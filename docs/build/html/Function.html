

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Functions &mdash; PsyNeuLink 0.1 documentation</title>
  

  
  

  

  
  
    

  

  
  
    <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  

  

  
        <link rel="index" title="Index"
              href="genindex.html"/>
        <link rel="search" title="Search" href="search.html"/>
    <link rel="top" title="PsyNeuLink 0.1 documentation" href="index.html"/>
        <link rel="next" title="Run" href="Run.html"/>
        <link rel="prev" title="MappingProjection" href="MappingProjection.html"/> 

  
  <script src="_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="index.html" class="icon icon-home"> PsyNeuLink
          

          
          </a>

          
            
            
              <div class="version">
                0.1
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
                <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="System.html">System</a></li>
<li class="toctree-l1"><a class="reference internal" href="Process.html">Process</a></li>
<li class="toctree-l1"><a class="reference internal" href="Mechanism.html">Mechanisms</a></li>
<li class="toctree-l1"><a class="reference internal" href="State.html">States</a></li>
<li class="toctree-l1"><a class="reference internal" href="Projection.html">Projections</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">Functions</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#overview">Overview</a></li>
<li class="toctree-l2"><a class="reference internal" href="#creating-a-function">Creating a Function</a></li>
<li class="toctree-l2"><a class="reference internal" href="#structure">Structure</a></li>
<li class="toctree-l2"><a class="reference internal" href="#execution">Execution</a></li>
<li class="toctree-l2"><a class="reference internal" href="#class-reference">Class Reference</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="Run.html">Run</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
        <a href="index.html">PsyNeuLink</a>
      </nav>


      
      <div class="wy-nav-content">
        <div class="rst-content">
          

 



<div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href="index.html">Docs</a> &raquo;</li>
      
    <li>Functions</li>
      <li class="wy-breadcrumbs-aside">
        
          
            <a href="_sources/Function.txt" rel="nofollow"> View page source</a>
          
        
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="functions">
<h1>Functions<a class="headerlink" href="#functions" title="Permalink to this headline">¶</a></h1>
<div class="toctree-wrapper compound">
</div>
<span class="target" id="module-Function"></span><dl class="docutils">
<dt>Example function:</dt>
<dd><ul class="first last simple">
<li><a class="reference internal" href="#Function.ArgumentTherapy" title="Function.ArgumentTherapy"><code class="xref any py py-class docutils literal"><span class="pre">ArgumentTherapy</span></code></a></li>
</ul>
</dd>
<dt>Combination Functions:</dt>
<dd><ul class="first last simple">
<li><a class="reference internal" href="#Function.Reduce" title="Function.Reduce"><code class="xref any py py-class docutils literal"><span class="pre">Reduce</span></code></a></li>
<li><a class="reference internal" href="#Function.LinearCombination" title="Function.LinearCombination"><code class="xref any py py-class docutils literal"><span class="pre">LinearCombination</span></code></a></li>
</ul>
</dd>
<dt>TransferMechanism Functions:</dt>
<dd><ul class="first last simple">
<li><a class="reference internal" href="#Function.Linear" title="Function.Linear"><code class="xref any py py-class docutils literal"><span class="pre">Linear</span></code></a></li>
<li><a class="reference internal" href="#Function.Exponential" title="Function.Exponential"><code class="xref any py py-class docutils literal"><span class="pre">Exponential</span></code></a></li>
<li><a class="reference internal" href="#Function.Logistic" title="Function.Logistic"><code class="xref any py py-class docutils literal"><span class="pre">Logistic</span></code></a></li>
<li><a class="reference internal" href="#Function.SoftMax" title="Function.SoftMax"><code class="xref any py py-class docutils literal"><span class="pre">SoftMax</span></code></a></li>
<li><a class="reference internal" href="#Function.LinearMatrix" title="Function.LinearMatrix"><code class="xref any py py-class docutils literal"><span class="pre">LinearMatrix</span></code></a></li>
</ul>
</dd>
<dt>Integrator Functions:</dt>
<dd><ul class="first last simple">
<li><a class="reference internal" href="#Function.Integrator" title="Function.Integrator"><code class="xref any py py-class docutils literal"><span class="pre">Integrator</span></code></a></li>
<li><a class="reference internal" href="#Function.BogaczEtAl" title="Function.BogaczEtAl"><code class="xref any py py-class docutils literal"><span class="pre">BogaczEtAl</span></code></a></li>
<li><a class="reference internal" href="#Function.NavarroAndFuss" title="Function.NavarroAndFuss"><code class="xref any py py-class docutils literal"><span class="pre">NavarroAndFuss</span></code></a></li>
</ul>
</dd>
<dt>Distribution Functions:</dt>
<dd><ul class="first last simple">
<li><code class="xref any docutils literal"><span class="pre">NormalDist</span></code></li>
<li><code class="xref any docutils literal"><span class="pre">ExponentialDist</span></code></li>
<li><code class="xref any docutils literal"><span class="pre">UniformDist</span></code></li>
<li><code class="xref any docutils literal"><span class="pre">GammaDist</span></code></li>
<li><code class="xref any docutils literal"><span class="pre">WaldDist</span></code></li>
</ul>
</dd>
<dt>Learning Functions:</dt>
<dd><ul class="first last simple">
<li><a class="reference internal" href="#Function.Reinforcement" title="Function.Reinforcement"><code class="xref any py py-class docutils literal"><span class="pre">Reinforcement</span></code></a></li>
<li><a class="reference internal" href="#Function.BackPropagation" title="Function.BackPropagation"><code class="xref any py py-class docutils literal"><span class="pre">BackPropagation</span></code></a></li>
</ul>
</dd>
</dl>
<div class="section" id="overview">
<span id="function-overview"></span><h2>Overview<a class="headerlink" href="#overview" title="Permalink to this headline">¶</a></h2>
<p>A Function is a <code class="xref any docutils literal"><span class="pre">component</span></code> that &#8220;packages&#8221; a function (in its <a class="reference internal" href="#Function.Function_Base.function" title="Function.Function_Base.function"><code class="xref any py py-attr docutils literal"><span class="pre">function</span></code></a> method)
for use by PsyNeuLink components.  Every <code class="xref any docutils literal"><span class="pre">component</span></code> in PsyNeuLink is assigned a Function, and when that
component is executed, that Function&#8217;s <code class="xref any docutils literal"><span class="pre">function</span> <span class="pre">&lt;Function_Base.function</span></code> is executed.  The
<code class="xref any docutils literal"><span class="pre">function</span> <span class="pre">&lt;Function_Base.function</span></code> can be any callable operation, although most commonly it is a mathematical operation
(and, for those, almost always uses calls to numpy function).</p>
<p>There are two reasons PsyNeuLink packages functions in a Function component. The first is to <strong>manage parameters</strong>.
Parameters are attributes of a function that either remain stable over multiple calls to the
function (e.g., the gain or bias of a logistic function, or the learning rate of a learning function);
or, if they change, they do less frequently or under the control of different factors than the function&#8217;s variable
(i.e., its input).  As a consequence, it is useful to manage these separately from the function&#8217;s variable,
and not have to provide them every time the function is called.  To address this, every PsyNeuLink Function has a
set of attributes corresponding to the parameters of the function, that can be specified at the time the Function is
created (in arguments to its constructor), and can be modified independently of a call to its <code class="xref std std-keyword docutils literal"><span class="pre">function</span></code>.
Modifications can be directly (e.g., in a script), or by the operation of other PsyNeuLink components (e.g.,
<code class="xref any docutils literal"><span class="pre">AdaptiveMechanisms</span></code>).  The second to reason PsyNeuLink uses Functions is for  <strong>modularity</strong>. By providing a standard
interface, any Function assigned to a components in PsyNeuLink can be replaced with other PsyNeuLink Functions, or with
user-written custom functions (so long as they adhere to certain standards (the PsyNeuLink <code class="xref any docutils literal"><span class="pre">Function</span> <span class="pre">API</span></code>).</p>
</div>
<div class="section" id="creating-a-function">
<span id="function-creation"></span><h2>Creating a Function<a class="headerlink" href="#creating-a-function" title="Permalink to this headline">¶</a></h2>
<p>A Function can be created directly by calling its constructor.  Functions are also created automatically whenever
any other type of PsyNeuLink component is created (and its <code class="xref std std-keyword docutils literal"><span class="pre">function</span></code> is not otherwise specified). The
constructor for a Function has an argument for its <a class="reference internal" href="#Function.Function_Base.variable" title="Function.Function_Base.variable"><code class="xref any py py-attr docutils literal"><span class="pre">variable</span></code></a> and each of the parameters of
its <a class="reference internal" href="#Function.Function_Base.function" title="Function.Function_Base.function"><code class="xref any py py-attr docutils literal"><span class="pre">function</span></code></a>.  The <a class="reference internal" href="#Function.Function_Base.variable" title="Function.Function_Base.variable"><code class="xref any py py-attr docutils literal"><span class="pre">variable</span></code></a> argument is used both to format the
input to the <a class="reference internal" href="#Function.Function_Base.function" title="Function.Function_Base.function"><code class="xref any py py-attr docutils literal"><span class="pre">function</span></code></a>, and assign its default value.  The arguments for each parameter can
be used to specify the default value for that parameter; the values can later be modified in various ways as described
below.</p>
</div>
<div class="section" id="structure">
<span id="function-structure"></span><h2>Structure<a class="headerlink" href="#structure" title="Permalink to this headline">¶</a></h2>
<p>Every Function has a <a class="reference internal" href="#Function.Function_Base.variable" title="Function.Function_Base.variable"><code class="xref any py py-attr docutils literal"><span class="pre">variable</span></code></a> that provides the input to its
<a class="reference internal" href="#Function.Function_Base.function" title="Function.Function_Base.function"><code class="xref any py py-attr docutils literal"><span class="pre">function</span></code></a> method.  It also has an attribute for each of the parameters of its <a class="reference internal" href="#Function.Function_Base.function" title="Function.Function_Base.function"><code class="xref any py py-attr docutils literal"><span class="pre">function</span></code></a>.   If a Function has been assigned to another component, then it also has an <a class="reference internal" href="#Function.Function_Base.owner" title="Function.Function_Base.owner"><code class="xref any py py-attr docutils literal"><span class="pre">owner</span></code></a> attribute that refers to that component. Each of the Function&#8217;s attributes is also assigned
as an attribute of the <a class="reference internal" href="#Function.Function_Base.owner" title="Function.Function_Base.owner"><code class="xref any py py-attr docutils literal"><span class="pre">owner</span></code></a>, and those are each associated with with a
<a class="reference internal" href="ParameterState.html"><span class="doc">parameterState</span></a> of the <a class="reference internal" href="#Function.Function_Base.owner" title="Function.Function_Base.owner"><code class="xref any py py-attr docutils literal"><span class="pre">owner</span></code></a>. Projections to those parameterStates can be
used to modify the Function&#8217;s parameters.</p>
</div>
<div class="section" id="execution">
<span id="function-execution"></span><h2>Execution<a class="headerlink" href="#execution" title="Permalink to this headline">¶</a></h2>
<p>Functions are not executable objects, but their <a class="reference internal" href="#Function.Function_Base.function" title="Function.Function_Base.function"><code class="xref any py py-attr docutils literal"><span class="pre">function</span></code></a> can be called.   This can be done
directly.  More commonly, however, they are called when their <a class="reference internal" href="#Function.Function_Base.owner" title="Function.Function_Base.owner"><code class="xref any py py-attr docutils literal"><span class="pre">owner</span></code></a> is executed.  The parameters
of the <a class="reference internal" href="#Function.Function_Base.function" title="Function.Function_Base.function"><code class="xref any py py-attr docutils literal"><span class="pre">function</span></code></a> can be modified when it is executed, by assigning a
<a class="reference internal" href="Mechanism.html#mechanism-creation"><span class="std std-ref">parameter specification dictionary</span></a> to the <code class="xref any docutils literal"><span class="pre">Function.params</span></code> argument in the call to the
<a class="reference internal" href="#Function.Function_Base.function" title="Function.Function_Base.function"><code class="xref any py py-attr docutils literal"><span class="pre">function</span></code></a>.  For <a class="reference internal" href="Mechanism.html"><span class="doc">mechanisms</span></a>, this can also be done by specifying <a class="reference internal" href="Mechanism.html#mechanism-runtime-parameters"><span class="std std-ref">runtime_params</span></a> for the mechanism when it is <a class="reference internal" href="Mechanism.html#Mechanism.Mechanism_Base.execute" title="Mechanism.Mechanism_Base.execute"><code class="xref any py py-meth docutils literal"><span class="pre">executed</span></code></a>.</p>
</div>
<div class="section" id="class-reference">
<h2>Class Reference<a class="headerlink" href="#class-reference" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="Function.Function_Base">
<em class="property">class </em><code class="descclassname">Function.</code><code class="descname">Function_Base</code><span class="sig-paren">(</span><em>variable_default</em>, <em>params=None</em>, <em>owner=None</em>, <em>name=None</em>, <em>prefs=None</em><span class="sig-paren">)</span><a class="headerlink" href="#Function.Function_Base" title="Permalink to this definition">¶</a></dt>
<dd><p>Implement abstract class for Function category of Component class</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>variable</strong> (<em>value : default variableClassDefault</em>) &#8211; specifies the format and a default value for the input to <a class="reference internal" href="#"><span class="doc">function</span></a>.</li>
<li><strong>params</strong> (<em>Optional[Dict[param keyword, param value]]</em>) &#8211; a <a class="reference internal" href="ParameterState.html#parameterstate-specifying-parameters"><span class="std std-ref">parameter dictionary</span></a> that specifies the parameters for the
function.  Values specified for parameters in the dictionary override any assigned to those parameters in
arguments of the constructor.</li>
<li><strong>owner</strong> (<em>Component</em>) &#8211; <code class="xref any docutils literal"><span class="pre">component</span></code> to which to assign the Function.</li>
<li><strong>prefs</strong> (<em>Optional[PreferenceSet or specification dict : Function.classPreferences]</em>) &#8211; the <code class="xref any docutils literal"><span class="pre">PreferenceSet</span></code> for the Function. If it is not specified, a default is assigned using <code class="xref any docutils literal"><span class="pre">classPreferences</span></code>
defined in __init__.py (see <span class="xref doc">PreferenceSet</span> for details).</li>
</ul>
</td>
</tr>
</tbody>
</table>
<dl class="attribute">
<dt id="Function.Function_Base.variable">
<code class="descname">variable</code><a class="headerlink" href="#Function.Function_Base.variable" title="Permalink to this definition">¶</a></dt>
<dd><p><em>value</em> &#8211; format and default value can be specified by the <code class="xref std std-keyword docutils literal"><span class="pre">variable</span></code> argument of the constructor;  otherwise,
they are specified by the Function&#8217;s <code class="xref std std-keyword docutils literal"><span class="pre">variableClassDefault</span></code>.</p>
</dd></dl>

<dl class="attribute">
<dt id="Function.Function_Base.function">
<code class="descname">function</code><a class="headerlink" href="#Function.Function_Base.function" title="Permalink to this definition">¶</a></dt>
<dd><p><em>function</em> &#8211; called by the Function&#8217;s <a class="reference internal" href="#Function.Function_Base.owner" title="Function.Function_Base.owner"><code class="xref any py py-attr docutils literal"><span class="pre">owner</span></code></a> when it is executed.</p>
</dd></dl>

<dl class="attribute">
<dt id="Function.Function_Base.owner">
<code class="descname">owner</code><a class="headerlink" href="#Function.Function_Base.owner" title="Permalink to this definition">¶</a></dt>
<dd><p><em>Mechanism</em> &#8211; <code class="xref any docutils literal"><span class="pre">component</span></code> to which the Function has been assigned.</p>
</dd></dl>

<dl class="attribute">
<dt id="Function.Function_Base.prefs">
<code class="descname">prefs</code><a class="headerlink" href="#Function.Function_Base.prefs" title="Permalink to this definition">¶</a></dt>
<dd><p><em>PreferenceSet or specification dict : Projection.classPreferences</em> &#8211; the <code class="xref any docutils literal"><span class="pre">PreferenceSet</span></code> for function. Specified in the <a class="reference internal" href="#Function.Function_Base.prefs" title="Function.Function_Base.prefs"><code class="xref any py py-attr docutils literal"><span class="pre">prefs</span></code></a> argument of the constructor for the function;
if it is not specified, a default is assigned using <code class="xref any docutils literal"><span class="pre">classPreferences</span></code> defined in __init__.py
(see <span class="xref doc">PreferenceSet</span> for details).</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="Function.ArgumentTherapy">
<em class="property">class </em><code class="descclassname">Function.</code><code class="descname">ArgumentTherapy</code><span class="sig-paren">(</span><em>variable</em>, <em>propensity=Manner.CONTRARIAN</em>, <em>pertinacity=10.0                       params=None</em>, <em>owner=None</em>, <em>name=None</em>, <em>prefs=None</em><span class="sig-paren">)</span><a class="headerlink" href="#Function.ArgumentTherapy" title="Permalink to this definition">¶</a></dt>
<dd><p id="argumenttherapist">Return <code class="xref std std-keyword docutils literal"><span class="pre">True</span></code> or <code class="xref std std-keyword docutils literal"><span class="pre">False</span></code> according to the manner of the therapist.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>variable</strong> (<em>boolean or statement that resolves to one : default variableClassDefault</em>) &#8211; assertion for which a therapeutic response will be offered.</li>
<li><strong>propensity</strong> (<em>Manner value : default Manner.CONTRARIAN</em>) &#8211; specifies preferred therapeutic manner</li>
<li><strong>pertinacity</strong> (<em>float : default 10.0</em>) &#8211; specifies therapeutic consistency</li>
<li><strong>params</strong> (<em>Optional[Dict[param keyword, param value]]</em>) &#8211; a <a class="reference internal" href="ParameterState.html#parameterstate-specifying-parameters"><span class="std std-ref">parameter dictionary</span></a> that specifies the parameters for the
function.  Values specified for parameters in the dictionary override any assigned to those parameters in
arguments of the constructor.</li>
<li><strong>owner</strong> (<em>Component</em>) &#8211; <code class="xref any docutils literal"><span class="pre">component</span></code> to which to assign the Function.</li>
<li><strong>prefs</strong> (<em>Optional[PreferenceSet or specification dict : Function.classPreferences]</em>) &#8211; the <code class="xref any docutils literal"><span class="pre">PreferenceSet</span></code> for the Function. If it is not specified, a default is assigned using <code class="xref any docutils literal"><span class="pre">classPreferences</span></code>
defined in __init__.py (see <span class="xref doc">PreferenceSet</span> for details).</li>
</ul>
</td>
</tr>
</tbody>
</table>
<dl class="attribute">
<dt id="Function.ArgumentTherapy.variable">
<code class="descname">variable</code><a class="headerlink" href="#Function.ArgumentTherapy.variable" title="Permalink to this definition">¶</a></dt>
<dd><p><em>boolean</em> &#8211; assertion to which a therapeutic response is made.</p>
</dd></dl>

<dl class="attribute">
<dt id="Function.ArgumentTherapy.propensity">
<code class="descname">propensity</code><a class="headerlink" href="#Function.ArgumentTherapy.propensity" title="Permalink to this definition">¶</a></dt>
<dd><p><em>Manner value : default Manner.CONTRARIAN</em> &#8211; determines therapeutic manner:  tendency to agree or disagree.</p>
</dd></dl>

<dl class="attribute">
<dt id="Function.ArgumentTherapy.pertinacity">
<code class="descname">pertinacity</code><a class="headerlink" href="#Function.ArgumentTherapy.pertinacity" title="Permalink to this definition">¶</a></dt>
<dd><p><em>float : default 10.0</em> &#8211; determines consistency with which the manner complies with the propensity.</p>
</dd></dl>

<dl class="attribute">
<dt id="Function.ArgumentTherapy.owner">
<code class="descname">owner</code><a class="headerlink" href="#Function.ArgumentTherapy.owner" title="Permalink to this definition">¶</a></dt>
<dd><p><em>Mechanism</em> &#8211; <code class="xref any docutils literal"><span class="pre">component</span></code> to which the Function has been assigned.</p>
</dd></dl>

<dl class="attribute">
<dt id="Function.ArgumentTherapy.prefs">
<code class="descname">prefs</code><a class="headerlink" href="#Function.ArgumentTherapy.prefs" title="Permalink to this definition">¶</a></dt>
<dd><p><em>PreferenceSet or specification dict : Projection.classPreferences</em> &#8211; the <code class="xref any docutils literal"><span class="pre">PreferenceSet</span></code> for function. Specified in the <a class="reference internal" href="#Function.ArgumentTherapy.prefs" title="Function.ArgumentTherapy.prefs"><code class="xref any py py-attr docutils literal"><span class="pre">prefs</span></code></a> argument of the constructor for the function;
if it is not specified, a default is assigned using <code class="xref any docutils literal"><span class="pre">classPreferences</span></code> defined in __init__.py
(see <span class="xref doc">PreferenceSet</span> for details).</p>
</dd></dl>

<dl class="class">
<dt id="Function.ArgumentTherapy.Manner">
<em class="property">class </em><code class="descname">Manner</code><a class="headerlink" href="#Function.ArgumentTherapy.Manner" title="Permalink to this definition">¶</a></dt>
<dd><p>An enumeration.</p>
</dd></dl>

<dl class="method">
<dt id="Function.ArgumentTherapy.function">
<code class="descclassname">ArgumentTherapy.</code><code class="descname">function</code><span class="sig-paren">(</span><em>variable=None</em>, <em>params=None</em>, <em>time_scale=&lt;TimeScale.TRIAL: 1&gt;</em>, <em>context=None</em><span class="sig-paren">)</span><a class="headerlink" href="#Function.ArgumentTherapy.function" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a boolean that is (or tends to be) the same as or opposite the one passed in.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>variable</strong> (<em>boolean : default variableClassDefault</em>) &#8211; an assertion to which a therapeutic response is made.</li>
<li><strong>params</strong> (<em>Optional[Dict[param keyword, param value]]</em>) &#8211; a <a class="reference internal" href="ParameterState.html#parameterstate-specifying-parameters"><span class="std std-ref">parameter dictionary</span></a> that specifies the parameters for the
function.  Values specified for parameters in the dictionary override any assigned to those parameters in
arguments of the constructor.</li>
<li><strong>time_scale</strong> (<em>TimeScale : default TimeScale.TRIAL</em>) &#8211; specifies whether the function is executed on the time_step or trial time scale.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>therapeutic response</strong></p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">boolean</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="Function.UserDefinedFunction">
<em class="property">class </em><code class="descclassname">Function.</code><code class="descname">UserDefinedFunction</code><span class="sig-paren">(</span><em>function</em>, <em>variable=None</em>, <em>params=None</em>, <em>owner=None</em>, <em>name=None</em>, <em>prefs=None</em><span class="sig-paren">)</span><a class="headerlink" href="#Function.UserDefinedFunction" title="Permalink to this definition">¶</a></dt>
<dd><p>Implement user-defined Function.</p>
<p>This is used to &#8220;wrap&#8221; custom functions in the PsyNeuLink <code class="xref any docutils literal"><span class="pre">Function</span> <span class="pre">API</span></code>.
It is automatically invoked and applied to any function that is assigned to the <code class="xref any docutils literal"><span class="pre">function</span></code>
attribute of a PsyNeuLink component (other than a Function itself).  The function can take any arguments and
return any values.  However, if UserDefinedFunction is used to create a custom version of another PsyNeuLink
<a class="reference internal" href="#"><span class="doc">Function</span></a>, then it must conform to the requirements of that Function&#8217;s type.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Currently the arguments for the <a class="reference internal" href="#Function.UserDefinedFunction.function" title="Function.UserDefinedFunction.function"><code class="xref any py py-attr docutils literal"><span class="pre">function</span></code></a> of a UserDefinedFunction are NOT
assigned as attributes of the UserDefinedFunction object or its owner, nor to its <code class="xref std std-keyword docutils literal"><span class="pre">user_params</span></code> dict.</p>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>function</strong> (<a class="reference internal" href="#Function.UserDefinedFunction.function" title="Function.UserDefinedFunction.function"><em>function</em></a>) &#8211; specifies function to &#8220;wrap.&#8221; It can be any function, take any arguments (including standard ones,
such as <code class="xref std std-keyword docutils literal"><span class="pre">params</span></code> and <code class="xref std std-keyword docutils literal"><span class="pre">context</span></code>) and return any value(s), so long as these are consistent
with the context in which the UserDefinedFunction will be used.</li>
<li><strong>variable</strong> (<em>value : default variableClassDefault</em>) &#8211; specifies the format and a default value for the input to <a class="reference internal" href="#"><span class="doc">function</span></a>.</li>
<li><strong>params</strong> (<em>Optional[Dict[param keyword, param value]]</em>) &#8211; a <a class="reference internal" href="ParameterState.html#parameterstate-specifying-parameters"><span class="std std-ref">parameter dictionary</span></a> that specifies the parameters for the
function.  Values specified for parameters in the dictionary override any assigned to those parameters in
arguments of the constructor.</li>
<li><strong>owner</strong> (<em>Component</em>) &#8211; <code class="xref any docutils literal"><span class="pre">component</span></code> to which to assign the Function.</li>
<li><strong>prefs</strong> (<em>Optional[PreferenceSet or specification dict : Function.classPreferences]</em>) &#8211; the <code class="xref any docutils literal"><span class="pre">PreferenceSet</span></code> for the Function. If it is not specified, a default is assigned using <code class="xref any docutils literal"><span class="pre">classPreferences</span></code>
defined in __init__.py (see <span class="xref doc">PreferenceSet</span> for details).</li>
</ul>
</td>
</tr>
</tbody>
</table>
<dl class="attribute">
<dt id="Function.UserDefinedFunction.variable">
<code class="descname">variable</code><a class="headerlink" href="#Function.UserDefinedFunction.variable" title="Permalink to this definition">¶</a></dt>
<dd><p><em>value</em> &#8211; format and default value can be specified by the <code class="xref std std-keyword docutils literal"><span class="pre">variable</span></code> argument of the constructor;  otherwise,
they are specified by the Function&#8217;s <code class="xref std std-keyword docutils literal"><span class="pre">variableClassDefault</span></code>.</p>
</dd></dl>

<dl class="attribute">
<dt id="Function.UserDefinedFunction.function">
<code class="descname">function</code><a class="headerlink" href="#Function.UserDefinedFunction.function" title="Permalink to this definition">¶</a></dt>
<dd><p><em>function</em> &#8211; called by the Function&#8217;s <a class="reference internal" href="#Function.Function_Base.owner" title="Function.Function_Base.owner"><code class="xref any py py-attr docutils literal"><span class="pre">owner</span></code></a> when it is executed.</p>
</dd></dl>

<dl class="attribute">
<dt id="Function.UserDefinedFunction.owner">
<code class="descname">owner</code><a class="headerlink" href="#Function.UserDefinedFunction.owner" title="Permalink to this definition">¶</a></dt>
<dd><p><em>Mechanism</em> &#8211; <code class="xref any docutils literal"><span class="pre">component</span></code> to which the Function has been assigned.</p>
</dd></dl>

<dl class="attribute">
<dt id="Function.UserDefinedFunction.prefs">
<code class="descname">prefs</code><a class="headerlink" href="#Function.UserDefinedFunction.prefs" title="Permalink to this definition">¶</a></dt>
<dd><p><em>PreferenceSet or specification dict : Projection.classPreferences</em> &#8211; the <code class="xref any docutils literal"><span class="pre">PreferenceSet</span></code> for function. Specified in the <a class="reference internal" href="#Function.UserDefinedFunction.prefs" title="Function.UserDefinedFunction.prefs"><code class="xref any py py-attr docutils literal"><span class="pre">prefs</span></code></a> argument of the constructor for the function;
if it is not specified, a default is assigned using <code class="xref any docutils literal"><span class="pre">classPreferences</span></code> defined in __init__.py
(see <span class="xref doc">PreferenceSet</span> for details).</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="Function.Reduce">
<em class="property">class </em><code class="descclassname">Function.</code><code class="descname">Reduce</code><span class="sig-paren">(</span><em>variable_default=variableClassDefault</em>, <em>operation=SUM</em>, <em>params=None</em>, <em>owner=None</em>, <em>prefs=None</em><span class="sig-paren">)</span><a class="headerlink" href="#Function.Reduce" title="Permalink to this definition">¶</a></dt>
<dd><p id="reduce">Combine values in each of one or more arrays into a single value for each array.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>variable_default</strong> (<em>list or np.array : default variableClassDefault</em>) &#8211; specifies a template for the value to be transformed and its default value;  all entries must be numeric.</li>
<li><strong>operation</strong> (<em>SUM or PRODUCT : default SUM</em>) &#8211; specifies whether to sum or multiply the elements in <code class="xref any docutils literal"><span class="pre">variable</span></code> of
<a class="reference internal" href="#Function.Reduce.function" title="Function.Reduce.function"><code class="xref any py py-meth docutils literal"><span class="pre">function</span></code></a>.</li>
<li><strong>params</strong> (<em>Optional[Dict[param keyword, param value]]</em>) &#8211; a <a class="reference internal" href="ParameterState.html#parameterstate-specifying-parameters"><span class="std std-ref">parameter dictionary</span></a> that specifies the parameters for the
function.  Values specified for parameters in the dictionary override any assigned to those parameters in
arguments of the constructor.</li>
<li><strong>owner</strong> (<em>Component</em>) &#8211; <code class="xref any docutils literal"><span class="pre">component</span></code> to which to assign the Function.</li>
<li><strong>prefs</strong> (<em>Optional[PreferenceSet or specification dict : Function.classPreferences]</em>) &#8211; the <code class="xref any docutils literal"><span class="pre">PreferenceSet</span></code> for the Function. If it is not specified, a default is assigned using <code class="xref any docutils literal"><span class="pre">classPreferences</span></code>
defined in __init__.py (see <span class="xref doc">PreferenceSet</span> for details).</li>
</ul>
</td>
</tr>
</tbody>
</table>
<dl class="attribute">
<dt id="Function.Reduce.variable_default">
<code class="descname">variable_default</code><a class="headerlink" href="#Function.Reduce.variable_default" title="Permalink to this definition">¶</a></dt>
<dd><p><em>list or np.array</em> &#8211; contains array(s) to be reduced.</p>
</dd></dl>

<dl class="attribute">
<dt id="Function.Reduce.operation">
<code class="descname">operation</code><a class="headerlink" href="#Function.Reduce.operation" title="Permalink to this definition">¶</a></dt>
<dd><p><em>SUM or PRODUCT</em> &#8211; determines whether elements of each array in <code class="xref any docutils literal"><span class="pre">variable</span></code> of
<a class="reference internal" href="#Function.Reduce.function" title="Function.Reduce.function"><code class="xref any py py-meth docutils literal"><span class="pre">function</span></code></a> are summmed or multiplied.</p>
</dd></dl>

<dl class="attribute">
<dt id="Function.Reduce.owner">
<code class="descname">owner</code><a class="headerlink" href="#Function.Reduce.owner" title="Permalink to this definition">¶</a></dt>
<dd><p><em>Mechanism</em> &#8211; <code class="xref any docutils literal"><span class="pre">component</span></code> to which the Function has been assigned.</p>
</dd></dl>

<dl class="attribute">
<dt id="Function.Reduce.prefs">
<code class="descname">prefs</code><a class="headerlink" href="#Function.Reduce.prefs" title="Permalink to this definition">¶</a></dt>
<dd><p><em>PreferenceSet or specification dict : Projection.classPreferences</em> &#8211; the <code class="xref any docutils literal"><span class="pre">PreferenceSet</span></code> for function. Specified in the <a class="reference internal" href="#Function.Reduce.prefs" title="Function.Reduce.prefs"><code class="xref any py py-attr docutils literal"><span class="pre">prefs</span></code></a> argument of the constructor for the function;
if it is not specified, a default is assigned using <code class="xref any docutils literal"><span class="pre">classPreferences</span></code> defined in __init__.py
(see <span class="xref doc">PreferenceSet</span> for details).</p>
</dd></dl>

<dl class="method">
<dt id="Function.Reduce.function">
<code class="descname">function</code><span class="sig-paren">(</span><em>variable=None</em>, <em>params=None</em>, <em>time_scale=&lt;TimeScale.TRIAL: 1&gt;</em>, <em>context=None</em><span class="sig-paren">)</span><a class="headerlink" href="#Function.Reduce.function" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a scalar value for each array in <code class="xref any docutils literal"><span class="pre">variable</span></code> that is either the sum or
product of the elements in that array.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>variable</strong> (<em>list or np.array : default variableClassDefault</em>) &#8211; a list or np.array of numeric values.</li>
<li><strong>params</strong> (<em>Optional[Dict[param keyword, param value]]</em>) &#8211; a <a class="reference internal" href="ParameterState.html#parameterstate-specifying-parameters"><span class="std std-ref">parameter dictionary</span></a> that specifies the parameters for the
function.  Values specified for parameters in the dictionary override any assigned to those parameters in
arguments of the constructor.</li>
<li><strong>time_scale</strong> (<em>TimeScale : default TimeScale.TRIAL</em>) &#8211; specifies whether the function is executed on the time_step or trial time scale.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>Sum or product of arrays in variable</strong> &#8211; in an array that is one dimension less than <code class="xref any docutils literal"><span class="pre">variable</span></code>.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">np.array</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="Function.LinearCombination">
<em class="property">class </em><code class="descclassname">Function.</code><code class="descname">LinearCombination</code><span class="sig-paren">(</span><em>variable_default</em>, <em>weights=None</em>, <em>exponents=None</em>, <em>scale=1.0</em>, <em>offset=0.0</em>, <em>operation=SUM</em>, <em>params=None</em>, <em>owner=None</em>, <em>name=None</em>, <em>prefs=None</em><span class="sig-paren">)</span><a class="headerlink" href="#Function.LinearCombination" title="Permalink to this definition">¶</a></dt>
<dd><p id="linearcombination">Linearly combine arrays of values with optional weighting, exponentiation, scaling and/or offset.</p>
<p>Combines the arrays in the items of the <a class="reference internal" href="#Function.LinearCombination.variable" title="Function.LinearCombination.variable"><code class="xref any py py-attr docutils literal"><span class="pre">variable</span></code></a> argument.  Each array can be
individually weighted and/or exponentiated; they can combined additively or multiplicatively; and the resulting
array can be multiplicatively transformed and/or additively offset.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>variable</strong> (<em>1d or 2d np.array : default variableClassDefault</em>) &#8211; specifies a template for the arrays to be combined.  If it is 2d, all items must have the same length.</li>
<li><strong>weights</strong> (<em>1d or 2d np.array</em>) &#8211; specifies values used to multiply the elements of each array in <a class="reference internal" href="#Function.LinearCombination.variable" title="Function.LinearCombination.variable"><code class="xref any py py-attr docutils literal"><span class="pre">variable</span></code></a>.
If it is 1d, its length must equal the number of items in <a class="reference internal" href="#Function.LinearCombination.variable" title="Function.LinearCombination.variable"><code class="xref any py py-attr docutils literal"><span class="pre">variable</span></code></a>;
if it is 2d, the length of each item must be the same as those in <a class="reference internal" href="#Function.LinearCombination.variable" title="Function.LinearCombination.variable"><code class="xref any py py-attr docutils literal"><span class="pre">variable</span></code></a>,
and there must be the same number of items as there are in <a class="reference internal" href="#Function.LinearCombination.variable" title="Function.LinearCombination.variable"><code class="xref any py py-attr docutils literal"><span class="pre">variable</span></code></a>
(see <a class="reference internal" href="#Function.LinearCombination.weights" title="Function.LinearCombination.weights"><code class="xref any py py-attr docutils literal"><span class="pre">weights</span></code></a> for details)</li>
<li><strong>exponents</strong> (<em>1d or 2d np.array</em>) &#8211; specifies values used to exponentiate the elements of each array in <a class="reference internal" href="#Function.LinearCombination.variable" title="Function.LinearCombination.variable"><code class="xref any py py-attr docutils literal"><span class="pre">variable</span></code></a>.
If it is 1d, its length must equal the number of items in <a class="reference internal" href="#Function.LinearCombination.variable" title="Function.LinearCombination.variable"><code class="xref any py py-attr docutils literal"><span class="pre">variable</span></code></a>;
if it is 2d, the length of each item must be the same as those in <a class="reference internal" href="#Function.LinearCombination.variable" title="Function.LinearCombination.variable"><code class="xref any py py-attr docutils literal"><span class="pre">variable</span></code></a>,
and there must be the same number of items as there are in <a class="reference internal" href="#Function.LinearCombination.variable" title="Function.LinearCombination.variable"><code class="xref any py py-attr docutils literal"><span class="pre">variable</span></code></a>
(see <a class="reference internal" href="#Function.LinearCombination.exponents" title="Function.LinearCombination.exponents"><code class="xref any py py-attr docutils literal"><span class="pre">exponents</span></code></a> for details)</li>
<li><strong>scale</strong> (<em>float</em>) &#8211; specifies a value by which to multiply each element of the output of <a class="reference internal" href="#Function.LinearCombination.function" title="Function.LinearCombination.function"><code class="xref any py py-meth docutils literal"><span class="pre">function</span></code></a>
(see <a class="reference internal" href="#Function.LinearCombination.scale" title="Function.LinearCombination.scale"><code class="xref any py py-attr docutils literal"><span class="pre">scale</span></code></a> for details)</li>
<li><strong>offset</strong> (<em>float</em>) &#8211; specifies a value to add to each element of the output of <a class="reference internal" href="#Function.LinearCombination.function" title="Function.LinearCombination.function"><code class="xref any py py-meth docutils literal"><span class="pre">function</span></code></a>
(see <a class="reference internal" href="#Function.LinearCombination.offset" title="Function.LinearCombination.offset"><code class="xref any py py-attr docutils literal"><span class="pre">offset</span></code></a> for details)</li>
<li><strong>operation</strong> (<em>SUM or PRODUCT</em>) &#8211; specifies whether the <a class="reference internal" href="#Function.LinearCombination.function" title="Function.LinearCombination.function"><code class="xref any py py-meth docutils literal"><span class="pre">function</span></code></a> takes the elementwise (Hadamarad)
sum or product of the arrays in <a class="reference internal" href="#Function.LinearCombination.variable" title="Function.LinearCombination.variable"><code class="xref any py py-attr docutils literal"><span class="pre">variable</span></code></a>.</li>
<li><strong>params</strong> (<em>Optional[Dict[param keyword, param value]]</em>) &#8211; a <a class="reference internal" href="ParameterState.html#parameterstate-specifying-parameters"><span class="std std-ref">parameter dictionary</span></a> that specifies the parameters for the
function.  Values specified for parameters in the dictionary override any assigned to those parameters in
arguments of the constructor.</li>
<li><strong>owner</strong> (<em>Component</em>) &#8211; <code class="xref any docutils literal"><span class="pre">component</span></code> to which to assign the Function.</li>
<li><strong>prefs</strong> (<em>Optional[PreferenceSet or specification dict : Function.classPreferences]</em>) &#8211; the <code class="xref any docutils literal"><span class="pre">PreferenceSet</span></code> for the Function. If it is not specified, a default is assigned using <code class="xref any docutils literal"><span class="pre">classPreferences</span></code>
defined in __init__.py (see <span class="xref doc">PreferenceSet</span> for details).</li>
</ul>
</td>
</tr>
</tbody>
</table>
<dl class="attribute">
<dt id="Function.LinearCombination.variable">
<code class="descname">variable</code><a class="headerlink" href="#Function.LinearCombination.variable" title="Permalink to this definition">¶</a></dt>
<dd><p><em>1d or 2d np.array</em> &#8211; contains the arrays to be combined by <a class="reference internal" href="#linearcombination"><span class="std std-ref">function</span></a>.  If it is 1d, the array is simply
linearly transformed by and <a class="reference internal" href="#Function.LinearCombination.scale" title="Function.LinearCombination.scale"><code class="xref any py py-attr docutils literal"><span class="pre">scale</span></code></a> and <a class="reference internal" href="#Function.LinearCombination.scale" title="Function.LinearCombination.scale"><code class="xref any py py-attr docutils literal"><span class="pre">offset</span></code></a>.
If it is 2d, the arrays (all of which must be of equal length) are weighted and/or exponentiated as
specified by <a class="reference internal" href="#Function.LinearCombination.weights" title="Function.LinearCombination.weights"><code class="xref any py py-attr docutils literal"><span class="pre">weights</span></code></a> and/or <a class="reference internal" href="#Function.LinearCombination.exponents" title="Function.LinearCombination.exponents"><code class="xref any py py-attr docutils literal"><span class="pre">exponents</span></code></a>
and then combined as specified by <a class="reference internal" href="#Function.LinearCombination.operation" title="Function.LinearCombination.operation"><code class="xref any py py-attr docutils literal"><span class="pre">operation</span></code></a>.</p>
</dd></dl>

<dl class="attribute">
<dt id="Function.LinearCombination.weights">
<code class="descname">weights</code><a class="headerlink" href="#Function.LinearCombination.weights" title="Permalink to this definition">¶</a></dt>
<dd><p><em>1d or 2d np.array</em> &#8211; if it is 1d, each element is used to multiply all elements in the corresponding array of
<a class="reference internal" href="#Function.LinearCombination.variable" title="Function.LinearCombination.variable"><code class="xref any py py-attr docutils literal"><span class="pre">variable</span></code></a>;    if it is 2d, then each array is multiplied elementwise
(i.e., the Hadamard Product is taken) with the corresponding array of <code class="xref any docutils literal"><span class="pre">variable</span></code>.
All <code class="xref std std-keyword docutils literal"><span class="pre">weights</span></code> are applied before any exponentiation (if it is specified).</p>
</dd></dl>

<dl class="attribute">
<dt id="Function.LinearCombination.exponents">
<code class="descname">exponents</code><a class="headerlink" href="#Function.LinearCombination.exponents" title="Permalink to this definition">¶</a></dt>
<dd><p><em>1d or 2d np.array</em> &#8211; if it is 1d, each element is used to exponentiate the elements of the corresponding array of
<code class="xref any docutils literal"><span class="pre">variable</span></code>;  if it is 2d, the element of each array is used to exponentiate
the correspnding element of the corresponding array of <a class="reference internal" href="#Function.LinearCombination.variable" title="Function.LinearCombination.variable"><code class="xref any py py-attr docutils literal"><span class="pre">variable</span></code></a>.
In either case, exponentiating is applied after application of the <a class="reference internal" href="#Function.LinearCombination.weights" title="Function.LinearCombination.weights"><code class="xref any py py-attr docutils literal"><span class="pre">weights</span></code></a>
(if any are specified).</p>
</dd></dl>

<dl class="attribute">
<dt id="Function.LinearCombination.scale">
<code class="descname">scale</code><a class="headerlink" href="#Function.LinearCombination.scale" title="Permalink to this definition">¶</a></dt>
<dd><p><em>float</em> &#8211; value is multiplied by each element of the array after applying the <a class="reference internal" href="#Function.LinearCombination.operation" title="Function.LinearCombination.operation"><code class="xref any py py-attr docutils literal"><span class="pre">operation</span></code></a>
(see <a class="reference internal" href="#Function.LinearCombination.scale" title="Function.LinearCombination.scale"><code class="xref any py py-attr docutils literal"><span class="pre">scale</span></code></a> for details);  this done before applying the
<a class="reference internal" href="#Function.LinearCombination.offset" title="Function.LinearCombination.offset"><code class="xref any py py-attr docutils literal"><span class="pre">offset</span></code></a> (if it is specified).</p>
</dd></dl>

<dl class="attribute">
<dt id="Function.LinearCombination.offset">
<code class="descname">offset</code><a class="headerlink" href="#Function.LinearCombination.offset" title="Permalink to this definition">¶</a></dt>
<dd><p><em>float</em> &#8211; value is added to each element of the array after applying the <a class="reference internal" href="#Function.LinearCombination.operation" title="Function.LinearCombination.operation"><code class="xref any py py-attr docutils literal"><span class="pre">operation</span></code></a>
and <a class="reference internal" href="#Function.LinearCombination.scale" title="Function.LinearCombination.scale"><code class="xref any py py-attr docutils literal"><span class="pre">scale</span></code></a> (if it is specified).</p>
</dd></dl>

<dl class="attribute">
<dt id="Function.LinearCombination.operation">
<code class="descname">operation</code><a class="headerlink" href="#Function.LinearCombination.operation" title="Permalink to this definition">¶</a></dt>
<dd><p><em>SUM or PRODUCT</em> &#8211; determines whether the <a class="reference internal" href="#Function.LinearCombination.function" title="Function.LinearCombination.function"><code class="xref any py py-meth docutils literal"><span class="pre">function</span></code></a> takes the elementwise (Hadamard) sum or
product of the arrays in <a class="reference internal" href="#Function.LinearCombination.variable" title="Function.LinearCombination.variable"><code class="xref any py py-attr docutils literal"><span class="pre">variable</span></code></a>.</p>
</dd></dl>

<dl class="attribute">
<dt id="Function.LinearCombination.owner">
<code class="descname">owner</code><a class="headerlink" href="#Function.LinearCombination.owner" title="Permalink to this definition">¶</a></dt>
<dd><p><em>Mechanism</em> &#8211; <code class="xref any docutils literal"><span class="pre">component</span></code> to which the Function has been assigned.</p>
</dd></dl>

<dl class="attribute">
<dt id="Function.LinearCombination.prefs">
<code class="descname">prefs</code><a class="headerlink" href="#Function.LinearCombination.prefs" title="Permalink to this definition">¶</a></dt>
<dd><p><em>PreferenceSet or specification dict : Projection.classPreferences</em> &#8211; the <code class="xref any docutils literal"><span class="pre">PreferenceSet</span></code> for function. Specified in the <a class="reference internal" href="#Function.LinearCombination.prefs" title="Function.LinearCombination.prefs"><code class="xref any py py-attr docutils literal"><span class="pre">prefs</span></code></a> argument of the constructor for the function;
if it is not specified, a default is assigned using <code class="xref any docutils literal"><span class="pre">classPreferences</span></code> defined in __init__.py
(see <span class="xref doc">PreferenceSet</span> for details).</p>
</dd></dl>

<dl class="method">
<dt id="Function.LinearCombination.function">
<code class="descname">function</code><span class="sig-paren">(</span><em>variable=None</em>, <em>params=None</em>, <em>time_scale=&lt;TimeScale.TRIAL: 1&gt;</em>, <em>context=None</em><span class="sig-paren">)</span><a class="headerlink" href="#Function.LinearCombination.function" title="Permalink to this definition">¶</a></dt>
<dd><p>Apply <a class="reference internal" href="#Function.LinearCombination.weights" title="Function.LinearCombination.weights"><code class="xref any py py-attr docutils literal"><span class="pre">weights</span></code></a> and/or <code class="xref any docutils literal"><span class="pre">exponents</span></code> to the
arrays in <a class="reference internal" href="#Function.LinearCombination.variable" title="Function.LinearCombination.variable"><code class="xref any py py-attr docutils literal"><span class="pre">variable</span></code></a>, then take their sum or product (as specified by
<a class="reference internal" href="#Function.LinearCombination.operation" title="Function.LinearCombination.operation"><code class="xref any py py-attr docutils literal"><span class="pre">operation</span></code></a>), apply <a class="reference internal" href="#Function.LinearCombination.scale" title="Function.LinearCombination.scale"><code class="xref any py py-attr docutils literal"><span class="pre">scale</span></code></a> and/or <a class="reference internal" href="#Function.LinearCombination.offset" title="Function.LinearCombination.offset"><code class="xref any py py-attr docutils literal"><span class="pre">offset</span></code></a>, and return the resulting array.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>variable</strong> (<em>1d or 2d np.array : default variableClassDefault</em>) &#8211; a single numeric array, or multiple arrays to be combined; if it is 2d, all arrays must have the same length.</li>
<li><strong>params</strong> (<em>Optional[Dict[param keyword, param value]]</em>) &#8211; a <a class="reference internal" href="ParameterState.html#parameterstate-specifying-parameters"><span class="std std-ref">parameter dictionary</span></a> that specifies the parameters for the
function.  Values specified for parameters in the dictionary override any assigned to those parameters in
arguments of the constructor.</li>
<li><strong>time_scale</strong> (<em>TimeScale : default TimeScale.TRIAL</em>) &#8211; specifies whether the function is executed on the time_step or trial time scale.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>combined array</strong> &#8211; the result of linearly combining the arrays in <a class="reference internal" href="#Function.LinearCombination.variable" title="Function.LinearCombination.variable"><code class="xref any py py-attr docutils literal"><span class="pre">variable</span></code></a>.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">1d np.array</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="Function.Linear">
<em class="property">class </em><code class="descclassname">Function.</code><code class="descname">Linear</code><span class="sig-paren">(</span><em>variable_default</em>, <em>slope=1.0</em>, <em>intercept=0.0</em>, <em>params=None</em>, <em>owner=None</em>, <em>name=None</em>, <em>prefs=None</em><span class="sig-paren">)</span><a class="headerlink" href="#Function.Linear" title="Permalink to this definition">¶</a></dt>
<dd><p id="linear">Linearly transform variable.</p>
<p>Note: default values for <a class="reference internal" href="#Function.Linear.slope" title="Function.Linear.slope"><code class="xref any py py-attr docutils literal"><span class="pre">slope</span></code></a> and <a class="reference internal" href="#Function.Linear.intercept" title="Function.Linear.intercept"><code class="xref any py py-attr docutils literal"><span class="pre">intercept</span></code></a> implement the IDENTITY_FUNCTION</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>variable</strong> (<em>number or np.array : default variableClassDefault</em>) &#8211; specifies a template for the value to be transformed.</li>
<li><strong>slope</strong> (<em>float : default 1.0</em>) &#8211; specifies a value by which to multiply <a class="reference internal" href="#Function.Linear.variable" title="Function.Linear.variable"><code class="xref any py py-attr docutils literal"><span class="pre">variable</span></code></a>.</li>
<li><strong>intercept</strong> (<em>float : default 0.0</em>) &#8211; specifies a value to add to each element of <a class="reference internal" href="#Function.Linear.variable" title="Function.Linear.variable"><code class="xref any py py-attr docutils literal"><span class="pre">variable</span></code></a> after applying <a class="reference internal" href="#Function.Linear.slope" title="Function.Linear.slope"><code class="xref any py py-attr docutils literal"><span class="pre">slope</span></code></a>.</li>
<li><strong>params</strong> (<em>Optional[Dict[param keyword, param value]]</em>) &#8211; a <a class="reference internal" href="ParameterState.html#parameterstate-specifying-parameters"><span class="std std-ref">parameter dictionary</span></a> that specifies the parameters for the
function.  Values specified for parameters in the dictionary override any assigned to those parameters in
arguments of the constructor.</li>
<li><strong>owner</strong> (<em>Component</em>) &#8211; <code class="xref any docutils literal"><span class="pre">component</span></code> to which to assign the Function.</li>
<li><strong>prefs</strong> (<em>Optional[PreferenceSet or specification dict : Function.classPreferences]</em>) &#8211; the <code class="xref any docutils literal"><span class="pre">PreferenceSet</span></code> for the Function. If it is not specified, a default is assigned using <code class="xref any docutils literal"><span class="pre">classPreferences</span></code>
defined in __init__.py (see <span class="xref doc">PreferenceSet</span> for details).</li>
</ul>
</td>
</tr>
</tbody>
</table>
<dl class="attribute">
<dt id="Function.Linear.variable">
<code class="descname">variable</code><a class="headerlink" href="#Function.Linear.variable" title="Permalink to this definition">¶</a></dt>
<dd><p><em>number or np.array</em> &#8211; contains value to be transformed.</p>
</dd></dl>

<dl class="attribute">
<dt id="Function.Linear.slope">
<code class="descname">slope</code><a class="headerlink" href="#Function.Linear.slope" title="Permalink to this definition">¶</a></dt>
<dd><p><em>float</em> &#8211; value by which each element of <a class="reference internal" href="#Function.Linear.variable" title="Function.Linear.variable"><code class="xref any py py-attr docutils literal"><span class="pre">variable</span></code></a> is multiplied before applying the
<a class="reference internal" href="#Function.Linear.intercept" title="Function.Linear.intercept"><code class="xref any py py-attr docutils literal"><span class="pre">intercept</span></code></a> (if it is specified).</p>
</dd></dl>

<dl class="attribute">
<dt id="Function.Linear.intercept">
<code class="descname">intercept</code><a class="headerlink" href="#Function.Linear.intercept" title="Permalink to this definition">¶</a></dt>
<dd><p><em>float</em> &#8211; value added to each element of <a class="reference internal" href="#Function.Linear.variable" title="Function.Linear.variable"><code class="xref any py py-attr docutils literal"><span class="pre">variable</span></code></a> after applying the <a class="reference internal" href="#Function.Linear.slope" title="Function.Linear.slope"><code class="xref any py py-attr docutils literal"><span class="pre">slope</span></code></a>
(if it is specified).</p>
</dd></dl>

<dl class="attribute">
<dt id="Function.Linear.owner">
<code class="descname">owner</code><a class="headerlink" href="#Function.Linear.owner" title="Permalink to this definition">¶</a></dt>
<dd><p><em>Mechanism</em> &#8211; <code class="xref any docutils literal"><span class="pre">component</span></code> to which the Function has been assigned.</p>
</dd></dl>

<dl class="attribute">
<dt id="Function.Linear.prefs">
<code class="descname">prefs</code><a class="headerlink" href="#Function.Linear.prefs" title="Permalink to this definition">¶</a></dt>
<dd><p><em>PreferenceSet or specification dict : Projection.classPreferences</em> &#8211; the <code class="xref any docutils literal"><span class="pre">PreferenceSet</span></code> for function. Specified in the <a class="reference internal" href="#Function.Linear.prefs" title="Function.Linear.prefs"><code class="xref any py py-attr docutils literal"><span class="pre">prefs</span></code></a> argument of the constructor for the function;
if it is not specified, a default is assigned using <code class="xref any docutils literal"><span class="pre">classPreferences</span></code> defined in __init__.py
(see <span class="xref doc">PreferenceSet</span> for details).</p>
</dd></dl>

<dl class="method">
<dt id="Function.Linear.function">
<code class="descname">function</code><span class="sig-paren">(</span><em>variable=None</em>, <em>params=None</em>, <em>time_scale=&lt;TimeScale.TRIAL: 1&gt;</em>, <em>context=None</em><span class="sig-paren">)</span><a class="headerlink" href="#Function.Linear.function" title="Permalink to this definition">¶</a></dt>
<dd><p>Return: <a class="reference internal" href="#Function.Linear.slope" title="Function.Linear.slope"><code class="xref any py py-attr docutils literal"><span class="pre">slope</span></code></a> * <a class="reference internal" href="#Function.Linear.variable" title="Function.Linear.variable"><code class="xref any py py-attr docutils literal"><span class="pre">variable</span></code></a> + <a class="reference internal" href="#Function.Linear.intercept" title="Function.Linear.intercept"><code class="xref any py py-attr docutils literal"><span class="pre">intercept</span></code></a>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>variable</strong> (<em>number or np.array : default variableClassDefault</em>) &#8211; a single value or array to be transformed.</li>
<li><strong>params</strong> (<em>Optional[Dict[param keyword, param value]]</em>) &#8211; a <a class="reference internal" href="ParameterState.html#parameterstate-specifying-parameters"><span class="std std-ref">parameter dictionary</span></a> that specifies the parameters for the
function.  Values specified for parameters in the dictionary override any assigned to those parameters in
arguments of the constructor.</li>
<li><strong>time_scale</strong> (<em>TimeScale : default TimeScale.TRIAL</em>) &#8211; specifies whether the function is executed on the time_step or trial time scale.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>linear transformation of variable</strong></p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">number or np.array</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="Function.Linear.derivative">
<code class="descname">derivative</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#Function.Linear.derivative" title="Permalink to this definition">¶</a></dt>
<dd><p>Derivative of <a class="reference internal" href="#Function.Linear.function" title="Function.Linear.function"><code class="xref any py py-meth docutils literal"><span class="pre">function</span></code></a>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><strong>derivative</strong> &#8211; current value of <a class="reference internal" href="#Function.Linear.slope" title="Function.Linear.slope"><code class="xref any py py-attr docutils literal"><span class="pre">slope</span></code></a>.</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body">number</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="Function.Exponential">
<em class="property">class </em><code class="descclassname">Function.</code><code class="descname">Exponential</code><span class="sig-paren">(</span><em>variable_default</em>, <em>scale=1.0</em>, <em>rate=1.0</em>, <em>params=None</em>, <em>owner=None</em>, <em>name=None</em>, <em>prefs=None</em><span class="sig-paren">)</span><a class="headerlink" href="#Function.Exponential" title="Permalink to this definition">¶</a></dt>
<dd><p id="exponential">Exponentially transform variable.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>variable</strong> (<em>number or np.array : default variableClassDefault</em>) &#8211; specifies a template for the value to be transformed.</li>
<li><strong>rate</strong> (<em>float : default 1.0</em>) &#8211; specifies a value by which to multiply <a class="reference internal" href="#Function.Exponential.variable" title="Function.Exponential.variable"><code class="xref any py py-attr docutils literal"><span class="pre">variable</span></code></a> before exponentiation.</li>
<li><strong>scale</strong> (<em>float : default 1.0</em>) &#8211; specifies a value by which to multiply the exponentiated value of <a class="reference internal" href="#Function.Exponential.variable" title="Function.Exponential.variable"><code class="xref any py py-attr docutils literal"><span class="pre">variable</span></code></a>.</li>
<li><strong>params</strong> (<em>Optional[Dict[param keyword, param value]]</em>) &#8211; a <a class="reference internal" href="ParameterState.html#parameterstate-specifying-parameters"><span class="std std-ref">parameter dictionary</span></a> that specifies the parameters for the
function.  Values specified for parameters in the dictionary override any assigned to those parameters in
arguments of the constructor.</li>
<li><strong>owner</strong> (<em>Component</em>) &#8211; <code class="xref any docutils literal"><span class="pre">component</span></code> to which to assign the Function.</li>
<li><strong>prefs</strong> (<em>Optional[PreferenceSet or specification dict : Function.classPreferences]</em>) &#8211; the <code class="xref any docutils literal"><span class="pre">PreferenceSet</span></code> for the Function. If it is not specified, a default is assigned using <code class="xref any docutils literal"><span class="pre">classPreferences</span></code>
defined in __init__.py (see <span class="xref doc">PreferenceSet</span> for details).</li>
</ul>
</td>
</tr>
</tbody>
</table>
<dl class="attribute">
<dt id="Function.Exponential.variable">
<code class="descname">variable</code><a class="headerlink" href="#Function.Exponential.variable" title="Permalink to this definition">¶</a></dt>
<dd><p><em>number or np.array</em> &#8211; contains value to be transformed.</p>
</dd></dl>

<dl class="attribute">
<dt id="Function.Exponential.rate">
<code class="descname">rate</code><a class="headerlink" href="#Function.Exponential.rate" title="Permalink to this definition">¶</a></dt>
<dd><p><em>float</em> &#8211; value by which <a class="reference internal" href="#Function.Exponential.variable" title="Function.Exponential.variable"><code class="xref any py py-attr docutils literal"><span class="pre">variable</span></code></a> is multiplied before exponentiation.</p>
</dd></dl>

<dl class="attribute">
<dt id="Function.Exponential.scale">
<code class="descname">scale</code><a class="headerlink" href="#Function.Exponential.scale" title="Permalink to this definition">¶</a></dt>
<dd><p><em>float</em> &#8211; value by which the exponentiated value is multipled.</p>
</dd></dl>

<dl class="attribute">
<dt id="Function.Exponential.owner">
<code class="descname">owner</code><a class="headerlink" href="#Function.Exponential.owner" title="Permalink to this definition">¶</a></dt>
<dd><p><em>Mechanism</em> &#8211; <code class="xref any docutils literal"><span class="pre">component</span></code> to which the Function has been assigned.</p>
</dd></dl>

<dl class="attribute">
<dt id="Function.Exponential.prefs">
<code class="descname">prefs</code><a class="headerlink" href="#Function.Exponential.prefs" title="Permalink to this definition">¶</a></dt>
<dd><p><em>PreferenceSet or specification dict : Projection.classPreferences</em> &#8211; the <code class="xref any docutils literal"><span class="pre">PreferenceSet</span></code> for function. Specified in the <a class="reference internal" href="#Function.Exponential.prefs" title="Function.Exponential.prefs"><code class="xref any py py-attr docutils literal"><span class="pre">prefs</span></code></a> argument of the constructor for the function;
if it is not specified, a default is assigned using <code class="xref any docutils literal"><span class="pre">classPreferences</span></code> defined in __init__.py
(see <span class="xref doc">PreferenceSet</span> for details).</p>
</dd></dl>

<dl class="method">
<dt id="Function.Exponential.function">
<code class="descname">function</code><span class="sig-paren">(</span><em>variable=None</em>, <em>params=None</em>, <em>time_scale=&lt;TimeScale.TRIAL: 1&gt;</em>, <em>context=None</em><span class="sig-paren">)</span><a class="headerlink" href="#Function.Exponential.function" title="Permalink to this definition">¶</a></dt>
<dd><p>Return: <a class="reference internal" href="#Function.Exponential.scale" title="Function.Exponential.scale"><code class="xref any py py-attr docutils literal"><span class="pre">scale</span></code></a> * e**(<a class="reference internal" href="#Function.Exponential.rate" title="Function.Exponential.rate"><code class="xref any py py-attr docutils literal"><span class="pre">rate</span></code></a> * <a class="reference internal" href="#Function.Linear.variable" title="Function.Linear.variable"><code class="xref any py py-attr docutils literal"><span class="pre">variable</span></code></a>).</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>variable</strong> (<em>number or np.array : default variableClassDefault</em>) &#8211; a single value or array to be exponentiated.</li>
<li><strong>params</strong> (<em>Optional[Dict[param keyword, param value]]</em>) &#8211; a <a class="reference internal" href="ParameterState.html#parameterstate-specifying-parameters"><span class="std std-ref">parameter dictionary</span></a> that specifies the parameters for the
function.  Values specified for parameters in the dictionary override any assigned to those parameters in
arguments of the constructor.</li>
<li><strong>time_scale</strong> (<em>TimeScale : default TimeScale.TRIAL</em>) &#8211; specifies whether the function is executed on the time_step or trial time scale.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>exponential transformation of variable</strong></p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">number or np.array</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="Function.Exponential.derivative">
<code class="descname">derivative</code><span class="sig-paren">(</span><em>input</em><span class="sig-paren">)</span><a class="headerlink" href="#Function.Exponential.derivative" title="Permalink to this definition">¶</a></dt>
<dd><p>Derivative of <a class="reference internal" href="#Function.Exponential.function" title="Function.Exponential.function"><code class="xref any py py-meth docutils literal"><span class="pre">function</span></code></a>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><strong>derivative</strong> &#8211; <a class="reference internal" href="#Function.Exponential.rate" title="Function.Exponential.rate"><code class="xref any py py-attr docutils literal"><span class="pre">rate</span></code></a> * input.</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body">number</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="Function.Logistic">
<em class="property">class </em><code class="descclassname">Function.</code><code class="descname">Logistic</code><span class="sig-paren">(</span><em>variable_default</em>, <em>gain=1.0</em>, <em>bias=0.0</em>, <em>params=None</em>, <em>owner=None</em>, <em>name=None</em>, <em>prefs=None</em><span class="sig-paren">)</span><a class="headerlink" href="#Function.Logistic" title="Permalink to this definition">¶</a></dt>
<dd><p id="logistic">Logistically transform variable.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>variable</strong> (<em>number or np.array : default variableClassDefault</em>) &#8211; specifies a template for the value to be transformed.</li>
<li><strong>gain</strong> (<em>float : default 1.0</em>) &#8211; specifies a value by which to multiply <a class="reference internal" href="#Function.Linear.variable" title="Function.Linear.variable"><code class="xref any py py-attr docutils literal"><span class="pre">variable</span></code></a> before logistic transformation</li>
<li><strong>bias</strong> (<em>float : default 0.0</em>) &#8211; specifies a value to add to each element of <a class="reference internal" href="#Function.Linear.variable" title="Function.Linear.variable"><code class="xref any py py-attr docutils literal"><span class="pre">variable</span></code></a> after applying <code class="xref any docutils literal"><span class="pre">gain</span></code>
but before logistic transformation.</li>
<li><strong>params</strong> (<em>Optional[Dict[param keyword, param value]]</em>) &#8211; a <a class="reference internal" href="ParameterState.html#parameterstate-specifying-parameters"><span class="std std-ref">parameter dictionary</span></a> that specifies the parameters for the
function.  Values specified for parameters in the dictionary override any assigned to those parameters in
arguments of the constructor.</li>
<li><strong>owner</strong> (<em>Component</em>) &#8211; <code class="xref any docutils literal"><span class="pre">component</span></code> to which to assign the Function.</li>
<li><strong>prefs</strong> (<em>Optional[PreferenceSet or specification dict : Function.classPreferences]</em>) &#8211; the <code class="xref any docutils literal"><span class="pre">PreferenceSet</span></code> for the Function. If it is not specified, a default is assigned using <code class="xref any docutils literal"><span class="pre">classPreferences</span></code>
defined in __init__.py (see <span class="xref doc">PreferenceSet</span> for details).</li>
</ul>
</td>
</tr>
</tbody>
</table>
<dl class="attribute">
<dt id="Function.Logistic.variable">
<code class="descname">variable</code><a class="headerlink" href="#Function.Logistic.variable" title="Permalink to this definition">¶</a></dt>
<dd><p><em>number or np.array</em> &#8211; contains value to be transformed.</p>
</dd></dl>

<dl class="attribute">
<dt id="Function.Logistic.gain">
<code class="descname">gain</code><a class="headerlink" href="#Function.Logistic.gain" title="Permalink to this definition">¶</a></dt>
<dd><p><em>float</em> &#8211; value by which each element of <a class="reference internal" href="#Function.Logistic.variable" title="Function.Logistic.variable"><code class="xref any py py-attr docutils literal"><span class="pre">variable</span></code></a> is multiplied before applying the
<code class="xref any docutils literal"><span class="pre">bias</span></code> (if it is specified).</p>
</dd></dl>

<dl class="attribute">
<dt id="Function.Logistic.bias">
<code class="descname">bias</code><a class="headerlink" href="#Function.Logistic.bias" title="Permalink to this definition">¶</a></dt>
<dd><p><em>float</em> &#8211; value added to each element of <a class="reference internal" href="#Function.Logistic.variable" title="Function.Logistic.variable"><code class="xref any py py-attr docutils literal"><span class="pre">variable</span></code></a> after applying the <a class="reference internal" href="#Function.Logistic.gain" title="Function.Logistic.gain"><code class="xref any py py-attr docutils literal"><span class="pre">gain</span></code></a>
(if it is specified).</p>
</dd></dl>

<dl class="attribute">
<dt id="Function.Logistic.owner">
<code class="descname">owner</code><a class="headerlink" href="#Function.Logistic.owner" title="Permalink to this definition">¶</a></dt>
<dd><p><em>Mechanism</em> &#8211; <code class="xref any docutils literal"><span class="pre">component</span></code> to which the Function has been assigned.</p>
</dd></dl>

<dl class="attribute">
<dt id="Function.Logistic.prefs">
<code class="descname">prefs</code><a class="headerlink" href="#Function.Logistic.prefs" title="Permalink to this definition">¶</a></dt>
<dd><p><em>PreferenceSet or specification dict : Projection.classPreferences</em> &#8211; the <code class="xref any docutils literal"><span class="pre">PreferenceSet</span></code> for function. Specified in the <a class="reference internal" href="#Function.Logistic.prefs" title="Function.Logistic.prefs"><code class="xref any py py-attr docutils literal"><span class="pre">prefs</span></code></a> argument of the constructor for the function;
if it is not specified, a default is assigned using <code class="xref any docutils literal"><span class="pre">classPreferences</span></code> defined in __init__.py
(see <span class="xref doc">PreferenceSet</span> for details).</p>
</dd></dl>

<dl class="method">
<dt id="Function.Logistic.function">
<code class="descname">function</code><span class="sig-paren">(</span><em>variable=None</em>, <em>params=None</em>, <em>time_scale=&lt;TimeScale.TRIAL: 1&gt;</em>, <em>context=None</em><span class="sig-paren">)</span><a class="headerlink" href="#Function.Logistic.function" title="Permalink to this definition">¶</a></dt>
<dd><p>Return: 1 / (1 + e**( (<a class="reference internal" href="#Function.Logistic.gain" title="Function.Logistic.gain"><code class="xref any py py-attr docutils literal"><span class="pre">gain</span></code></a> * <a class="reference internal" href="#Function.Logistic.variable" title="Function.Logistic.variable"><code class="xref any py py-attr docutils literal"><span class="pre">variable</span></code></a>) + <a class="reference internal" href="#Function.Logistic.bias" title="Function.Logistic.bias"><code class="xref any py py-attr docutils literal"><span class="pre">bias</span></code></a>))</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>variable</strong> (<em>number or np.array : default variableClassDefault</em>) &#8211; a single value or array to be transformed.</li>
<li><strong>params</strong> (<em>Optional[Dict[param keyword, param value]]</em>) &#8211; a <a class="reference internal" href="ParameterState.html#parameterstate-specifying-parameters"><span class="std std-ref">parameter dictionary</span></a> that specifies the parameters for the
function.  Values specified for parameters in the dictionary override any assigned to those parameters in
arguments of the constructor.</li>
<li><strong>time_scale</strong> (<em>TimeScale : default TimeScale.TRIAL</em>) &#8211; specifies whether the function is executed on the time_step or trial time scale.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>logistic transformation of variable</strong></p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">number or np.array</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="Function.Logistic.derivative">
<code class="descname">derivative</code><span class="sig-paren">(</span><em>output</em><span class="sig-paren">)</span><a class="headerlink" href="#Function.Logistic.derivative" title="Permalink to this definition">¶</a></dt>
<dd><p>Derivative of <a class="reference internal" href="#Function.Logistic.function" title="Function.Logistic.function"><code class="xref any py py-meth docutils literal"><span class="pre">function</span></code></a>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><strong>derivative</strong> &#8211; output * (1 - output).</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body">number</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="Function.SoftMax">
<em class="property">class </em><code class="descclassname">Function.</code><code class="descname">SoftMax</code><span class="sig-paren">(</span><em>variable_default</em>, <em>gain=1.0</em>, <em>output=ALL</em>, <em>params=None</em>, <em>owner=None</em>, <em>name=None</em>, <em>prefs=None</em><span class="sig-paren">)</span><a class="headerlink" href="#Function.SoftMax" title="Permalink to this definition">¶</a></dt>
<dd><p id="softmax">SoftMax transform of variable.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>variable</strong> (<em>1d np.array : default variableClassDefault</em>) &#8211; specifies a template for the value to be transformed.</li>
<li><strong>gain</strong> (<em>float : default 1.0</em>) &#8211; specifies a value by which to multiply <a class="reference internal" href="#Function.Linear.variable" title="Function.Linear.variable"><code class="xref any py py-attr docutils literal"><span class="pre">variable</span></code></a> before softmax transformation.</li>
<li><strong>output</strong> (<em>ALL, MAX_VAL, MAX_INDICATOR, or PROB : default ALL</em>) &#8211; specifies the format of array returned by <a class="reference internal" href="#Function.SoftMax.function" title="Function.SoftMax.function"><code class="xref any py py-meth docutils literal"><span class="pre">function</span></code></a>
(see <a class="reference internal" href="#Function.SoftMax.output" title="Function.SoftMax.output"><code class="xref any py py-attr docutils literal"><span class="pre">output</span></code></a> for details).</li>
<li><strong>params</strong> (<em>Optional[Dict[param keyword, param value]]</em>) &#8211; a <a class="reference internal" href="ParameterState.html#parameterstate-specifying-parameters"><span class="std std-ref">parameter dictionary</span></a> that specifies the parameters for the
function.  Values specified for parameters in the dictionary override any assigned to those parameters in
arguments of the constructor.</li>
<li><strong>owner</strong> (<em>Component</em>) &#8211; <code class="xref any docutils literal"><span class="pre">component</span></code> to which to assign the Function.</li>
<li><strong>prefs</strong> (<em>Optional[PreferenceSet or specification dict : Function.classPreferences]</em>) &#8211; the <code class="xref any docutils literal"><span class="pre">PreferenceSet</span></code> for the Function. If it is not specified, a default is assigned using <code class="xref any docutils literal"><span class="pre">classPreferences</span></code>
defined in __init__.py (see <span class="xref doc">PreferenceSet</span> for details).</li>
</ul>
</td>
</tr>
</tbody>
</table>
<dl class="attribute">
<dt id="Function.SoftMax.variable">
<code class="descname">variable</code><a class="headerlink" href="#Function.SoftMax.variable" title="Permalink to this definition">¶</a></dt>
<dd><p><em>1d np.array</em> &#8211; contains value to be transformed.</p>
</dd></dl>

<dl class="attribute">
<dt id="Function.SoftMax.gain">
<code class="descname">gain</code><a class="headerlink" href="#Function.SoftMax.gain" title="Permalink to this definition">¶</a></dt>
<dd><p><em>float</em> &#8211; value by which <a class="reference internal" href="#Function.Logistic.variable" title="Function.Logistic.variable"><code class="xref any py py-attr docutils literal"><span class="pre">variable</span></code></a> is multiplied before the softmax transformation;  determines
the &#8220;sharpness&#8221; of the distribution.</p>
</dd></dl>

<dl class="attribute">
<dt id="Function.SoftMax.output">
<code class="descname">output</code><a class="headerlink" href="#Function.SoftMax.output" title="Permalink to this definition">¶</a></dt>
<dd><p><em>ALL, MAX_VAL, MAX_INDICATOR, or PROB</em> &#8211; determines how the softmax-transformed values of the elements in <a class="reference internal" href="#Function.SoftMax.variable" title="Function.SoftMax.variable"><code class="xref any py py-attr docutils literal"><span class="pre">variable</span></code></a> are reported
in the array returned by <code class="xref any docutils literal"><span class="pre">function</span></code>:</p>
<blockquote>
<div><ul class="simple">
<li><strong>ALL</strong>: array of all softmax-transformed values;</li>
<li><strong>MAX_VAL</strong>: softmax-transformed value for the element with the maximum such value, 0 for all others;</li>
<li><strong>MAX_INDICATOR</strong>: 1 for the element with the maximum softmax-transformed value, 0 for all others;</li>
<li><strong>PROB</strong>: probabilistically chosen element based on softmax-transformed values after normalizing sum of
values to 1, 0 for all others.</li>
</ul>
</div></blockquote>
</dd></dl>

<dl class="attribute">
<dt id="Function.SoftMax.owner">
<code class="descname">owner</code><a class="headerlink" href="#Function.SoftMax.owner" title="Permalink to this definition">¶</a></dt>
<dd><p><em>Mechanism</em> &#8211; <code class="xref any docutils literal"><span class="pre">component</span></code> to which the Function has been assigned.</p>
</dd></dl>

<dl class="attribute">
<dt id="Function.SoftMax.prefs">
<code class="descname">prefs</code><a class="headerlink" href="#Function.SoftMax.prefs" title="Permalink to this definition">¶</a></dt>
<dd><p><em>PreferenceSet or specification dict : Projection.classPreferences</em> &#8211; the <code class="xref any docutils literal"><span class="pre">PreferenceSet</span></code> for function. Specified in the <a class="reference internal" href="#Function.SoftMax.prefs" title="Function.SoftMax.prefs"><code class="xref any py py-attr docutils literal"><span class="pre">prefs</span></code></a> argument of the constructor for the function;
if it is not specified, a default is assigned using <code class="xref any docutils literal"><span class="pre">classPreferences</span></code> defined in __init__.py
(see <span class="xref doc">PreferenceSet</span> for details).</p>
</dd></dl>

<dl class="method">
<dt id="Function.SoftMax.function">
<code class="descname">function</code><span class="sig-paren">(</span><em>variable=None</em>, <em>params=None</em>, <em>time_scale=&lt;TimeScale.TRIAL: 1&gt;</em>, <em>context=None</em><span class="sig-paren">)</span><a class="headerlink" href="#Function.SoftMax.function" title="Permalink to this definition">¶</a></dt>
<dd><p>Return: e**(<a class="reference internal" href="#Function.SoftMax.gain" title="Function.SoftMax.gain"><code class="xref any py py-attr docutils literal"><span class="pre">gain</span></code></a> * <a class="reference internal" href="#Function.SoftMax.variable" title="Function.SoftMax.variable"><code class="xref any py py-attr docutils literal"><span class="pre">variable</span></code></a>) /
sum(e**(<a class="reference internal" href="#Function.SoftMax.gain" title="Function.SoftMax.gain"><code class="xref any py py-attr docutils literal"><span class="pre">gain</span></code></a> * <a class="reference internal" href="#Function.SoftMax.variable" title="Function.SoftMax.variable"><code class="xref any py py-attr docutils literal"><span class="pre">variable</span></code></a>)),
filtered by <a class="reference internal" href="#Function.SoftMax.output" title="Function.SoftMax.output"><code class="xref any py py-attr docutils literal"><span class="pre">ouptput</span></code></a> specification.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>variable</strong> (<em>1d np.array : default variableClassDefault</em>) &#8211; an array to be transformed.</li>
<li><strong>params</strong> (<em>Optional[Dict[param keyword, param value]]</em>) &#8211; a <a class="reference internal" href="ParameterState.html#parameterstate-specifying-parameters"><span class="std std-ref">parameter dictionary</span></a> that specifies the parameters for the
function.  Values specified for parameters in the dictionary override any assigned to those parameters in
arguments of the constructor.</li>
<li><strong>time_scale</strong> (<em>TimeScale : default TimeScale.TRIAL</em>) &#8211; specifies whether the function is executed on the time_step or trial time scale.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>softmax transformation of variable</strong></p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">number or np.array</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="Function.SoftMax.derivative">
<code class="descname">derivative</code><span class="sig-paren">(</span><em>output</em><span class="sig-paren">)</span><a class="headerlink" href="#Function.SoftMax.derivative" title="Permalink to this definition">¶</a></dt>
<dd><p>Derivative of <a class="reference internal" href="#Function.SoftMax.function" title="Function.SoftMax.function"><code class="xref any py py-meth docutils literal"><span class="pre">function</span></code></a>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><strong>derivative</strong> &#8211; output - maximum value.</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body">number</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="Function.LinearMatrix">
<em class="property">class </em><code class="descclassname">Function.</code><code class="descname">LinearMatrix</code><span class="sig-paren">(</span><em>variable_default</em>, <em>matrix=None</em>, <em>params=None</em>, <em>owner=None</em>, <em>name=None</em>, <em>prefs=None</em><span class="sig-paren">)</span><a class="headerlink" href="#Function.LinearMatrix" title="Permalink to this definition">¶</a></dt>
<dd><p id="linearmatrix">Matrix transform of variable:</p>
<blockquote>
<div><a class="reference internal" href="#Function.LinearMatrix.function" title="Function.LinearMatrix.function"><code class="xref any py py-meth docutils literal"><span class="pre">function</span></code></a> returns dot product of <a class="reference internal" href="#Function.LinearMatrix.variable" title="Function.LinearMatrix.variable"><code class="xref any py py-attr docutils literal"><span class="pre">variable</span></code></a> and
<a class="reference internal" href="#Function.LinearMatrix.matrix" title="Function.LinearMatrix.matrix"><code class="xref any py py-attr docutils literal"><span class="pre">matrix</span></code></a>.</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>variable</strong> (<em>list or 1d np.array : default variableClassDefault</em>) &#8211; specifies a template for the value to be transformed; length must equal the number of rows of <a class="reference internal" href="#Function.LinearMatrix.matrix" title="Function.LinearMatrix.matrix"><code class="xref any py py-attr docutils literal"><span class="pre">matrix</span></code></a>.</li>
<li><strong>matrix</strong> (<em>number, list, 1d or 2d np.ndarray, np.matrix, function, or matrix keyword : default IDENTITY_MATRIX</em>) &#8211; specifies matrix used to transform <a class="reference internal" href="#Function.LinearMatrix.variable" title="Function.LinearMatrix.variable"><code class="xref any py py-attr docutils literal"><span class="pre">variable</span></code></a>
(see <a class="reference internal" href="#Function.LinearMatrix.matrix" title="Function.LinearMatrix.matrix"><code class="xref any py py-attr docutils literal"><span class="pre">matrix</span></code></a> for specification details).</li>
<li><strong>params</strong> (<em>Optional[Dict[param keyword, param value]]</em>) &#8211; a <a class="reference internal" href="ParameterState.html#parameterstate-specifying-parameters"><span class="std std-ref">parameter dictionary</span></a> that specifies the parameters for the
function.  Values specified for parameters in the dictionary override any assigned to those parameters in
arguments of the constructor.</li>
<li><strong>owner</strong> (<em>Component</em>) &#8211; <code class="xref any docutils literal"><span class="pre">component</span></code> to which to assign the Function.</li>
<li><strong>prefs</strong> (<em>Optional[PreferenceSet or specification dict : Function.classPreferences]</em>) &#8211; the <code class="xref any docutils literal"><span class="pre">PreferenceSet</span></code> for the Function. If it is not specified, a default is assigned using <code class="xref any docutils literal"><span class="pre">classPreferences</span></code>
defined in __init__.py (see <span class="xref doc">PreferenceSet</span> for details).</li>
</ul>
</td>
</tr>
</tbody>
</table>
<dl class="attribute">
<dt id="Function.LinearMatrix.variable">
<code class="descname">variable</code><a class="headerlink" href="#Function.LinearMatrix.variable" title="Permalink to this definition">¶</a></dt>
<dd><p><em>1d np.array</em> &#8211; contains value to be transformed.</p>
</dd></dl>

<dl class="attribute">
<dt id="Function.LinearMatrix.matrix">
<code class="descname">matrix</code><a class="headerlink" href="#Function.LinearMatrix.matrix" title="Permalink to this definition">¶</a></dt>
<dd><p><em>2d np.array</em> &#8211; matrix used to transform <a class="reference internal" href="#Function.LinearMatrix.variable" title="Function.LinearMatrix.variable"><code class="xref any py py-attr docutils literal"><span class="pre">variable</span></code></a>.
Can be specified as any of the following:</p>
<blockquote>
<div><ul class="simple">
<li>number - used as the filler value for all elements of the <code class="xref std std-keyword docutils literal"><span class="pre">matrix</span></code> (call to np.fill);</li>
<li>list of arrays, 2d np.array or np.matrix - assigned as the value of <code class="xref std std-keyword docutils literal"><span class="pre">matrix</span></code>;</li>
<li>matrix keyword - see <a class="reference internal" href="Keywords.html#Keywords.MatrixKeywords" title="Keywords.MatrixKeywords"><code class="xref any py py-class docutils literal"><span class="pre">MatrixKeywords</span></code></a> for list of options.</li>
</ul>
</div></blockquote>
<p>Rows correspond to elements of the input array (outer index), and
columns correspond to elements of the output array (inner index).</p>
</dd></dl>

<dl class="attribute">
<dt id="Function.LinearMatrix.owner">
<code class="descname">owner</code><a class="headerlink" href="#Function.LinearMatrix.owner" title="Permalink to this definition">¶</a></dt>
<dd><p><em>Mechanism</em> &#8211; <code class="xref any docutils literal"><span class="pre">component</span></code> to which the Function has been assigned.</p>
</dd></dl>

<dl class="attribute">
<dt id="Function.LinearMatrix.prefs">
<code class="descname">prefs</code><a class="headerlink" href="#Function.LinearMatrix.prefs" title="Permalink to this definition">¶</a></dt>
<dd><p><em>PreferenceSet or specification dict : Projection.classPreferences</em> &#8211; the <code class="xref any docutils literal"><span class="pre">PreferenceSet</span></code> for function. Specified in the <a class="reference internal" href="#Function.LinearMatrix.prefs" title="Function.LinearMatrix.prefs"><code class="xref any py py-attr docutils literal"><span class="pre">prefs</span></code></a> argument of the constructor for the function;
if it is not specified, a default is assigned using <code class="xref any docutils literal"><span class="pre">classPreferences</span></code> defined in __init__.py
(see <span class="xref doc">PreferenceSet</span> for details).</p>
</dd></dl>

<dl class="method">
<dt id="Function.LinearMatrix.instantiate_matrix">
<code class="descname">instantiate_matrix</code><span class="sig-paren">(</span><em>specification</em>, <em>context=None</em><span class="sig-paren">)</span><a class="headerlink" href="#Function.LinearMatrix.instantiate_matrix" title="Permalink to this definition">¶</a></dt>
<dd><p>Implements matrix indicated by specification</p>
<blockquote>
<div><p>Specification is derived from MATRIX param (passed to self.__init__ or self.function)</p>
<dl class="docutils">
<dt>Specification (validated in _validate_params):</dt>
<dd><ul class="first last simple">
<li>single number (used to fill self.matrix)</li>
<li>matrix keyword (see get_matrix)</li>
<li>2D list or np.ndarray of numbers</li>
</ul>
</dd>
</dl>
</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return matrix:</th><td class="field-body">(2D list)</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="Function.LinearMatrix.function">
<code class="descname">function</code><span class="sig-paren">(</span><em>variable=None</em>, <em>params=None</em>, <em>time_scale=&lt;TimeScale.TRIAL: 1&gt;</em>, <em>context=None</em><span class="sig-paren">)</span><a class="headerlink" href="#Function.LinearMatrix.function" title="Permalink to this definition">¶</a></dt>
<dd><p>Return: <a class="reference internal" href="#Function.LinearMatrix.variable" title="Function.LinearMatrix.variable"><code class="xref any py py-attr docutils literal"><span class="pre">variable</span></code></a> • <a class="reference internal" href="#Function.LinearMatrix.matrix" title="Function.LinearMatrix.matrix"><code class="xref any py py-attr docutils literal"><span class="pre">matrix</span></code></a></p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>variable</strong> (<em>list or 1d np.array</em>) &#8211; array to be transformed;  length must equal the number of rows of &#8216;matrix &lt;LinearMatrix.matrix&gt;`.</li>
<li><strong>params</strong> (<em>Optional[Dict[param keyword, param value]]</em>) &#8211; a <a class="reference internal" href="ParameterState.html#parameterstate-specifying-parameters"><span class="std std-ref">parameter dictionary</span></a> that specifies the parameters for the
function.  Values specified for parameters in the dictionary override any assigned to those parameters in
arguments of the constructor.</li>
<li><strong>time_scale</strong> (<em>TimeScale : default TimeScale.TRIAL</em>) &#8211; specifies whether the function is executed on the time_step or trial time scale.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>dot product of variable and matrix</strong> &#8211; length of the array returned equals the number of columns of <a class="reference internal" href="#Function.LinearMatrix.matrix" title="Function.LinearMatrix.matrix"><code class="xref any py py-attr docutils literal"><span class="pre">matrix</span></code></a>.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">1d np.array</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="Function.Integrator">
<em class="property">class </em><code class="descclassname">Function.</code><code class="descname">Integrator</code><span class="sig-paren">(</span><em>variable_default=None</em>, <em>rate=1.0</em>, <em>weighting=CONSTANT</em>, <em>noise=0.0</em>, <em>time_step_size=1.0</em>, <em>params=None</em>, <em>owner=None</em>, <em>prefs:is_pref_set=None</em><span class="sig-paren">)</span><a class="headerlink" href="#Function.Integrator" title="Permalink to this definition">¶</a></dt>
<dd><p id="integrator">Integrate current value of <code class="xref any docutils literal"><span class="pre">variable</span></code> with its prior value.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>variable_default</strong> (<em>number, list or np.array : default variableClassDefault</em>) &#8211; specifies a template for the value to be integrated</li>
<li><strong>rate</strong> (<em>float, list or 1d np.array : default 1.0</em>) &#8211; specifies the rate of integration.  If it is a list or array, it must be the same length as
<code class="xref any docutils literal"><span class="pre">variable</span></code> and all elements must be floats between 0 and 1
(see <a class="reference internal" href="#Function.Integrator.rate" title="Function.Integrator.rate"><code class="xref any py py-attr docutils literal"><span class="pre">rate</span></code></a> for details).</li>
<li><strong>weighting</strong> (<em>CONSTANT, SIMPLE, ADAPTIVE, DIFFUSION : default CONSTANT</em>) &#8211; specifies type of integration (see <a class="reference internal" href="#Function.Integrator.weighting" title="Function.Integrator.weighting"><code class="xref any py py-attr docutils literal"><span class="pre">weighting</span></code></a> for details).</li>
<li><strong>noise</strong> (<em>float, list or 1d np.array : default 0.0</em>) &#8211; specifies random value to be added in each call to <a class="reference internal" href="#Function.Integrator.function" title="Function.Integrator.function"><code class="xref any py py-meth docutils literal"><span class="pre">function</span></code></a>.
If it is a list or array, it must be the same length as <code class="xref any docutils literal"><span class="pre">variable</span></code> and all elements
must be floats between 0 and 1 (see <a class="reference internal" href="#Function.Integrator.rate" title="Function.Integrator.rate"><code class="xref any py py-attr docutils literal"><span class="pre">noise</span></code></a> for details).</li>
<li><strong>time_step_size</strong> (<em>float : default 0.0</em>) &#8211; determines the timing precision of the integration process when <a class="reference internal" href="#Function.Integrator.weighting" title="Function.Integrator.weighting"><code class="xref any py py-attr docutils literal"><span class="pre">weighting</span></code></a> is set to
DIFFUSION (see <a class="reference internal" href="#Function.Integrator.time_step_size" title="Function.Integrator.time_step_size"><code class="xref any py py-attr docutils literal"><span class="pre">time_step_size</span></code></a> for details.</li>
<li><strong>float, list or 1d np.array</strong> (<a class="reference internal" href="#Function.Integrator.initializer" title="Function.Integrator.initializer"><em>initializer</em></a>) &#8211; specifies starting value for integration.  If it is a list or array, it must be the same length as <code class="xref any docutils literal"><span class="pre">variable</span></code> (see <a class="reference internal" href="#Function.Integrator.initializer" title="Function.Integrator.initializer"><code class="xref any py py-attr docutils literal"><span class="pre">initializer</span></code></a> for details).</li>
<li><strong>params</strong> (<em>Optional[Dict[param keyword, param value]]</em>) &#8211; a <a class="reference internal" href="ParameterState.html#parameterstate-specifying-parameters"><span class="std std-ref">parameter dictionary</span></a> that specifies the parameters for the
function.  Values specified for parameters in the dictionary override any assigned to those parameters in
arguments of the constructor.</li>
<li><strong>owner</strong> (<em>Component</em>) &#8211; <code class="xref any docutils literal"><span class="pre">component</span></code> to which to assign the Function.</li>
<li><strong>prefs</strong> (<em>Optional[PreferenceSet or specification dict : Function.classPreferences]</em>) &#8211; the <code class="xref any docutils literal"><span class="pre">PreferenceSet</span></code> for the Function. If it is not specified, a default is assigned using <code class="xref any docutils literal"><span class="pre">classPreferences</span></code>
defined in __init__.py (see <span class="xref doc">PreferenceSet</span> for details).</li>
</ul>
</td>
</tr>
</tbody>
</table>
<dl class="attribute">
<dt id="Function.Integrator.variable_default">
<code class="descname">variable_default</code><a class="headerlink" href="#Function.Integrator.variable_default" title="Permalink to this definition">¶</a></dt>
<dd><p><em>number, list or np.array</em> &#8211; current input value some portion of which (determined by <a class="reference internal" href="#Function.Integrator.rate" title="Function.Integrator.rate"><code class="xref any py py-attr docutils literal"><span class="pre">rate</span></code></a> that will be
added to prior value.</p>
</dd></dl>

<dl class="attribute">
<dt id="Function.Integrator.rate">
<code class="descname">rate</code><a class="headerlink" href="#Function.Integrator.rate" title="Permalink to this definition">¶</a></dt>
<dd><p><em>1d np.array</em> &#8211; determines the rate of integration based on current and prior values.  All elements are between 0 and 1
(0 = no change; 1 = instantaneous change). If it has a single element, it applies to all elements of
<code class="xref any docutils literal"><span class="pre">variable</span></code>;  if it has more than n array, each element applies to the corresponding
element of <code class="xref any docutils literal"><span class="pre">variable</span></code>.</p>
</dd></dl>

<dl class="attribute">
<dt id="Function.Integrator.weighting">
<code class="descname">weighting</code><a class="headerlink" href="#Function.Integrator.weighting" title="Permalink to this definition">¶</a></dt>
<dd><p><em>CONSTANT, SIMPLE, ADAPTIVE, DIFFUSION</em> &#8211;</p>
<dl class="docutils">
<dt>specifies type of integration:</dt>
<dd><ul class="first last simple">
<li><strong>CONSTANT</strong>: <a class="reference internal" href="#Function.Integrator.old_value" title="Function.Integrator.old_value"><code class="xref any py py-attr docutils literal"><span class="pre">old_value</span></code></a> + <a class="reference internal" href="#Function.Integrator.rate" title="Function.Integrator.rate"><code class="xref any py py-attr docutils literal"><span class="pre">rate</span></code></a> + <a class="reference internal" href="#Function.Integrator.noise" title="Function.Integrator.noise"><code class="xref any py py-attr docutils literal"><span class="pre">noise</span></code></a>
(ignores <code class="xref any docutils literal"><span class="pre">variable</span></code>);</li>
<li><strong>SIMPLE</strong>: <a class="reference internal" href="#Function.Integrator.old_value" title="Function.Integrator.old_value"><code class="xref any py py-attr docutils literal"><span class="pre">old_value</span></code></a> + <a class="reference internal" href="#Function.Integrator.rate" title="Function.Integrator.rate"><code class="xref any py py-attr docutils literal"><span class="pre">rate</span></code></a> *
<code class="xref any docutils literal"><span class="pre">variable</span></code> + <a class="reference internal" href="#Function.Integrator.noise" title="Function.Integrator.noise"><code class="xref any py py-attr docutils literal"><span class="pre">noise</span></code></a>;</li>
<li><strong>ADAPTIVE</strong>: (1-<a class="reference internal" href="#Function.Integrator.rate" title="Function.Integrator.rate"><code class="xref any py py-attr docutils literal"><span class="pre">rate</span></code></a>) * <code class="xref any docutils literal"><span class="pre">variable</span></code> +
(<a class="reference internal" href="#Function.Integrator.rate" title="Function.Integrator.rate"><code class="xref any py py-attr docutils literal"><span class="pre">rate</span></code></a> * <a class="reference internal" href="#Function.Integrator.old_value" title="Function.Integrator.old_value"><code class="xref any py py-attr docutils literal"><span class="pre">old_value</span></code></a>) + <a class="reference internal" href="#Function.Integrator.noise" title="Function.Integrator.noise"><code class="xref any py py-attr docutils literal"><span class="pre">noise</span></code></a>
(<a class="reference external" href="https://en.wikipedia.org/wiki/Wiener_filter">Weiner filter</a> or
<a class="reference external" href="https://en.wikipedia.org/wiki/Delta_rule">Delta rule</a>);</li>
<li><strong>DIFFUSION</strong>: <a class="reference internal" href="#Function.Integrator.old_value" title="Function.Integrator.old_value"><code class="xref any py py-attr docutils literal"><span class="pre">old_value</span></code></a> +
(<a class="reference internal" href="#Function.Integrator.rate" title="Function.Integrator.rate"><code class="xref any py py-attr docutils literal"><span class="pre">rate</span></code></a> * <a class="reference internal" href="#Function.Integrator.old_value" title="Function.Integrator.old_value"><code class="xref any py py-attr docutils literal"><span class="pre">old_value</span></code></a> * <a class="reference internal" href="#Function.Integrator.time_step_size" title="Function.Integrator.time_step_size"><code class="xref any py py-attr docutils literal"><span class="pre">time_step_size</span></code></a>) +
√(<a class="reference internal" href="#Function.Integrator.time_step_size" title="Function.Integrator.time_step_size"><code class="xref any py py-attr docutils literal"><span class="pre">time_step_size</span></code></a> * <a class="reference internal" href="#Function.Integrator.noise" title="Function.Integrator.noise"><code class="xref any py py-attr docutils literal"><span class="pre">noise</span></code></a> * Gaussian(0,1))
(<a class="reference external" href="https://en.wikipedia.org/wiki/Two-alternative_forced_choice#Drift-diffusion_model">Drift Diffusion Model</a>).</li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="attribute">
<dt id="Function.Integrator.noise">
<code class="descname">noise</code><a class="headerlink" href="#Function.Integrator.noise" title="Permalink to this definition">¶</a></dt>
<dd><p><em>float, list or 1d np.array</em> &#8211; specifies random value to be added in each call to <a class="reference internal" href="#Function.Integrator.function" title="Function.Integrator.function"><code class="xref any py py-meth docutils literal"><span class="pre">function</span></code></a>.
If it is a list or array, it must be the same length as <code class="xref any docutils literal"><span class="pre">variable</span></code> and all elements
must be floats between 0 and 1 (see <a class="reference internal" href="#Function.Integrator.rate" title="Function.Integrator.rate"><code class="xref any py py-attr docutils literal"><span class="pre">noise</span></code></a> for details).</p>
</dd></dl>

<dl class="attribute">
<dt id="Function.Integrator.time_step_size">
<code class="descname">time_step_size</code><a class="headerlink" href="#Function.Integrator.time_step_size" title="Permalink to this definition">¶</a></dt>
<dd><p><em>float</em> &#8211; determines the timing precision of the integration process when <a class="reference internal" href="#Function.Integrator.weighting" title="Function.Integrator.weighting"><code class="xref any py py-attr docutils literal"><span class="pre">weighting</span></code></a> is set to
DIFFUSION (and used to scale the <a class="reference internal" href="#Function.Integrator.noise" title="Function.Integrator.noise"><code class="xref any py py-attr docutils literal"><span class="pre">noise</span></code></a> parameter appropriately).</p>
</dd></dl>

<dl class="attribute">
<dt id="Function.Integrator.initializer">
<code class="descname">initializer</code><a class="headerlink" href="#Function.Integrator.initializer" title="Permalink to this definition">¶</a></dt>
<dd><p><em>float, list or 1d np.array</em> &#8211; determines the starting value for integration (i.e., the value to which <a class="reference internal" href="#Function.Integrator.old_value" title="Function.Integrator.old_value"><code class="xref any py py-attr docutils literal"><span class="pre">old_value</span></code></a>
is set.  If it is assigned as a <code class="xref any docutils literal"><span class="pre">runtime_param</span></code> it resets <a class="reference internal" href="#Function.Integrator.old_value" title="Function.Integrator.old_value"><code class="xref any py py-attr docutils literal"><span class="pre">old_value</span></code></a> to the
specified value. &lt;Integrator.variable&gt;` (see <a class="reference internal" href="#Function.Integrator.initializer" title="Function.Integrator.initializer"><code class="xref any py py-attr docutils literal"><span class="pre">initializer</span></code></a> for details).</p>
</dd></dl>

<dl class="attribute">
<dt id="Function.Integrator.old_value">
<code class="descname">old_value</code><a class="headerlink" href="#Function.Integrator.old_value" title="Permalink to this definition">¶</a></dt>
<dd><p><em>1d np.array : default variableClassDefault</em> &#8211; stores previous value with <code class="xref any docutils literal"><span class="pre">variable</span></code> is integrated.</p>
</dd></dl>

<dl class="attribute">
<dt id="Function.Integrator.owner">
<code class="descname">owner</code><a class="headerlink" href="#Function.Integrator.owner" title="Permalink to this definition">¶</a></dt>
<dd><p><em>Mechanism</em> &#8211; <code class="xref any docutils literal"><span class="pre">component</span></code> to which the Function has been assigned.</p>
</dd></dl>

<dl class="attribute">
<dt id="Function.Integrator.prefs">
<code class="descname">prefs</code><a class="headerlink" href="#Function.Integrator.prefs" title="Permalink to this definition">¶</a></dt>
<dd><p><em>PreferenceSet or specification dict : Projection.classPreferences</em> &#8211; the <code class="xref any docutils literal"><span class="pre">PreferenceSet</span></code> for function. Specified in the <a class="reference internal" href="#Function.Integrator.prefs" title="Function.Integrator.prefs"><code class="xref any py py-attr docutils literal"><span class="pre">prefs</span></code></a> argument of the constructor for the function;
if it is not specified, a default is assigned using <code class="xref any docutils literal"><span class="pre">classPreferences</span></code> defined in __init__.py
(see <span class="xref doc">PreferenceSet</span> for details).</p>
</dd></dl>

<dl class="method">
<dt id="Function.Integrator.function">
<code class="descname">function</code><span class="sig-paren">(</span><em>variable=None</em>, <em>params=None</em>, <em>time_scale=&lt;TimeScale.TRIAL: 1&gt;</em>, <em>context=None</em><span class="sig-paren">)</span><a class="headerlink" href="#Function.Integrator.function" title="Permalink to this definition">¶</a></dt>
<dd><p>Return: some fraction of <a class="reference internal" href="#Function.Linear.slope" title="Function.Linear.slope"><code class="xref any py py-attr docutils literal"><span class="pre">variable</span></code></a> combined with some fraction of <a class="reference internal" href="#Function.Integrator.old_value" title="Function.Integrator.old_value"><code class="xref any py py-attr docutils literal"><span class="pre">old_value</span></code></a> (see <a class="reference internal" href="#Function.Integrator.weighting" title="Function.Integrator.weighting"><code class="xref any py py-attr docutils literal"><span class="pre">weighting</span></code></a>).</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>variable</strong> (<em>number, list or np.array : default variableClassDefault</em>) &#8211; a single value or array to be transformed.</li>
<li><strong>params</strong> (<em>Optional[Dict[param keyword, param value]]</em>) &#8211; a <a class="reference internal" href="ParameterState.html#parameterstate-specifying-parameters"><span class="std std-ref">parameter dictionary</span></a> that specifies the parameters for the
function.  Values specified for parameters in the dictionary override any assigned to those parameters in
arguments of the constructor.</li>
<li><strong>time_scale</strong> (<em>TimeScale : default TimeScale.TRIAL</em>) &#8211; specifies whether the function is executed on the time_step or trial time scale.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>updated value of integral</strong></p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">2d np.array</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="Function.BogaczEtAl">
<em class="property">class </em><code class="descclassname">Function.</code><code class="descname">BogaczEtAl</code><span class="sig-paren">(</span><em>variable_default=[[0]], drift_rate: &lt;function parameter_spec at 0x10b973ae8&gt; = 1.0, starting_point: &lt;function parameter_spec at 0x10b973ae8&gt; = 0.0, threshold: &lt;function parameter_spec at 0x10b973ae8&gt; = 1.0, noise: &lt;function parameter_spec at 0x10b973ae8&gt; = 0.5, t0: &lt;function parameter_spec at 0x10b973ae8&gt; = 0.2, params=None, owner=None, prefs: &lt;function is_pref_set at 0x10b9626a8&gt; = None, context='Integrator Init'</em><span class="sig-paren">)</span><a class="headerlink" href="#Function.BogaczEtAl" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute analytic solution to DDM process and return mean response time and accuracy.</p>
<dl class="docutils">
<dt>Description:</dt>
<dd><dl class="first last docutils">
<dt>generates mean response time (RT) and mean error rate (ER) as described in:</dt>
<dd>Bogacz, R., Brown, E., Moehlis, J., Holmes, P., &amp; Cohen, J. D. (2006). The physics of optimal
decision making: a formal analysis of models of performance in two-alternative forced-choice
tasks.  Psychological review, 113(4), 700. (<a class="reference external" href="https://www.ncbi.nlm.nih.gov/pubmed/17014301">PubMed entry</a>)</dd>
</dl>
</dd>
<dt>Initialization arguments:</dt>
<dd><p class="first">variable (float): set to self.value (== self.inputValue)
- params (dict):  runtime_params passed from Mechanism, used as one-time value for current execution:</p>
<blockquote>
<div><ul class="simple">
<li>drift_rate (DRIFT_RATE: float)</li>
<li>threshold (THRESHOLD: float)</li>
<li>bias (kwDDM_Bias: float)</li>
<li>noise (NOISE: float)</li>
<li>t0 (NON_DECISION_TIME: float)</li>
</ul>
</div></blockquote>
<ul class="simple">
<li>time_scale (TimeScale): specifies &#8220;temporal granularity&#8221; with which mechanism is executed</li>
<li>context (str)</li>
</ul>
<dl class="last docutils">
<dt>Returns the following values in self.value (2D np.array) and in</dt>
<dd>the value of the corresponding outputState in the self.outputStates dict:
- decision variable (float)
- mean error rate (float)
- mean RT (float)
- correct mean RT (float) - Navarro and Fuss only
- correct mean ER (float) - Navarro and Fuss only</dd>
</dl>
</dd>
</dl>
<dl class="method">
<dt id="Function.BogaczEtAl.function">
<code class="descname">function</code><span class="sig-paren">(</span><em>variable=None</em>, <em>params=None</em>, <em>time_scale=&lt;TimeScale.TRIAL: 1&gt;</em>, <em>context=None</em><span class="sig-paren">)</span><a class="headerlink" href="#Function.BogaczEtAl.function" title="Permalink to this definition">¶</a></dt>
<dd><p>DDM function</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Variables:</th><td class="field-body"><a class="reference internal" href="#Function.ArgumentTherapy.variable" title="Function.ArgumentTherapy.variable"><strong>variable</strong></a> &#8211; (list)</td>
</tr>
<tr class="field-even field"><th class="field-name">Parameters:</th><td class="field-body"><strong>params</strong> &#8211; (dict) with entries specifying:
drift_rate...</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="Function.NavarroAndFuss">
<em class="property">class </em><code class="descclassname">Function.</code><code class="descname">NavarroAndFuss</code><span class="sig-paren">(</span><em>variable_default=[[0]], drift_rate: &lt;function parameter_spec at 0x10b973ae8&gt; = 1.0, starting_point: &lt;function parameter_spec at 0x10b973ae8&gt; = 0.0, threshold: &lt;function parameter_spec at 0x10b973ae8&gt; = 1.0, noise: &lt;function parameter_spec at 0x10b973ae8&gt; = 0.5, t0: &lt;function parameter_spec at 0x10b973ae8&gt; = 0.2, params=None, owner=None, prefs: &lt;function is_pref_set at 0x10b9626a8&gt; = None, context='Integrator Init'</em><span class="sig-paren">)</span><a class="headerlink" href="#Function.NavarroAndFuss" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute analytic solution to distribution of DDM responses (mean and variance of response time and accuracy).</p>
<dl class="docutils">
<dt>Description:</dt>
<dd><dl class="first last docutils">
<dt>generates distributions of response time (RT) and error rate (ER) as described in:</dt>
<dd>Navarro, D. J., and Fuss, I. G. &#8220;Fast and accurate calculations for first-passage times in
Wiener diffusion models.&#8221; Journal of Mathematical Psychology 53.4 (2009): 222-230.
(<a class="reference external" href="http://www.sciencedirect.com/science/article/pii/S0022249609000200">ScienceDirect entry</a>)</dd>
</dl>
</dd>
<dt>Initialization arguments:</dt>
<dd><p class="first">variable (float): set to self.value (== self.inputValue)
- params (dict):  runtime_params passed from Mechanism, used as one-time value for current execution:</p>
<blockquote>
<div><ul class="simple">
<li>drift_rate (DRIFT_RATE: float)</li>
<li>threshold (THRESHOLD: float)</li>
<li>bias (kwDDM_Bias: float)</li>
<li>noise (NOISE: float)</li>
<li>t0 (NON_DECISION_TIME: float)</li>
</ul>
</div></blockquote>
<ul class="simple">
<li>time_scale (TimeScale): specifies &#8220;temporal granularity&#8221; with which mechanism is executed</li>
<li>context (str)</li>
</ul>
<dl class="last docutils">
<dt>Returns the following values in self.value (2D np.array) and in</dt>
<dd>the value of the corresponding outputState in the self.outputStates dict:
- decision variable (float)
- mean error rate (float)
- mean RT (float)
- correct mean RT (float) - Navarro and Fuss only
- correct mean ER (float) - Navarro and Fuss only</dd>
</dl>
</dd>
</dl>
<dl class="method">
<dt id="Function.NavarroAndFuss.function">
<code class="descname">function</code><span class="sig-paren">(</span><em>variable=None</em>, <em>params=None</em>, <em>time_scale=&lt;TimeScale.TRIAL: 1&gt;</em>, <em>context=None</em><span class="sig-paren">)</span><a class="headerlink" href="#Function.NavarroAndFuss.function" title="Permalink to this definition">¶</a></dt>
<dd><p>DDM function</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Variables:</th><td class="field-body"><a class="reference internal" href="#Function.ArgumentTherapy.variable" title="Function.ArgumentTherapy.variable"><strong>variable</strong></a> &#8211; (list)</td>
</tr>
<tr class="field-even field"><th class="field-name">Parameters:</th><td class="field-body"><strong>params</strong> &#8211; (dict) with entries specifying:
drift_rate...</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="Function.LearningFunction">
<em class="property">class </em><code class="descclassname">Function.</code><code class="descname">LearningFunction</code><span class="sig-paren">(</span><em>variable_default</em>, <em>params</em>, <em>owner=None</em>, <em>name=None</em>, <em>prefs=None</em>, <em>context='Function_Base Init'</em><span class="sig-paren">)</span><a class="headerlink" href="#Function.LearningFunction" title="Permalink to this definition">¶</a></dt>
<dd><p>Abstract class of <a class="reference internal" href="#"><span class="doc">Functions</span></a> used for learning.</p>
<p>All LearningFunctions take three input values (specified in each of the three required items of the
<a class="reference internal" href="#Function.ArgumentTherapy.variable" title="Function.ArgumentTherapy.variable"><code class="xref any py py-attr docutils literal"><span class="pre">variable</span></code></a> argument), and return two output values.</p>
<dl class="docutils">
<dt>Input values:</dt>
<dd><ul class="first last simple">
<li>input to the parameter being modified (variable[0]);</li>
<li>output of the parameter being modified (variable[1]);</li>
<li>error associated with the output (variable[2]).</li>
</ul>
</dd>
<dt>Output values:</dt>
<dd><ul class="first last simple">
<li>learning_signal: modifications calculated by the function that attempt to reduce the error;</li>
<li>error_signal: the error received, possibly modified by the function.</li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="class">
<dt id="Function.Reinforcement">
<em class="property">class </em><code class="descclassname">Function.</code><code class="descname">Reinforcement</code><span class="sig-paren">(</span><em>variable_default=variableClassDefault</em>, <em>activation_function=SoftMax</em>, <em>learning_rate=None</em>, <em>params=None</em>, <em>name=None</em>, <em>prefs=None</em><span class="sig-paren">)</span><a class="headerlink" href="#Function.Reinforcement" title="Permalink to this definition">¶</a></dt>
<dd><p>Implements a function that calculates a diagonal matrix of weight changes using the reinforcement (delta)
learning rule.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>variable</strong> (<em>List or 2d np.array [length 3] : default variableClassDefault</em>) &#8211; template for the three items provided as the variable in the call to the <a class="reference internal" href="#Function.Reinforcement.function" title="Function.Reinforcement.function"><code class="xref any py py-attr docutils literal"><span class="pre">function</span></code></a>
(in order):
<a class="reference internal" href="#Function.Reinforcement.activation_input" title="Function.Reinforcement.activation_input"><code class="xref any py py-attr docutils literal"><span class="pre">activation_input</span></code></a> (1d np.array),
<a class="reference internal" href="#Function.Reinforcement.activation_output" title="Function.Reinforcement.activation_output"><code class="xref any py py-attr docutils literal"><span class="pre">activation_output</span></code></a> (1d np.array),
<a class="reference internal" href="#Function.Reinforcement.error_signal" title="Function.Reinforcement.error_signal"><code class="xref any py py-attr docutils literal"><span class="pre">error_signal</span></code></a> (1d np.array).</li>
<li><strong>activation_function</strong> (<em>Function or function : SoftMax</em>) &#8211; specifies the function of the mechanism that generates <a class="reference internal" href="#Function.Reinforcement.activation_output" title="Function.Reinforcement.activation_output"><code class="xref any py py-attr docutils literal"><span class="pre">activation_output</span></code></a>.</li>
<li><strong>learning_rate</strong> (<em>float : default default_learning_rate</em>) &#8211; supercedes any specification for the <a class="reference internal" href="Process.html"><span class="doc">process</span></a> and/or <a class="reference internal" href="System.html"><span class="doc">system</span></a> to which the function&#8217;s
<code class="xref any docutils literal"><span class="pre">owner</span></code> belongs (see <a class="reference internal" href="#Function.Reinforcement.learning_rate" title="Function.Reinforcement.learning_rate"><code class="xref any py py-attr docutils literal"><span class="pre">learning_rate</span></code></a> for details).</li>
<li><strong>params</strong> (<em>Optional[Dict[param keyword, param value]]</em>) &#8211; a <a class="reference internal" href="ParameterState.html#parameterstate-specifying-parameters"><span class="std std-ref">parameter dictionary</span></a> that specifies the parameters for the
function.  Values specified for parameters in the dictionary override any assigned to those parameters in
arguments of the constructor.</li>
<li><strong>owner</strong> (<em>Component</em>) &#8211; <code class="xref any docutils literal"><span class="pre">component</span></code> to which to assign the Function.</li>
<li><strong>prefs</strong> (<em>Optional[PreferenceSet or specification dict : Function.classPreferences]</em>) &#8211; the <code class="xref any docutils literal"><span class="pre">PreferenceSet</span></code> for the Function. If it is not specified, a default is assigned using <code class="xref any docutils literal"><span class="pre">classPreferences</span></code>
defined in __init__.py (see <span class="xref doc">PreferenceSet</span> for details).</li>
</ul>
</td>
</tr>
</tbody>
</table>
<dl class="attribute">
<dt id="Function.Reinforcement.variable">
<code class="descname">variable</code><a class="headerlink" href="#Function.Reinforcement.variable" title="Permalink to this definition">¶</a></dt>
<dd><p><em>2d np.array</em> &#8211;  specifies three values used as input to the <a class="reference internal" href="#Function.Reinforcement.function" title="Function.Reinforcement.function"><code class="xref any py py-attr docutils literal"><span class="pre">function</span></code></a>:
<a class="reference internal" href="#Function.Reinforcement.activation_input" title="Function.Reinforcement.activation_input"><code class="xref any py py-attr docutils literal"><span class="pre">activation_input</span></code></a>,
<a class="reference internal" href="#Function.Reinforcement.activation_output" title="Function.Reinforcement.activation_output"><code class="xref any py py-attr docutils literal"><span class="pre">activation_output</span></code></a>, and
<a class="reference internal" href="#Function.Reinforcement.error_signal" title="Function.Reinforcement.error_signal"><code class="xref any py py-attr docutils literal"><span class="pre">error_signal</span></code></a>.</p>
</dd></dl>

<dl class="attribute">
<dt id="Function.Reinforcement.activation_input">
<code class="descname">activation_input</code><a class="headerlink" href="#Function.Reinforcement.activation_input" title="Permalink to this definition">¶</a></dt>
<dd><p><em>1d np.array</em> &#8211; first item of <a class="reference internal" href="#Function.Reinforcement.variable" title="Function.Reinforcement.variable"><code class="xref any py py-attr docutils literal"><span class="pre">variable</span></code></a>;  this is not used (it is implemented for consistency
with other <a class="reference internal" href="#Function.LearningFunction" title="Function.LearningFunction"><code class="xref any py py-class docutils literal"><span class="pre">LearningFunctions</span></code></a>).</p>
</dd></dl>

<dl class="attribute">
<dt id="Function.Reinforcement.activation_output">
<code class="descname">activation_output</code><a class="headerlink" href="#Function.Reinforcement.activation_output" title="Permalink to this definition">¶</a></dt>
<dd><p><em>1d np.array</em> &#8211; the output of the function for which the matrix being modified provides the input; must have a single non-zero
value (corresponding to the selected &#8220;action&#8221;).</p>
</dd></dl>

<dl class="attribute">
<dt id="Function.Reinforcement.error_signal">
<code class="descname">error_signal</code><a class="headerlink" href="#Function.Reinforcement.error_signal" title="Permalink to this definition">¶</a></dt>
<dd><p><em>1d np.array</em> &#8211; the error signal associated with the <a class="reference internal" href="#Function.Reinforcement.activation_output" title="Function.Reinforcement.activation_output"><code class="xref any py py-attr docutils literal"><span class="pre">activation_output</span></code></a>; must be the same
length as <a class="reference internal" href="#Function.Reinforcement.activation_output" title="Function.Reinforcement.activation_output"><code class="xref any py py-attr docutils literal"><span class="pre">activation_output</span></code></a> and must have a single non-zero value in the
same position as the one in <a class="reference internal" href="#Function.Reinforcement.activation_output" title="Function.Reinforcement.activation_output"><code class="xref any py py-attr docutils literal"><span class="pre">activation_output</span></code></a>.</p>
</dd></dl>

<dl class="attribute">
<dt id="Function.Reinforcement.activation_function">
<code class="descname">activation_function</code><a class="headerlink" href="#Function.Reinforcement.activation_function" title="Permalink to this definition">¶</a></dt>
<dd><p><em>Function or function : SoftMax</em> &#8211; the function of the mechanism that generates <a class="reference internal" href="#Function.Reinforcement.activation_output" title="Function.Reinforcement.activation_output"><code class="xref any py py-attr docutils literal"><span class="pre">activation_output</span></code></a>; must
return and array with a single non-zero value.</p>
</dd></dl>

<dl class="attribute">
<dt id="Function.Reinforcement.learning_rate">
<code class="descname">learning_rate</code><a class="headerlink" href="#Function.Reinforcement.learning_rate" title="Permalink to this definition">¶</a></dt>
<dd><p><em>float</em> &#8211; the learning rate used by the function.  If specified, it supercedes any learning_rate specified for the
<code class="xref any docutils literal"><span class="pre">process</span></code> and/or <code class="xref any docutils literal"><span class="pre">system</span></code> to which the function&#8217;s  <a class="reference internal" href="#Function.Reinforcement.owner" title="Function.Reinforcement.owner"><code class="xref any py py-attr docutils literal"><span class="pre">owner</span></code></a> belongs.  If it is <code class="xref any docutils literal"><span class="pre">None</span></code>, then the learning_rate specified for the process to
which the <a class="reference internal" href="#Function.Reinforcement.owner" title="Function.Reinforcement.owner"><code class="xref any py py-attr docutils literal"><span class="pre">owner</span></code></a> belongs is used;  and, if that is <code class="xref any docutils literal"><span class="pre">None</span></code>, then the learning_rate for the
system to which it belongs is used. If all are <code class="xref any docutils literal"><span class="pre">None</span></code>, then the
<a class="reference internal" href="#Function.Reinforcement.default_learning_rate" title="Function.Reinforcement.default_learning_rate"><code class="xref any py py-attr docutils literal"><span class="pre">default_learning_rate</span></code></a> is used.</p>
</dd></dl>

<dl class="attribute">
<dt id="Function.Reinforcement.default_learning_rate">
<code class="descname">default_learning_rate</code><a class="headerlink" href="#Function.Reinforcement.default_learning_rate" title="Permalink to this definition">¶</a></dt>
<dd><p><em>float</em> &#8211; the value used for the <a class="reference internal" href="#Function.Reinforcement.learning_rate" title="Function.Reinforcement.learning_rate"><code class="xref any py py-attr docutils literal"><span class="pre">learning_rate</span></code></a> if it is not otherwise specified.</p>
</dd></dl>

<dl class="attribute">
<dt id="Function.Reinforcement.function">
<code class="descname">function</code><a class="headerlink" href="#Function.Reinforcement.function" title="Permalink to this definition">¶</a></dt>
<dd><p><em>function</em> &#8211; the function that computes the weight change matrix, and returns that along with the
<a class="reference internal" href="#Function.Reinforcement.error_signal" title="Function.Reinforcement.error_signal"><code class="xref any py py-attr docutils literal"><span class="pre">error_signal</span></code></a> received.</p>
</dd></dl>

<dl class="attribute">
<dt id="Function.Reinforcement.owner">
<code class="descname">owner</code><a class="headerlink" href="#Function.Reinforcement.owner" title="Permalink to this definition">¶</a></dt>
<dd><p><em>Mechanism</em> &#8211; <a class="reference internal" href="Mechanism.html"><span class="doc">mechanism</span></a> to which the function belongs.</p>
</dd></dl>

<dl class="attribute">
<dt id="Function.Reinforcement.prefs">
<code class="descname">prefs</code><a class="headerlink" href="#Function.Reinforcement.prefs" title="Permalink to this definition">¶</a></dt>
<dd><p><em>PreferenceSet or specification dict : Projection.classPreferences</em> &#8211; the <code class="xref any docutils literal"><span class="pre">PreferenceSet</span></code> for function. Specified in the <a class="reference internal" href="#Function.Reinforcement.prefs" title="Function.Reinforcement.prefs"><code class="xref any py py-attr docutils literal"><span class="pre">prefs</span></code></a> argument of the constructor for the function;
if it is not specified, a default is assigned using <code class="xref any docutils literal"><span class="pre">classPreferences</span></code> defined in __init__.py
(see <span class="xref doc">PreferenceSet</span> for details).</p>
</dd></dl>

<dl class="method">
<dt>
<code class="descname">function</code><span class="sig-paren">(</span><em>variable=None</em>, <em>params=None</em>, <em>time_scale=&lt;TimeScale.TRIAL: 1&gt;</em>, <em>context=None</em><span class="sig-paren">)</span></dt>
<dd><p>Calculate a matrix of weight changes from a single (scalar) error term</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>variable</strong> (<em>List or 2d np.array [length 3] : default variableClassDefault</em>) &#8211; must have three items that are the values for (in order):
<a class="reference internal" href="#Function.Reinforcement.activation_input" title="Function.Reinforcement.activation_input"><code class="xref any py py-attr docutils literal"><span class="pre">activation_input</span></code></a> (not used),
<a class="reference internal" href="#Function.Reinforcement.activation_output" title="Function.Reinforcement.activation_output"><code class="xref any py py-attr docutils literal"><span class="pre">activation_output</span></code></a> (1d np.array with a single non-zero value),
<a class="reference internal" href="#Function.Reinforcement.error_signal" title="Function.Reinforcement.error_signal"><code class="xref any py py-attr docutils literal"><span class="pre">error_signal</span></code></a> (1d np.array).</li>
<li><strong>params</strong> (<em>Optional[Dict[param keyword, param value]]</em>) &#8211; a <a class="reference internal" href="ParameterState.html#parameterstate-specifying-parameters"><span class="std std-ref">parameter dictionary</span></a> that specifies the parameters for the
function.  Values specified for parameters in the dictionary override any assigned to those parameters in
arguments of the constructor.</li>
<li><strong>time_scale</strong> (<em>TimeScale : default TimeScale.TRIAL</em>) &#8211; specifies whether the function is executed on the time_step or trial time scale.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><ul class="simple">
<li><strong>diagonal weight change matrix</strong> (<em>2d np.array</em>) &#8211; has a single non-zero entry in the same row and column as the one in
<a class="reference internal" href="#Function.Reinforcement.activation_output" title="Function.Reinforcement.activation_output"><code class="xref any py py-attr docutils literal"><span class="pre">activation_output</span></code></a> and <a class="reference internal" href="#Function.Reinforcement.error_signal" title="Function.Reinforcement.error_signal"><code class="xref any py py-attr docutils literal"><span class="pre">error_signal</span></code></a>.</li>
<li><strong>error signal</strong> (<em>1d np.array</em>) &#8211; same as value received in <a class="reference internal" href="#Function.Reinforcement.error_signal" title="Function.Reinforcement.error_signal"><code class="xref any py py-attr docutils literal"><span class="pre">error_signal</span></code></a> argument.</li>
</ul>
</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="Function.BackPropagation">
<em class="property">class </em><code class="descclassname">Function.</code><code class="descname">BackPropagation</code><span class="sig-paren">(</span><em>variable_default=variableClassDefault</em>, <em>activation_derivative_fct=Logistic().derivative</em>, <em>error_derivative_fct=Logistic().derivative</em>, <em>error_matrix=None</em>, <em>learning_rate=None</em>, <em>params=None</em>, <em>name=None</em>, <em>prefs=None</em><span class="sig-paren">)</span><a class="headerlink" href="#Function.BackPropagation" title="Permalink to this definition">¶</a></dt>
<dd><p>Implements a function that calculate a matrix of weight changes using the backpropagation
(<a class="reference external" href="http://www.nature.com/nature/journal/v323/n6088/abs/323533a0.html">Generalized Delta Rule</a>) learning algorithm.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>variable</strong> (<em>List or 2d np.array [length 3] : default variableClassDefault</em>) &#8211; specifies a template for the three items provided as the variable in the call to the
<a class="reference internal" href="#Function.BackPropagation.function" title="Function.BackPropagation.function"><code class="xref any py py-attr docutils literal"><span class="pre">function</span></code></a> (in order):
<a class="reference internal" href="#Function.BackPropagation.activation_input" title="Function.BackPropagation.activation_input"><code class="xref any py py-attr docutils literal"><span class="pre">activation_input</span></code></a> (1d np.array),
<a class="reference internal" href="#Function.BackPropagation.activation_output" title="Function.BackPropagation.activation_output"><code class="xref any py py-attr docutils literal"><span class="pre">activation_output</span></code></a> (1d np.array),
<a class="reference internal" href="#Function.BackPropagation.error_signal" title="Function.BackPropagation.error_signal"><code class="xref any py py-attr docutils literal"><span class="pre">error_signal</span></code></a> (1d np.array).</li>
<li><strong>activation_derivative</strong> (<em>Function or function</em>) &#8211; specifies the derivative for the function of the mechanism that generates
<a class="reference internal" href="#Function.BackPropagation.activation_output" title="Function.BackPropagation.activation_output"><code class="xref any py py-attr docutils literal"><span class="pre">activation_output</span></code></a>.</li>
<li><strong>error_derivative</strong> (<em>Function or function</em>) &#8211; specifies the derivative for the function of the mechanism that is the receiver of the
<a class="reference internal" href="#Function.BackPropagation.error_matrix" title="Function.BackPropagation.error_matrix"><code class="xref any py py-attr docutils literal"><span class="pre">error_matrix</span></code></a>.</li>
<li><strong>error_matrix</strong> (<em>List, 2d np.array, np.matrix, ParameterState, or MappingProjection</em>) &#8211; matrix, the output of which is used to calculate the <a class="reference internal" href="#Function.BackPropagation.error_signal" title="Function.BackPropagation.error_signal"><code class="xref any py py-attr docutils literal"><span class="pre">error_signal</span></code></a>.
If it is specified as a ParameterState it must be one for the <a class="reference internal" href="MappingProjection.html#MappingProjection.MappingProjection.matrix" title="MappingProjection.MappingProjection.matrix"><code class="xref any py py-attr docutils literal"><span class="pre">matrix</span></code></a>
parameter of a <a class="reference internal" href="MappingProjection.html"><span class="doc">MappingProjection</span></a>;  if it is a MappingProjection, it must be one with a
MATRIX parameterState.</li>
<li><strong>learning_rate</strong> (<em>float : default default_learning_rate</em>) &#8211; supercedes any specification for the <a class="reference internal" href="Process.html"><span class="doc">process</span></a> and/or <a class="reference internal" href="System.html"><span class="doc">system</span></a> to which the function&#8217;s
<code class="xref any docutils literal"><span class="pre">owner</span></code> belongs (see <a class="reference internal" href="#Function.BackPropagation.learning_rate" title="Function.BackPropagation.learning_rate"><code class="xref any py py-attr docutils literal"><span class="pre">learning_rate</span></code></a> for details).</li>
<li><strong>params</strong> (<em>Optional[Dict[param keyword, param value]]</em>) &#8211; a <a class="reference internal" href="ParameterState.html#parameterstate-specifying-parameters"><span class="std std-ref">parameter dictionary</span></a> that specifies the parameters for the
function.  Values specified for parameters in the dictionary override any assigned to those parameters in
arguments of the constructor.</li>
<li><strong>owner</strong> (<em>Component</em>) &#8211; <code class="xref any docutils literal"><span class="pre">component</span></code> to which to assign the Function.</li>
<li><strong>prefs</strong> (<em>Optional[PreferenceSet or specification dict : Function.classPreferences]</em>) &#8211; the <code class="xref any docutils literal"><span class="pre">PreferenceSet</span></code> for the Function. If it is not specified, a default is assigned using <code class="xref any docutils literal"><span class="pre">classPreferences</span></code>
defined in __init__.py (see <span class="xref doc">PreferenceSet</span> for details).</li>
</ul>
</td>
</tr>
</tbody>
</table>
<dl class="attribute">
<dt id="Function.BackPropagation.variable">
<code class="descname">variable</code><a class="headerlink" href="#Function.BackPropagation.variable" title="Permalink to this definition">¶</a></dt>
<dd><p><em>2d np.array</em> &#8211;  contains the three values used as input to the <a class="reference internal" href="#Function.BackPropagation.function" title="Function.BackPropagation.function"><code class="xref any py py-attr docutils literal"><span class="pre">function</span></code></a>:
<a class="reference internal" href="#Function.BackPropagation.activation_input" title="Function.BackPropagation.activation_input"><code class="xref any py py-attr docutils literal"><span class="pre">activation_input</span></code></a>,
<a class="reference internal" href="#Function.BackPropagation.activation_output" title="Function.BackPropagation.activation_output"><code class="xref any py py-attr docutils literal"><span class="pre">activation_output</span></code></a>, and
<a class="reference internal" href="#Function.BackPropagation.error_signal" title="Function.BackPropagation.error_signal"><code class="xref any py py-attr docutils literal"><span class="pre">error_signal</span></code></a>.</p>
</dd></dl>

<dl class="attribute">
<dt id="Function.BackPropagation.activation_input">
<code class="descname">activation_input</code><a class="headerlink" href="#Function.BackPropagation.activation_input" title="Permalink to this definition">¶</a></dt>
<dd><p><em>1d np.array</em> &#8211; the input to the matrix being modified; same as 1st item of <a href="#id1"><span class="problematic" id="id2">`</span></a>variable &lt;BackPropagation.variable&gt;.</p>
</dd></dl>

<dl class="attribute">
<dt id="Function.BackPropagation.activation_output">
<code class="descname">activation_output</code><a class="headerlink" href="#Function.BackPropagation.activation_output" title="Permalink to this definition">¶</a></dt>
<dd><p><em>1d np.array</em> &#8211; the output of the function for which the matrix being modified provides the input;
same as 2nd item of <a href="#id3"><span class="problematic" id="id4">`</span></a>variable &lt;BackPropagation.variable&gt;.</p>
</dd></dl>

<dl class="attribute">
<dt id="Function.BackPropagation.error_signal">
<code class="descname">error_signal</code><a class="headerlink" href="#Function.BackPropagation.error_signal" title="Permalink to this definition">¶</a></dt>
<dd><p><em>1d np.array</em> &#8211; the error signal for the next matrix (layer above) in the learning sequence, or the error computed from the
target (training signal) and the output of the last mechanism in the sequence;
same as 3rd item of <a href="#id5"><span class="problematic" id="id6">`</span></a>variable &lt;BackPropagation.variable&gt;.</p>
</dd></dl>

<dl class="attribute">
<dt id="Function.BackPropagation.error_matrix">
<code class="descname">error_matrix</code><a class="headerlink" href="#Function.BackPropagation.error_matrix" title="Permalink to this definition">¶</a></dt>
<dd><p><em>2d np.array or ParameterState</em> &#8211; matrix, the output of which is used to calculate the <a class="reference internal" href="#Function.BackPropagation.error_signal" title="Function.BackPropagation.error_signal"><code class="xref any py py-attr docutils literal"><span class="pre">error_signal</span></code></a>;
if it is a <a class="reference internal" href="ParameterState.html"><span class="doc">ParameterState</span></a>, it refers to the MATRIX parameterState of the <a class="reference internal" href="MappingProjection.html"><span class="doc">MappingProjection</span></a> being learned.</p>
</dd></dl>

<dl class="attribute">
<dt id="Function.BackPropagation.learning_rate">
<code class="descname">learning_rate</code><a class="headerlink" href="#Function.BackPropagation.learning_rate" title="Permalink to this definition">¶</a></dt>
<dd><p><em>float</em> &#8211; the learning rate used by the function.  If specified, it supercedes any learning_rate specified for the
<code class="xref any docutils literal"><span class="pre">process</span></code> and/or <code class="xref any docutils literal"><span class="pre">system</span></code> to which the function&#8217;s  <a class="reference internal" href="#Function.BackPropagation.owner" title="Function.BackPropagation.owner"><code class="xref any py py-attr docutils literal"><span class="pre">owner</span></code></a> belongs.  If it is <code class="xref any docutils literal"><span class="pre">None</span></code>, then the learning_rate specified for the process to
which the <code class="xref any docutils literal"><span class="pre">owner</span></code> belongs is used;  and, if that is <code class="xref any docutils literal"><span class="pre">None</span></code>, then the learning_rate for the
system to which it belongs is used. If all are <code class="xref any docutils literal"><span class="pre">None</span></code>, then the
<a class="reference internal" href="#Function.BackPropagation.default_learning_rate" title="Function.BackPropagation.default_learning_rate"><code class="xref any py py-attr docutils literal"><span class="pre">default_learning_rate</span></code></a> is used.</p>
</dd></dl>

<dl class="attribute">
<dt id="Function.BackPropagation.default_learning_rate">
<code class="descname">default_learning_rate</code><a class="headerlink" href="#Function.BackPropagation.default_learning_rate" title="Permalink to this definition">¶</a></dt>
<dd><p><em>float</em> &#8211; the value used for the <a class="reference internal" href="#Function.BackPropagation.learning_rate" title="Function.BackPropagation.learning_rate"><code class="xref any py py-attr docutils literal"><span class="pre">learning_rate</span></code></a> if it is not otherwise specified.</p>
</dd></dl>

<dl class="attribute">
<dt id="Function.BackPropagation.function">
<code class="descname">function</code><a class="headerlink" href="#Function.BackPropagation.function" title="Permalink to this definition">¶</a></dt>
<dd><p><em>function</em> &#8211; the function that computes the weight change matrix, and returns that along with the
<a class="reference internal" href="#Function.BackPropagation.error_signal" title="Function.BackPropagation.error_signal"><code class="xref any py py-attr docutils literal"><span class="pre">error_signal</span></code></a> received, weighted by the contribution made by each element of
<a class="reference internal" href="#Function.BackPropagation.activation_output" title="Function.BackPropagation.activation_output"><code class="xref any py py-attr docutils literal"><span class="pre">activation_output</span></code></a> as a function of the
<a class="reference internal" href="#Function.BackPropagation.error_matrix" title="Function.BackPropagation.error_matrix"><code class="xref any py py-attr docutils literal"><span class="pre">error_matrix</span></code></a>.</p>
</dd></dl>

<dl class="attribute">
<dt id="Function.BackPropagation.owner">
<code class="descname">owner</code><a class="headerlink" href="#Function.BackPropagation.owner" title="Permalink to this definition">¶</a></dt>
<dd><p><em>Mechanism</em> &#8211; <a class="reference internal" href="Mechanism.html"><span class="doc">mechanism</span></a> to which the function belongs.</p>
</dd></dl>

<dl class="attribute">
<dt id="Function.BackPropagation.prefs">
<code class="descname">prefs</code><a class="headerlink" href="#Function.BackPropagation.prefs" title="Permalink to this definition">¶</a></dt>
<dd><p><em>PreferenceSet or specification dict : Projection.classPreferences</em> &#8211; the <code class="xref any docutils literal"><span class="pre">PreferenceSet</span></code> for function. Specified in the <a class="reference internal" href="#Function.BackPropagation.prefs" title="Function.BackPropagation.prefs"><code class="xref any py py-attr docutils literal"><span class="pre">prefs</span></code></a> argument of the constructor for the function;
if it is not specified, a default is assigned using <code class="xref any docutils literal"><span class="pre">classPreferences</span></code> defined in __init__.py
(see <span class="xref doc">PreferenceSet</span> for details).</p>
</dd></dl>

<dl class="method">
<dt>
<code class="descname">function</code><span class="sig-paren">(</span><em>variable=None</em>, <em>params=None</em>, <em>time_scale=&lt;TimeScale.TRIAL: 1&gt;</em>, <em>context=None</em><span class="sig-paren">)</span></dt>
<dd><p>Calculate and return a matrix of weight changes from arrays of inputs, outputs and error terms</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>variable</strong> (<em>List or 2d np.array [length 3] : default variableClassDefault</em>) &#8211; must have three items that are the values for (in order):
<a class="reference internal" href="#Function.BackPropagation.activation_input" title="Function.BackPropagation.activation_input"><code class="xref any py py-attr docutils literal"><span class="pre">activation_input</span></code></a> (1d np.array),
<a class="reference internal" href="#Function.BackPropagation.activation_output" title="Function.BackPropagation.activation_output"><code class="xref any py py-attr docutils literal"><span class="pre">activation_output</span></code></a> (1d np.array),
<a class="reference internal" href="#Function.BackPropagation.error_signal" title="Function.BackPropagation.error_signal"><code class="xref any py py-attr docutils literal"><span class="pre">error_signal</span></code></a> (1d np.array).</li>
<li><strong>params</strong> (<em>Optional[Dict[param keyword, param value]]</em>) &#8211; a <a class="reference internal" href="ParameterState.html#parameterstate-specifying-parameters"><span class="std std-ref">parameter dictionary</span></a> that specifies the parameters for the
function.  Values specified for parameters in the dictionary override any assigned to those parameters in
arguments of the constructor.</li>
<li><strong>time_scale</strong> (<em>TimeScale : default TimeScale.TRIAL</em>) &#8211; specifies whether the function is executed on the time_step or trial time scale.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><ul class="simple">
<li><strong>weight change matrix</strong> (<em>2d np.array</em>) &#8211; the modifications to make to the matrix.</li>
<li><strong>weighted error signal</strong> (<em>1d np.array</em>) &#8211; <a class="reference internal" href="#Function.BackPropagation.error_signal" title="Function.BackPropagation.error_signal"><code class="xref any py py-attr docutils literal"><span class="pre">error_signal</span></code></a>, weighted by the contribution made by each element of
<a class="reference internal" href="#Function.BackPropagation.activation_output" title="Function.BackPropagation.activation_output"><code class="xref any py py-attr docutils literal"><span class="pre">activation_output</span></code></a> as a function of
<a class="reference internal" href="#Function.BackPropagation.error_matrix" title="Function.BackPropagation.error_matrix"><code class="xref any py py-attr docutils literal"><span class="pre">error_matrix</span></code></a>.</li>
</ul>
</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

</div>
</div>


           </div>
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="Run.html" class="btn btn-neutral float-right" title="Run" accesskey="n">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="MappingProjection.html" class="btn btn-neutral" title="MappingProjection" accesskey="p"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2016, Jonathan D. Cohen.

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'./',
            VERSION:'0.1',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true
        };
    </script>
      <script type="text/javascript" src="_static/jquery.js"></script>
      <script type="text/javascript" src="_static/underscore.js"></script>
      <script type="text/javascript" src="_static/doctools.js"></script>

  

  
  
    <script type="text/javascript" src="_static/js/theme.js"></script>
  

  
  
  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.StickyNav.enable();
      });
  </script>
   

</body>
</html>