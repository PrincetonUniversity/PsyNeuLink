

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Functions &mdash; PsyNeuLink 0.1 documentation</title>
  

  
  

  

  
  
    

  

  
  
    <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  

  

  
        <link rel="index" title="Index"
              href="genindex.html"/>
        <link rel="search" title="Search" href="search.html"/>
    <link rel="top" title="PsyNeuLink 0.1 documentation" href="index.html"/>
        <link rel="next" title="Run" href="Run.html"/>
        <link rel="prev" title="MappingProjection" href="MappingProjection.html"/> 

  
  <script src="_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="index.html" class="icon icon-home"> PsyNeuLink
          

          
          </a>

          
            
            
              <div class="version">
                0.1
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
                <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="System.html">System</a></li>
<li class="toctree-l1"><a class="reference internal" href="Process.html">Process</a></li>
<li class="toctree-l1"><a class="reference internal" href="Mechanism.html">Mechanisms</a></li>
<li class="toctree-l1"><a class="reference internal" href="State.html">States</a></li>
<li class="toctree-l1"><a class="reference internal" href="Projection.html">Projections</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">Functions</a><ul class="simple">
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="Run.html">Run</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
        <a href="index.html">PsyNeuLink</a>
      </nav>


      
      <div class="wy-nav-content">
        <div class="rst-content">
          

 



<div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href="index.html">Docs</a> &raquo;</li>
      
    <li>Functions</li>
      <li class="wy-breadcrumbs-aside">
        
          
            <a href="_sources/Function.txt" rel="nofollow"> View page source</a>
          
        
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="functions">
<h1>Functions<a class="headerlink" href="#functions" title="Permalink to this headline">¶</a></h1>
<div class="toctree-wrapper compound">
</div>
<span class="target" id="module-Function"></span><dl class="docutils">
<dt>Example function:</dt>
<dd><ul class="first last simple">
<li><a class="reference internal" href="#Function.Contradiction" title="Function.Contradiction"><code class="xref py py-class docutils literal"><span class="pre">Contradiction</span></code></a></li>
</ul>
</dd>
<dt>Combination Components:</dt>
<dd><ul class="first last simple">
<li><a class="reference internal" href="#Function.LinearCombination" title="Function.LinearCombination"><code class="xref py py-class docutils literal"><span class="pre">LinearCombination</span></code></a></li>
</ul>
</dd>
<dt>TransferMechanism Components:</dt>
<dd><ul class="first last simple">
<li><a class="reference internal" href="#Function.Linear" title="Function.Linear"><code class="xref py py-class docutils literal"><span class="pre">Linear</span></code></a></li>
<li><a class="reference internal" href="#Function.Exponential" title="Function.Exponential"><code class="xref py py-class docutils literal"><span class="pre">Exponential</span></code></a></li>
<li><a class="reference internal" href="#Function.Logistic" title="Function.Logistic"><code class="xref py py-class docutils literal"><span class="pre">Logistic</span></code></a></li>
<li><a class="reference internal" href="#Function.SoftMax" title="Function.SoftMax"><code class="xref py py-class docutils literal"><span class="pre">SoftMax</span></code></a></li>
<li><a class="reference internal" href="#Function.LinearMatrix" title="Function.LinearMatrix"><code class="xref py py-class docutils literal"><span class="pre">LinearMatrix</span></code></a></li>
</ul>
</dd>
<dt>Integrator Components:</dt>
<dd><ul class="first last simple">
<li><a class="reference internal" href="#Function.Integrator" title="Function.Integrator"><code class="xref py py-class docutils literal"><span class="pre">Integrator</span></code></a></li>
<li><a class="reference internal" href="#Function.BogaczEtAl" title="Function.BogaczEtAl"><code class="xref py py-class docutils literal"><span class="pre">BogaczEtAl</span></code></a></li>
<li><a class="reference internal" href="#Function.NavarroAndFuss" title="Function.NavarroAndFuss"><code class="xref py py-class docutils literal"><span class="pre">NavarroAndFuss</span></code></a></li>
</ul>
</dd>
<dt>Learning Components:</dt>
<dd><ul class="first last simple">
<li><a class="reference internal" href="#Function.Reinforcement" title="Function.Reinforcement"><code class="xref py py-class docutils literal"><span class="pre">Reinforcement</span></code></a></li>
<li><a class="reference internal" href="#Function.BackPropagation" title="Function.BackPropagation"><code class="xref py py-class docutils literal"><span class="pre">BackPropagation</span></code></a></li>
</ul>
</dd>
</dl>
<dl class="class">
<dt id="Function.Contradiction">
<em class="property">class </em><code class="descclassname">Function.</code><code class="descname">Contradiction</code><span class="sig-paren">(</span><em>variable_default=0</em>, <em>params=None</em>, <em>prefs: &lt;function is_pref_set at 0x10bb56598&gt; = None</em>, <em>context='Contradiction INITIALIZING '</em><span class="sig-paren">)</span><a class="headerlink" href="#Function.Contradiction" title="Permalink to this definition">¶</a></dt>
<dd><p>Example function for use as template for function construction</p>
<dl class="docutils">
<dt>Iniialization arguments:</dt>
<dd><ul class="first last">
<li><p class="first">variable (boolean or statement resolving to boolean)</p>
</li>
<li><dl class="first docutils">
<dt>params (dict) specifying the:</dt>
<dd><ul class="first last simple">
<li>propensity (kwPropensity: a mode specifying the manner of responses (tendency to agree or disagree)</li>
<li>pertinacity (kwPertinacity: the consistency with which the manner complies with the propensity</li>
</ul>
</dd>
</dl>
</li>
</ul>
</dd>
</dl>
<p>Contradiction.function returns <code class="xref std std-keyword docutils literal"><span class="pre">True</span></code> or <code class="xref std std-keyword docutils literal"><span class="pre">False</span></code></p>
<dl class="class">
<dt id="Function.Contradiction.Manner">
<em class="property">class </em><code class="descname">Manner</code><a class="headerlink" href="#Function.Contradiction.Manner" title="Permalink to this definition">¶</a></dt>
<dd><p>An enumeration.</p>
</dd></dl>

<dl class="method">
<dt id="Function.Contradiction.function">
<code class="descclassname">Contradiction.</code><code class="descname">function</code><span class="sig-paren">(</span><em>variable=None</em>, <em>params=None</em>, <em>time_scale=&lt;TimeScale.TRIAL: 1&gt;</em>, <em>context=None</em><span class="sig-paren">)</span><a class="headerlink" href="#Function.Contradiction.function" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a boolean that is (or tends to be) the same as or opposite the one passed in</p>
<p>Returns <code class="xref std std-keyword docutils literal"><span class="pre">True</span></code> or <code class="xref std std-keyword docutils literal"><span class="pre">False</span></code>, that is either the same or opposite the statement passed in as the
variable
The propensity parameter must be set to be Manner.OBSEQUIOUS or Manner.CONTRARIAN, which</p>
<blockquote>
<div>determines whether the response is (or tends to be) the same as or opposite to the statement</div></blockquote>
<p>The pertinacity parameter determines the consistency with which the response conforms to the manner</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>variable</strong> &#8211; (boolean) Statement to probe</li>
<li><strong>params</strong> &#8211; (dict) with entires specifying
kwPropensity: Contradiction.Manner - contrarian or obsequious (default: CONTRARIAN)
kwPertinacity: float - obstinate or equivocal (default: 10)</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name" colspan="2">Return response:</th></tr>
<tr class="field-even field"><td>&nbsp;</td><td class="field-body"><p class="first last">(boolean)</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="Function.UserDefinedFunction">
<em class="property">class </em><code class="descclassname">Function.</code><code class="descname">UserDefinedFunction</code><span class="sig-paren">(</span><em>function</em>, <em>variable=None</em>, <em>params=None</em>, <em>prefs: &lt;function is_pref_set at 0x10bb56598&gt; = None</em>, <em>context='USER DEFINED FUNCTION INITIALIZING '</em><span class="sig-paren">)</span><a class="headerlink" href="#Function.UserDefinedFunction" title="Permalink to this definition">¶</a></dt>
<dd><p>Implement user-defined function</p>
<dl class="docutils">
<dt>Initialization arguments:</dt>
<dd><ul class="first last simple">
<li>variable</li>
</ul>
</dd>
</dl>
<p>Linear.function returns scalar result</p>
</dd></dl>

<dl class="class">
<dt id="Function.LinearCombination">
<em class="property">class </em><code class="descclassname">Function.</code><code class="descname">LinearCombination</code><span class="sig-paren">(</span><em>variable_default=[2, 2], scale: &lt;function parameter_spec at 0x10bb709d8&gt; = 1.0, offset: &lt;function parameter_spec at 0x10bb709d8&gt; = 0.0, weights=None, exponents=None, operation: &lt;typecheck.tc_predicates.enum object at 0x10c250828&gt; = 'sum', params=None, prefs: &lt;function is_pref_set at 0x10bb56598&gt; = None, context='LinearCombination INITIALIZING '</em><span class="sig-paren">)</span><a class="headerlink" href="#Function.LinearCombination" title="Permalink to this definition">¶</a></dt>
<dd><p>Linearly combine arrays of values with optional weighting, offset, and/or scaling</p>
<dl class="docutils">
<dt>Description:</dt>
<dd><p class="first">Combine corresponding elements of arrays in variable arg, using arithmetic operation determined by OPERATION
Use optional WEIGHTING argument to weight contribution of each array to the combination
Use optional SCALE and OFFSET parameters to linearly transform the resulting array
Returns a list or 1D array of the same length as the individual ones in the variable</p>
<p>Notes:
* If variable contains only a single array, it is simply linearly transformed using SCALE and OFFSET
* If there is more than one array in variable, they must all be of the same length
* WEIGHTS can be:</p>
<blockquote class="last">
<div><ul class="simple">
<li>1D: each array in the variable is scaled by the corresponding element of WEIGHTS)</li>
<li>2D: each array in the variable is multiplied by (Hadamard Product) the corresponding array in kwWeight</li>
</ul>
</div></blockquote>
</dd>
<dt>Initialization arguments:</dt>
<dd><ul class="first last">
<li><dl class="first docutils">
<dt>variable (value, np.ndarray or list): values to be combined;</dt>
<dd><p class="first last">can be a list of lists, or a 1D or 2D np.array;  a 1D np.array is always returned
if it is a list, it must be a list of numbers, lists, or np.arrays
all items in the list or 2D np.array must be of equal length
the length of WEIGHTS (if provided) must equal the number of arrays (2nd dimension; default is 2)</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>params (dict) can include:</dt>
<dd><ul class="first last">
<li><p class="first">WEIGHTS (list of numbers or 1D np.array): multiplies each variable before combining them (default: [1, 1])</p>
</li>
<li><p class="first">OFFSET (value): added to the result (after the arithmetic operation is applied; default is 0)</p>
</li>
<li><p class="first">SCALE (value): multiples the result (after combining elements; default: 1)</p>
</li>
<li><dl class="first docutils">
<dt>OPERATION (Operation Enum) - method used to combine terms (default: SUM)</dt>
<dd><p class="first last">SUM: element-wise sum of the arrays in variable
PRODUCT: Hadamard Product of the arrays in variable</p>
</dd>
</dl>
</li>
</ul>
</dd>
</dl>
</li>
</ul>
</dd>
</dl>
<p>LinearCombination.function returns combined values:
- single number if variable was a single number
- list of numbers if variable was list of numbers
- 1D np.array if variable was a single np.variable or np.ndarray</p>
<dl class="method">
<dt id="Function.LinearCombination.function">
<code class="descname">function</code><span class="sig-paren">(</span><em>variable=None</em>, <em>params=None</em>, <em>time_scale=&lt;TimeScale.TRIAL: 1&gt;</em>, <em>context=None</em><span class="sig-paren">)</span><a class="headerlink" href="#Function.LinearCombination.function" title="Permalink to this definition">¶</a></dt>
<dd><p>Linearly combine a list of values, and optionally offset and/or scale them</p>
<dl class="docutils">
<dt># DOCUMENT:</dt>
<dd><p class="first">Handles 1-D or 2-D arrays of numbers
Convert to np.array
All elements must be numeric
If linear (single number or 1-D array of numbers) just apply scale and offset
If 2D (array of arrays), apply exponents to each array
If 2D (array of arrays), apply weights to each array
Operators:  SUM AND PRODUCT
&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;-
OLD:
Variable must be a list of items:</p>
<blockquote>
<div><ul class="simple">
<li>each item can be a number or a list of numbers</li>
</ul>
</div></blockquote>
<dl class="docutils">
<dt>Corresponding elements of each item in variable are combined based on OPERATION param:</dt>
<dd><ul class="first last simple">
<li>SUM adds corresponding elements</li>
<li>PRODUCT multiples corresponding elements</li>
</ul>
</dd>
<dt>An initializer (kwLinearCombinationInitializer) can be provided as the first item in variable;</dt>
<dd>it will be populated with a number of elements equal to the second item,
each element of which is determined by OPERATION param:
- for SUM, initializer will be a list of 0&#8217;s
- for PRODUCT, initializer will be a list of 1&#8217;s</dd>
<dt>Returns a list of the same length as the items in variable,</dt>
<dd>each of which is the combination of their corresponding elements specified by OPERATION</dd>
</dl>
<table class="last docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">var variable:</th><td class="field-body">(list of numbers) - values to calculate (default: [0, 0]:</td>
</tr>
<tr class="field-even field"><th class="field-name">params:</th><td class="field-body">(dict) with entries specifying:
EXPONENTS (2D np.array): exponentiate each value in the variable array (default: none)
WEIGHTS (2D np.array): multiply each value in the variable array (default: none):
OFFSET (scalar) - additive constant (default: 0):
SCALE: (scalar) - scaling factor (default: 1)
OPERATION: LinearCombination.Operation - operation to perform (default: SUM):</td>
</tr>
<tr class="field-odd field"><th class="field-name">return:</th><td class="field-body">(1D np.array)</td>
</tr>
</tbody>
</table>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="Function.Linear">
<em class="property">class </em><code class="descclassname">Function.</code><code class="descname">Linear</code><span class="sig-paren">(</span><em>variable_default=[0], slope: &lt;function parameter_spec at 0x10bb709d8&gt; = 1.0, intercept: &lt;function parameter_spec at 0x10bb709d8&gt; = 0.0, params=None, prefs: &lt;function is_pref_set at 0x10bb56598&gt; = None, context='Linear INITIALIZING '</em><span class="sig-paren">)</span><a class="headerlink" href="#Function.Linear" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate a linear transform of input variable (SLOPE, INTERCEPT)</p>
<dl class="docutils">
<dt>Initialization arguments:</dt>
<dd><ul class="first last">
<li><p class="first">variable (number): transformed by linear function: slope * variable + intercept</p>
</li>
<li><dl class="first docutils">
<dt>params (dict): specifies</dt>
<dd><ul class="first last simple">
<li>slope (SLOPE: value) - slope (default: 1)</li>
<li>intercept (INTERCEPT: value) - intercept (defaul: 0)</li>
</ul>
</dd>
</dl>
</li>
</ul>
</dd>
</dl>
<p>Linear.function returns scalar result</p>
<dl class="method">
<dt id="Function.Linear.function">
<code class="descname">function</code><span class="sig-paren">(</span><em>variable=None</em>, <em>params=None</em>, <em>time_scale=&lt;TimeScale.TRIAL: 1&gt;</em>, <em>context=None</em><span class="sig-paren">)</span><a class="headerlink" href="#Function.Linear.function" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate single value (defined by slope and intercept)</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Variables:</th><td class="field-body"><a class="reference internal" href="LearningProjection.html#LearningProjection.LearningProjection.variable" title="LearningProjection.LearningProjection.variable"><strong>variable</strong></a> &#8211; (number) - value to be &#8220;plotted&#8221; (default: 0</td>
</tr>
<tr class="field-even field"><th class="field-name">Parameters:</th><td class="field-body"><strong>params</strong> &#8211; (dict) with entries specifying:
SLOPE: number - slope (default: 1)
INTERCEPT: number - intercept (default: 0)</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return number:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="Function.Linear.derivative">
<code class="descname">derivative</code><span class="sig-paren">(</span><em>output</em>, <em>input=None</em><span class="sig-paren">)</span><a class="headerlink" href="#Function.Linear.derivative" title="Permalink to this definition">¶</a></dt>
<dd><p>Derivative of the softMax sigmoid function</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="Function.Exponential">
<em class="property">class </em><code class="descclassname">Function.</code><code class="descname">Exponential</code><span class="sig-paren">(</span><em>variable_default=0</em>, <em>rate: &lt;function parameter_spec at 0x10bb709d8&gt; = 1.0</em>, <em>scale: &lt;function parameter_spec at 0x10bb709d8&gt; = 1.0</em>, <em>params=None</em>, <em>prefs: &lt;function is_pref_set at 0x10bb56598&gt; = None</em>, <em>context='Exponential INITIALIZING '</em><span class="sig-paren">)</span><a class="headerlink" href="#Function.Exponential" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate an exponential transform of input variable  (RATE, SCALE)</p>
<dl class="docutils">
<dt>Initialization arguments:</dt>
<dd><ul class="first last">
<li><dl class="first docutils">
<dt>variable (number):</dt>
<dd><ul class="first last simple">
<li>scalar value to be transformed by exponential function: scale * e**(rate * x)</li>
</ul>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>params (dict): specifies</dt>
<dd><ul class="first last simple">
<li>rate (RATE: coeffiencent on variable in exponent (default: 1)</li>
<li>scale (SCALE: coefficient on exponential (default: 1)</li>
</ul>
</dd>
</dl>
</li>
</ul>
</dd>
</dl>
<p>Exponential.function returns scalar result</p>
<dl class="method">
<dt id="Function.Exponential.function">
<code class="descname">function</code><span class="sig-paren">(</span><em>variable=None</em>, <em>params=None</em>, <em>time_scale=&lt;TimeScale.TRIAL: 1&gt;</em>, <em>context=None</em><span class="sig-paren">)</span><a class="headerlink" href="#Function.Exponential.function" title="Permalink to this definition">¶</a></dt>
<dd><p>Exponential function</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Variables:</th><td class="field-body"><a class="reference internal" href="LearningProjection.html#LearningProjection.LearningProjection.variable" title="LearningProjection.LearningProjection.variable"><strong>variable</strong></a> &#8211; (number) - value to be exponentiated (default: 0</td>
</tr>
<tr class="field-even field"><th class="field-name">Parameters:</th><td class="field-body"><strong>params</strong> &#8211; (dict) with entries specifying:
RATE: number - rate (default: 1)
SCALE: number - scale (default: 1)</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return number:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="Function.Exponential.derivative">
<code class="descname">derivative</code><span class="sig-paren">(</span><em>output</em>, <em>input=None</em><span class="sig-paren">)</span><a class="headerlink" href="#Function.Exponential.derivative" title="Permalink to this definition">¶</a></dt>
<dd><p>Derivative of the softMax sigmoid function</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="Function.Logistic">
<em class="property">class </em><code class="descclassname">Function.</code><code class="descname">Logistic</code><span class="sig-paren">(</span><em>variable_default=0</em>, <em>gain: &lt;function parameter_spec at 0x10bb709d8&gt; = 1.0</em>, <em>bias: &lt;function parameter_spec at 0x10bb709d8&gt; = 0.0</em>, <em>params=None</em>, <em>prefs: &lt;function is_pref_set at 0x10bb56598&gt; = None</em>, <em>context='Logistic Init'</em><span class="sig-paren">)</span><a class="headerlink" href="#Function.Logistic" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the logistic transform of input variable  (GAIN, BIAS)</p>
<dl class="docutils">
<dt>Initialization arguments:</dt>
<dd><ul class="first last">
<li><dl class="first docutils">
<dt>variable (number):</dt>
<dd><ul class="first last simple">
<li>scalar value to be transformed by logistic function: 1 / (1 + e**(gain*variable + bias))</li>
</ul>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>params (dict): specifies</dt>
<dd><ul class="first last simple">
<li>gain (GAIN): coeffiencent on exponent (default: 1)</li>
<li>bias (BIAS): additive constant in exponent (default: 0)</li>
</ul>
</dd>
</dl>
</li>
</ul>
</dd>
</dl>
<p>Logistic.function returns scalar result</p>
<dl class="method">
<dt id="Function.Logistic.function">
<code class="descname">function</code><span class="sig-paren">(</span><em>variable=None</em>, <em>params=None</em>, <em>time_scale=&lt;TimeScale.TRIAL: 1&gt;</em>, <em>context=None</em><span class="sig-paren">)</span><a class="headerlink" href="#Function.Logistic.function" title="Permalink to this definition">¶</a></dt>
<dd><p>Logistic sigmoid function</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Variables:</th><td class="field-body"><a class="reference internal" href="LearningProjection.html#LearningProjection.LearningProjection.variable" title="LearningProjection.LearningProjection.variable"><strong>variable</strong></a> &#8211; (number) - value to be transformed by logistic function (default: 0)</td>
</tr>
<tr class="field-even field"><th class="field-name">Parameters:</th><td class="field-body"><strong>params</strong> &#8211; (dict) with entries specifying:
GAIN: number - gain (default: 1)
BIAS: number - rate (default: 0)</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return number:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="Function.Logistic.derivative">
<code class="descname">derivative</code><span class="sig-paren">(</span><em>output</em>, <em>input=None</em><span class="sig-paren">)</span><a class="headerlink" href="#Function.Logistic.derivative" title="Permalink to this definition">¶</a></dt>
<dd><p>Derivative of the logistic signmoid function</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="Function.SoftMax">
<em class="property">class </em><code class="descclassname">Function.</code><code class="descname">SoftMax</code><span class="sig-paren">(</span><em>variable_default=0</em>, <em>gain: &lt;function parameter_spec at 0x10bb709d8&gt; = 1.0</em>, <em>output: &lt;typecheck.tc_predicates.enum object at 0x10c250588&gt; = 'all'</em>, <em>params: &lt;typecheck.framework.optional object at 0x10c2508d0&gt; = None</em>, <em>prefs: &lt;function is_pref_set at 0x10bb56598&gt; = None</em>, <em>context='SoftMax Init'</em><span class="sig-paren">)</span><a class="headerlink" href="#Function.SoftMax" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the softMax transform of input variable  (GAIN, BIAS)</p>
<dl class="docutils">
<dt>Initialization arguments:</dt>
<dd><ul class="first last">
<li><dl class="first docutils">
<dt>variable (number):</dt>
<dd><ul class="first last simple">
<li>scalar value to be transformed by softMax function: e**(gain * variable) / sum(e**(gain * variable))</li>
</ul>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>params (dict): specifies</dt>
<dd><ul class="first">
<li><p class="first">gain (GAIN): coeffiencent on exponent (default: 1)</p>
</li>
<li><dl class="first docutils">
<dt>output (OUTPUT_TYPE): determines how to populate the return array (default: ALL)</dt>
<dd><p class="first last">ALL: array each element of which is the softmax value of the elements in the input array
MAX_VAL: array with a scalar for the element with the maximum softmax value, and zeros elsewhere
MAX_INDICATOR: array with a one for the element with the maximum softmax value, and zeros elsewhere
PROB: probabilistially picks an element based on their softmax values to pass through; all others are zero</p>
</dd>
</dl>
</li>
</ul>
<p class="last"># + max (kwMax): only reports max value, all others set to 0 (default: <code class="xref std std-keyword docutils literal"><span class="pre">False</span></code>)</p>
</dd>
</dl>
</li>
</ul>
</dd>
</dl>
<p>SoftMax.function returns scalar result</p>
<dl class="method">
<dt id="Function.SoftMax.function">
<code class="descname">function</code><span class="sig-paren">(</span><em>variable=None</em>, <em>params=None</em>, <em>time_scale=&lt;TimeScale.TRIAL: 1&gt;</em>, <em>context=None</em><span class="sig-paren">)</span><a class="headerlink" href="#Function.SoftMax.function" title="Permalink to this definition">¶</a></dt>
<dd><p>SoftMax sigmoid function</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Variables:</th><td class="field-body"><a class="reference internal" href="LearningProjection.html#LearningProjection.LearningProjection.variable" title="LearningProjection.LearningProjection.variable"><strong>variable</strong></a> &#8211; (number) - value to be transformed by softMax function (default: 0)</td>
</tr>
<tr class="field-even field"><th class="field-name">Parameters:</th><td class="field-body"><strong>params</strong> &#8211; (dict) with entries specifying:
GAIN: number - gain (default: 1)
BIAS: number - rate (default: 0)</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return number:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="Function.SoftMax.derivative">
<code class="descname">derivative</code><span class="sig-paren">(</span><em>output</em>, <em>input=None</em><span class="sig-paren">)</span><a class="headerlink" href="#Function.SoftMax.derivative" title="Permalink to this definition">¶</a></dt>
<dd><p>Derivative of the softMax sigmoid function</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="Function.LinearMatrix">
<em class="property">class </em><code class="descclassname">Function.</code><code class="descname">LinearMatrix</code><span class="sig-paren">(</span><em>variable_default=[0], matrix: &lt;function matrix_spec at 0x10c218d08&gt; = None, params=None, prefs: &lt;function is_pref_set at 0x10bb56598&gt; = None, context='Linear Matrix INITIALIZING '</em><span class="sig-paren">)</span><a class="headerlink" href="#Function.LinearMatrix" title="Permalink to this definition">¶</a></dt>
<dd><p>Map sender vector to receiver vector using a linear weight matrix  (kwReceiver, MATRIX)</p>
<p>Use a weight matrix to convert a sender vector into a receiver vector:
- each row of the mapping corresponds to an element of the sender vector (outer index)
- each column of the mapping corresponds to an element of the receiver vector (inner index):</p>
<p>Initialization arguments:
- variable (2D np.ndarray containing exactly two sub-arrays:  sender and receiver vectors
- params (dict) specifying:</p>
<blockquote>
<div><ul class="simple">
<li>filler (kwFillerValue: number) value used to initialize all entries in matrix (default: 0)</li>
<li>identity (kwkwIdentityMapping: boolean): constructs identity matrix (default: <code class="xref std std-keyword docutils literal"><span class="pre">False</span></code>)</li>
</ul>
</div></blockquote>
<p>Create a matrix in self.matrix that is used in calls to LinearMatrix.function.</p>
<p>Returns sender 2D array linearly transformed by self.matrix</p>
<dl class="method">
<dt id="Function.LinearMatrix.instantiate_matrix">
<code class="descname">instantiate_matrix</code><span class="sig-paren">(</span><em>specification</em>, <em>context=None</em><span class="sig-paren">)</span><a class="headerlink" href="#Function.LinearMatrix.instantiate_matrix" title="Permalink to this definition">¶</a></dt>
<dd><p>Implements matrix indicated by specification</p>
<blockquote>
<div><p>Specification is derived from MATRIX param (passed to self.__init__ or self.function)</p>
<dl class="docutils">
<dt>Specification (validated in _validate_params):</dt>
<dd><ul class="first last simple">
<li>single number (used to fill self.matrix)</li>
<li>matrix keyword (see get_matrix)</li>
<li>2D list or np.ndarray of numbers</li>
</ul>
</dd>
</dl>
</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return matrix:</th><td class="field-body">(2D list)</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="Function.LinearMatrix.function">
<code class="descname">function</code><span class="sig-paren">(</span><em>variable=None</em>, <em>params=None</em>, <em>time_scale=&lt;TimeScale.TRIAL: 1&gt;</em>, <em>context=None</em><span class="sig-paren">)</span><a class="headerlink" href="#Function.LinearMatrix.function" title="Permalink to this definition">¶</a></dt>
<dd><p>Transforms variable vector using either self.matrix or specification in params</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Variables:</th><td class="field-body"><a class="reference internal" href="LearningProjection.html#LearningProjection.LearningProjection.variable" title="LearningProjection.LearningProjection.variable"><strong>variable</strong></a> &#8211; (list) - vector of numbers with length equal of height (number of rows, inner index) of matrix</td>
</tr>
<tr class="field-even field"><th class="field-name">Parameters:</th><td class="field-body"><strong>params</strong> &#8211; <p>(dict) with entries specifying:
MATRIX: value - used to override self.matrix implemented by __init__;  must be one of:</p>
<blockquote>
<div><ul>
<li><dl class="first docutils">
<dt>2D matrix - two-item list, each of which is a list of numbers with</dt>
<dd>length that matches the length of the vector in variable</dd>
</dl>
</li>
<li>kwIdentity - specifies use of identity matrix (dimensions of vector)</li>
<li>number - used to fill matrix of same dimensions as self.matrix</li>
</ul>
</div></blockquote>
</td>
</tr>
<tr class="field-odd field"><th class="field-name" colspan="2">Return list of numbers:</th></tr>
<tr class="field-odd field"><td>&nbsp;</td><td class="field-body">vector with length = width (number of columns, outer index) of matrix</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="Function.Integrator">
<em class="property">class </em><code class="descclassname">Function.</code><code class="descname">Integrator</code><span class="sig-paren">(</span><em>variable_default=None</em>, <em>rate: &lt;function parameter_spec at 0x10bb709d8&gt; = 1.0</em>, <em>weighting: &lt;typecheck.tc_predicates.enum object at 0x10c23ea58&gt; = 'constant'</em>, <em>params: &lt;typecheck.framework.optional object at 0x10c23e6d8&gt; = None</em>, <em>prefs: &lt;function is_pref_set at 0x10bb56598&gt; = None</em>, <em>noise=0.0</em>, <em>time_step_size=1.0</em>, <em>context='Integrator Init'</em><span class="sig-paren">)</span><a class="headerlink" href="#Function.Integrator" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate an accumulated and/or time-averaged value for input variable using a specified accumulation method</p>
<dl class="docutils">
<dt>Initialization arguments:</dt>
<dd><ul class="first last">
<li><p class="first">variable: new input value, to be combined with old value at rate and using method specified by params</p>
</li>
<li><dl class="first docutils">
<dt>params (dict): specifying:</dt>
<dd><ul class="first last">
<li><dl class="first docutils">
<dt>kwInitializer (value): initial value to which to set self.oldValue (default: variableClassDefault)</dt>
<dd><ul class="first simple">
<li>must be same type and format as variable</li>
<li>can be specified as a runtime parameter, which resets oldValue to one specified</li>
</ul>
<p class="last">Note: self.oldValue stores previous value with which new value is integrated</p>
</dd>
</dl>
</li>
<li><p class="first">RATE (value): rate of accumulation based on weighting of new vs. old value (default: 1)</p>
</li>
<li><dl class="first docutils">
<dt>WEIGHTING (Weightings Enum): method of accumulation (default: CONSTANT):</dt>
<dd><p class="first">CONSTANT &#8211; returns old_value incremented by rate parameter (ignores input) with optional noise
SIMPLE&nbsp;&#8211; returns old_value incremented by rate * new_value with optional noise
ADAPTIVE &#8211; returns rate-weighted average of old and new values  (Delta rule, Wiener filter) with optional noise</p>
<blockquote>
<div><p>rate = 0:  no change (returns old_value)
rate 1:    instantaneous change (returns new_value)</p>
</div></blockquote>
<p class="last">DIFFUSION &#8211; returns old_value incremented by drift_rate * old_value * time_step_size and the standard DDM noise distribution</p>
</dd>
</dl>
</li>
</ul>
</dd>
</dl>
</li>
</ul>
</dd>
</dl>
<p>Class attributes:
- oldValue (value): stores previous value with which value provided in variable is integrated</p>
<p>Integrator.function returns scalar result</p>
<dl class="method">
<dt id="Function.Integrator.function">
<code class="descname">function</code><span class="sig-paren">(</span><em>variable=None</em>, <em>params=None</em>, <em>time_scale=&lt;TimeScale.TRIAL: 1&gt;</em>, <em>context=None</em><span class="sig-paren">)</span><a class="headerlink" href="#Function.Integrator.function" title="Permalink to this definition">¶</a></dt>
<dd><p>Integrator function</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Variables:</th><td class="field-body"><a class="reference internal" href="LearningProjection.html#LearningProjection.LearningProjection.variable" title="LearningProjection.LearningProjection.variable"><strong>variable</strong></a> &#8211; (list) - old_value and new_value (default: [0, 0]:</td>
</tr>
<tr class="field-even field"><th class="field-name">Parameters:</th><td class="field-body"><strong>params</strong> &#8211; (dict) with entries specifying:
RATE: number - rate of accumulation as relative weighting of new vs. old value  (default = 1)
WEIGHTING: Integrator.Weightings - type of weighting (default = CONSTANT)</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return number:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="Function.BogaczEtAl">
<em class="property">class </em><code class="descclassname">Function.</code><code class="descname">BogaczEtAl</code><span class="sig-paren">(</span><em>variable_default=[[0]], drift_rate: &lt;function parameter_spec at 0x10bb709d8&gt; = 1.0, starting_point: &lt;function parameter_spec at 0x10bb709d8&gt; = 0.0, threshold: &lt;function parameter_spec at 0x10bb709d8&gt; = 1.0, noise: &lt;function parameter_spec at 0x10bb709d8&gt; = 0.5, t0: &lt;function parameter_spec at 0x10bb709d8&gt; = 0.2, params=None, prefs: &lt;function is_pref_set at 0x10bb56598&gt; = None, context='Integrator Init'</em><span class="sig-paren">)</span><a class="headerlink" href="#Function.BogaczEtAl" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute analytic solution to DDM process and return mean response time and accuracy.</p>
<dl class="docutils">
<dt>Description:</dt>
<dd><dl class="first last docutils">
<dt>generates mean response time (RT) and mean error rate (ER) as described in:</dt>
<dd>Bogacz, R., Brown, E., Moehlis, J., Holmes, P., &amp; Cohen, J. D. (2006). The physics of optimal
decision making: a formal analysis of models of performance in two-alternative forced-choice
tasks.  Psychological review, 113(4), 700. (<a class="reference external" href="https://www.ncbi.nlm.nih.gov/pubmed/17014301">PubMed entry</a>)</dd>
</dl>
</dd>
<dt>Initialization arguments:</dt>
<dd><p class="first">variable (float): set to self.value (== self.inputValue)
- params (dict):  runtime_params passed from Mechanism, used as one-time value for current execution:</p>
<blockquote>
<div><ul class="simple">
<li>drift_rate (DRIFT_RATE: float)</li>
<li>threshold (THRESHOLD: float)</li>
<li>bias (kwDDM_Bias: float)</li>
<li>noise (NOISE: float)</li>
<li>t0 (NON_DECISION_TIME: float)</li>
</ul>
</div></blockquote>
<ul class="simple">
<li>time_scale (TimeScale): specifies &#8220;temporal granularity&#8221; with which mechanism is executed</li>
<li>context (str)</li>
</ul>
<dl class="last docutils">
<dt>Returns the following values in self.value (2D np.array) and in</dt>
<dd>the value of the corresponding outputState in the self.outputStates dict:
- decision variable (float)
- mean error rate (float)
- mean RT (float)
- correct mean RT (float) - Navarro and Fuss only
- correct mean ER (float) - Navarro and Fuss only</dd>
</dl>
</dd>
</dl>
<dl class="method">
<dt id="Function.BogaczEtAl.function">
<code class="descname">function</code><span class="sig-paren">(</span><em>variable=None</em>, <em>params=None</em>, <em>time_scale=&lt;TimeScale.TRIAL: 1&gt;</em>, <em>context=None</em><span class="sig-paren">)</span><a class="headerlink" href="#Function.BogaczEtAl.function" title="Permalink to this definition">¶</a></dt>
<dd><p>DDM function</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Variables:</th><td class="field-body"><a class="reference internal" href="LearningProjection.html#LearningProjection.LearningProjection.variable" title="LearningProjection.LearningProjection.variable"><strong>variable</strong></a> &#8211; (list)</td>
</tr>
<tr class="field-even field"><th class="field-name">Parameters:</th><td class="field-body"><strong>params</strong> &#8211; (dict) with entries specifying:
drift_rate...</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="Function.NavarroAndFuss">
<em class="property">class </em><code class="descclassname">Function.</code><code class="descname">NavarroAndFuss</code><span class="sig-paren">(</span><em>variable_default=[[0]], drift_rate: &lt;function parameter_spec at 0x10bb709d8&gt; = 1.0, starting_point: &lt;function parameter_spec at 0x10bb709d8&gt; = 0.0, threshold: &lt;function parameter_spec at 0x10bb709d8&gt; = 1.0, noise: &lt;function parameter_spec at 0x10bb709d8&gt; = 0.5, t0: &lt;function parameter_spec at 0x10bb709d8&gt; = 0.2, params=None, prefs: &lt;function is_pref_set at 0x10bb56598&gt; = None, context='Integrator Init'</em><span class="sig-paren">)</span><a class="headerlink" href="#Function.NavarroAndFuss" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute analytic solution to distribution of DDM responses (mean and variance of response time and accuracy).</p>
<dl class="docutils">
<dt>Description:</dt>
<dd><dl class="first last docutils">
<dt>generates distributions of response time (RT) and error rate (ER) as described in:</dt>
<dd>Navarro, D. J., and Fuss, I. G. &#8220;Fast and accurate calculations for first-passage times in
Wiener diffusion models.&#8221; Journal of Mathematical Psychology 53.4 (2009): 222-230.
(<a class="reference external" href="http://www.sciencedirect.com/science/article/pii/S0022249609000200">ScienceDirect entry</a>)</dd>
</dl>
</dd>
<dt>Initialization arguments:</dt>
<dd><p class="first">variable (float): set to self.value (== self.inputValue)
- params (dict):  runtime_params passed from Mechanism, used as one-time value for current execution:</p>
<blockquote>
<div><ul class="simple">
<li>drift_rate (DRIFT_RATE: float)</li>
<li>threshold (THRESHOLD: float)</li>
<li>bias (kwDDM_Bias: float)</li>
<li>noise (NOISE: float)</li>
<li>t0 (NON_DECISION_TIME: float)</li>
</ul>
</div></blockquote>
<ul class="simple">
<li>time_scale (TimeScale): specifies &#8220;temporal granularity&#8221; with which mechanism is executed</li>
<li>context (str)</li>
</ul>
<dl class="last docutils">
<dt>Returns the following values in self.value (2D np.array) and in</dt>
<dd>the value of the corresponding outputState in the self.outputStates dict:
- decision variable (float)
- mean error rate (float)
- mean RT (float)
- correct mean RT (float) - Navarro and Fuss only
- correct mean ER (float) - Navarro and Fuss only</dd>
</dl>
</dd>
</dl>
<dl class="method">
<dt id="Function.NavarroAndFuss.function">
<code class="descname">function</code><span class="sig-paren">(</span><em>variable=None</em>, <em>params=None</em>, <em>time_scale=&lt;TimeScale.TRIAL: 1&gt;</em>, <em>context=None</em><span class="sig-paren">)</span><a class="headerlink" href="#Function.NavarroAndFuss.function" title="Permalink to this definition">¶</a></dt>
<dd><p>DDM function</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Variables:</th><td class="field-body"><a class="reference internal" href="LearningProjection.html#LearningProjection.LearningProjection.variable" title="LearningProjection.LearningProjection.variable"><strong>variable</strong></a> &#8211; (list)</td>
</tr>
<tr class="field-even field"><th class="field-name">Parameters:</th><td class="field-body"><strong>params</strong> &#8211; (dict) with entries specifying:
drift_rate...</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="Function.LearningFunction">
<em class="property">class </em><code class="descclassname">Function.</code><code class="descname">LearningFunction</code><span class="sig-paren">(</span><em>variable_default</em>, <em>params</em>, <em>name=None</em>, <em>prefs=None</em>, <em>context='Function_Base Init'</em><span class="sig-paren">)</span><a class="headerlink" href="#Function.LearningFunction" title="Permalink to this definition">¶</a></dt>
<dd><p>Abstract class of <a class="reference internal" href="#"><span class="doc">Functions</span></a> used for learning.</p>
<p>All LearningFunctions take three input values (specified in each of the three required items of the
<a class="reference internal" href="LearningProjection.html#LearningProjection.LearningProjection.variable" title="LearningProjection.LearningProjection.variable"><code class="xref any py py-attr docutils literal"><span class="pre">variable</span></code></a> argument), and return two output values.</p>
<dl class="docutils">
<dt>Input values:</dt>
<dd><ul class="first simple">
<li>input to the parameter being modified (variable[0];</li>
</ul>
<ul class="last simple">
<li>output of the parameter being modified (variable[1];</li>
<li>error associated with the output (variable[2]).</li>
</ul>
</dd>
<dt>Output values:</dt>
<dd><ul class="first last simple">
<li>learning_signal: modifications calculated by the function that attempt to reduce the error;</li>
<li>error_signal: the error received, possibly modified by the learning function.</li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="class">
<dt id="Function.Reinforcement">
<em class="property">class </em><code class="descclassname">Function.</code><code class="descname">Reinforcement</code><span class="sig-paren">(</span><em>variable_default=[[0], [0], [0]], activation_function: &lt;typecheck.tc_predicates.any object at 0x10c08e978&gt; = &lt;class 'Function.SoftMax'&gt;, learning_rate: &lt;typecheck.framework.optional object at 0x10c08e860&gt; = 1.0, params=None, prefs: &lt;function is_pref_set at 0x10bb56598&gt; = None, context='Component Init'</em><span class="sig-paren">)</span><a class="headerlink" href="#Function.Reinforcement" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate matrix of weight changes using the reinforcement (delta) learning rule</p>
<dl class="docutils">
<dt>Reinforcement learning rule</dt>
<dd>[matrix]         [scalar]        [col array]</dd>
<dt>delta_weight =  learning rate   *     error</dt>
<dd>return     =  LEARNING_RATE  *  self.variable</dd>
<dt>Reinforcement.function:</dt>
<dd><dl class="first docutils">
<dt>variable must be a 1D np.array with three items (standard for learning functions)</dt>
<dd>note: only the LEARNING_ACTIVATION_OUTPUT and LEARNING_ERROR_OUTPUT items are used by RL</dd>
<dt>assumes matrix to which errors are applied is the identity matrix</dt>
<dd>(i.e., set of &#8220;parallel&#8221; weights from input to output)</dd>
</dl>
<p class="last">LEARNING_RATE param must be a float
returns matrix of weight changes</p>
</dd>
<dt>Initialization arguments:</dt>
<dd><ul class="first last">
<li><p class="first">variable (list or np.array): must a single 1D np.array</p>
</li>
<li><dl class="first docutils">
<dt>params (dict): specifies</dt>
<dd><ul class="first last simple">
<li>LEARNING_RATE: (float) - learning rate (default: 1.0)</li>
</ul>
</dd>
</dl>
</li>
</ul>
</dd>
</dl>
<dl class="method">
<dt id="Function.Reinforcement.function">
<code class="descname">function</code><span class="sig-paren">(</span><em>variable=None</em>, <em>params=None</em>, <em>time_scale=&lt;TimeScale.TRIAL: 1&gt;</em>, <em>context=None</em><span class="sig-paren">)</span><a class="headerlink" href="#Function.Reinforcement.function" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate a matrix of weight changes from a single (scalar) error term</p>
<p>Assume output array has a single non-zero value chosen by the softmax function of the error_source
Assume error is a single scalar value
Assume weight matrix (for MappingProjection to error_source) is a diagonal matrix</p>
<blockquote>
<div>(one weight for corresponding pairs of elements in the input and output arrays)</div></blockquote>
<p>Adjust the weight corresponding to the chosen element of the output array, using error value and learning rate</p>
<dl class="docutils">
<dt>Note: assume variable is a 2D np.array with three items (input, output, error)</dt>
<dd>for compatibility with other learning functions (and calls from LearningProjection)</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Variables:</th><td class="field-body"><a class="reference internal" href="LearningProjection.html#LearningProjection.LearningProjection.variable" title="LearningProjection.LearningProjection.variable"><strong>variable</strong></a> &#8211; 2D np.array with three items (input array, output array, error array)</td>
</tr>
<tr class="field-even field"><th class="field-name">Parameters:</th><td class="field-body"><strong>params</strong> &#8211; (dict) with entry specifying:
LEARNING_RATE: (float) - (default: 1)</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return matrix:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="Function.BackPropagation">
<em class="property">class </em><code class="descclassname">Function.</code><code class="descname">BackPropagation</code><span class="sig-paren">(</span><em>variable_default=[[0], [0], [0]], activation_derivative_fct: &lt;typecheck.framework.optional object at 0x10c10d400&gt; = &lt;bound method Logistic.derivative of &lt;Function.Logistic object&gt;&gt;, error_derivative_fct: &lt;typecheck.framework.optional object at 0x10c10da20&gt; = &lt;bound method Logistic.derivative of &lt;Function.Logistic object&gt;&gt;, error_matrix=None, learning_rate: &lt;typecheck.framework.optional object at 0x10c10d588&gt; = 1.0, params=None, prefs: &lt;function is_pref_set at 0x10bb56598&gt; = None, context='Component Init'</em><span class="sig-paren">)</span><a class="headerlink" href="#Function.BackPropagation" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate matrix of weight changes using the backpropagation (Generalized Delta Rule) learning algorithm</p>
<dl class="docutils">
<dt>Backpropagation learning algorithm (Generalized Delta Rule):</dt>
<dd>[matrix]         [scalar]       [row array]              [row array/ col array]                 [col array]</dd>
<dt>delta_weight =  learning rate   *    input      *            d(output)/d(input)                 *     error</dt>
<dd>return     =  LEARNING_RATE  *  variable[0]  *  kwTransferFctDeriv(variable[1],variable[0])  *  variable[2]</dd>
<dt>BackPropagation.function:</dt>
<dd><dl class="first docutils">
<dt>variable must be a list or np.array with three items:</dt>
<dd><ul class="first last simple">
<li>input (e.g, array of activities of sender units)</li>
<li>output (array of activities of receiver units)</li>
<li>error (array of errors for receiver units)</li>
</ul>
</dd>
</dl>
<p class="last">LEARNING_RATE param must be a float
kwTransferFunctionDerivative param must be a function reference for dReceiver/dSender
returns matrix of weight changes</p>
</dd>
<dt>Initialization arguments:</dt>
<dd><ul class="first last">
<li><p class="first">variable (list or np.array): must have three 1D elements</p>
</li>
<li><dl class="first docutils">
<dt>params (dict): specifies</dt>
<dd><ul class="first last simple">
<li>LEARNING_RATE: (float) - learning rate (default: 1.0)</li>
<li>kwTransferFunctionDerivative - (function) derivative of TransferMechanism function (default: derivative of logistic)</li>
</ul>
</dd>
</dl>
</li>
</ul>
</dd>
</dl>
<dl class="class">
<dt id="Function.BackPropagation.MappingProjection">
<em class="property">class </em><code class="descname">MappingProjection</code><span class="sig-paren">(</span><em>sender=None</em>, <em>receiver=None</em>, <em>matrix=DEFAULT_MATRIX</em>, <em>param_modulation_operation=ModulationOperation.ADD</em>, <em>params=None</em>, <em>name=None</em>, <em>prefs=None</em><span class="sig-paren">)</span><a class="headerlink" href="#Function.BackPropagation.MappingProjection" title="Permalink to this definition">¶</a></dt>
<dd><p>Implements a projection that transmits the output of one mechanism to the input of another.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>sender</strong> (<em>Optional[OutputState or Mechanism]</em>) &#8211; specifies the source of the projection&#8217;s input. If a mechanism is specified, its
<a class="reference internal" href="OutputState.html#outputstate-primary"><span class="std std-ref">primary outputState</span></a> will be used. If it is not specified, it will be assigned in
the context in which the projection is used.</li>
<li><strong>receiver</strong> (<em>Optional[InputState or Mechanism]</em>) &#8211; specifies the destination of the projection&#8217;s output.  If a mechanism is specified, its
<a class="reference internal" href="Mechanism.html#mechanism-inputstates"><span class="std std-ref">primary inputState</span></a> will be used. If it is not specified, it will be assigned in
the context in which the projection is used.</li>
<li><strong>matrix</strong> (<em>list, np.ndarray, np.matrix, function or keyword : default DEFAULT_MATRIX</em>) &#8211; the matrix used by <code class="xref any docutils literal"><span class="pre">function</span></code> (default: <a class="reference internal" href="#Function.LinearCombination" title="Function.LinearCombination"><code class="xref any py py-class docutils literal"><span class="pre">LinearCombination</span></code></a>) to transform the
value of the <a class="reference internal" href="MappingProjection.html#MappingProjection.MappingProjection.sender" title="MappingProjection.MappingProjection.sender"><code class="xref any py py-attr docutils literal"><span class="pre">sender</span></code></a>.</li>
<li><strong>param_modulation_operation</strong> (<em>ModulationOperation : default ModulationOperation.ADD</em>) &#8211; specifies the operation used to combine the value of any projections to the matrix&#8217;s parameterState with the
<a class="reference internal" href="MappingProjection.html#MappingProjection.MappingProjection.matrix" title="MappingProjection.MappingProjection.matrix"><code class="xref any py py-attr docutils literal"><span class="pre">matrix</span></code></a> itself.  Most commonly used with <a class="reference internal" href="LearningProjection.html"><span class="doc">LearningProjections</span></a>.</li>
<li><strong>params</strong> (<em>Optional[Dict[param keyword, param value]]</em>) &#8211; a <a class="reference internal" href="ParameterState.html#parameterstate-specifying-parameters"><span class="std std-ref">parameter dictionary</span></a> that can be used to specify the parameters for
the projection, its function, and/or a custom function and its parameters. By default, it contains an entry for
the projection&#8217;s default assignment (<a class="reference internal" href="#Function.LinearCombination" title="Function.LinearCombination"><code class="xref any py py-class docutils literal"><span class="pre">LinearCombination</span></code></a>).  Values specified for parameters in the dictionary
override any assigned to those parameters in arguments of the constructor.</li>
<li><strong>name</strong> (<em>str : default MappingProjection-&lt;index&gt;</em>) &#8211; a string used for the name of the MappingProjection.
If not is specified, a default is assigned by <code class="xref any docutils literal"><span class="pre">ProjectionRegistry</span></code>
(see <code class="xref any docutils literal"><span class="pre">Registry</span></code> for conventions used in naming, including for default and duplicate names).</li>
<li><strong>prefs</strong> (<em>Optional[PreferenceSet or specification dict : Projection.classPreferences]</em>) &#8211; the <code class="xref any docutils literal"><span class="pre">PreferenceSet</span></code> for the MappingProjection.
If it is not specified, a default is assigned using <code class="xref any docutils literal"><span class="pre">classPreferences</span></code> defined in __init__.py
(see <code class="xref any docutils literal"><span class="pre">PreferenceSet</span></code> for details).</li>
</ul>
</td>
</tr>
</tbody>
</table>
<dl class="attribute">
<dt id="Function.BackPropagation.MappingProjection.componentType">
<code class="descname">componentType</code><a class="headerlink" href="#Function.BackPropagation.MappingProjection.componentType" title="Permalink to this definition">¶</a></dt>
<dd><p><em>MAPPING_PROJECTION</em></p>
</dd></dl>

<dl class="attribute">
<dt id="Function.BackPropagation.MappingProjection.sender">
<code class="descname">sender</code><a class="headerlink" href="#Function.BackPropagation.MappingProjection.sender" title="Permalink to this definition">¶</a></dt>
<dd><p><em>OutputState</em> &#8211; identifies the source of the projection&#8217;s input.</p>
</dd></dl>

<dl class="attribute">
<dt id="Function.BackPropagation.MappingProjection.receiver">
<code class="descname">receiver</code><a class="headerlink" href="#Function.BackPropagation.MappingProjection.receiver" title="Permalink to this definition">¶</a></dt>
<dd><p><em>InputState</em> &#8211; identifies the destination of the projection.</p>
</dd></dl>

<dl class="attribute">
<dt id="Function.BackPropagation.MappingProjection.param_modulation_operation">
<code class="descname">param_modulation_operation</code><a class="headerlink" href="#Function.BackPropagation.MappingProjection.param_modulation_operation" title="Permalink to this definition">¶</a></dt>
<dd><p><em>ModulationOperation</em> &#8211; determines the operation used to combine the value of any projections to the matrix&#8217;s parameterState with the
<a class="reference internal" href="MappingProjection.html#MappingProjection.MappingProjection.matrix" title="MappingProjection.MappingProjection.matrix"><code class="xref any py py-attr docutils literal"><span class="pre">matrix</span></code></a> itself.</p>
</dd></dl>

<dl class="attribute">
<dt id="Function.BackPropagation.MappingProjection.monitoringMechanism">
<code class="descname">monitoringMechanism</code><a class="headerlink" href="#Function.BackPropagation.MappingProjection.monitoringMechanism" title="Permalink to this definition">¶</a></dt>
<dd><p><em>MonitoringMechanism</em> &#8211; source of error signal for that determine changes to the <a class="reference internal" href="MappingProjection.html#MappingProjection.MappingProjection.matrix" title="MappingProjection.MappingProjection.matrix"><code class="xref any py py-attr docutils literal"><span class="pre">matrix</span></code></a> when
<a class="reference internal" href="LearningProjection.html"><span class="doc">learning</span></a> is used.</p>
</dd></dl>

<dl class="attribute">
<dt id="Function.BackPropagation.MappingProjection.matrix">
<code class="descname">matrix</code><a class="headerlink" href="#Function.BackPropagation.MappingProjection.matrix" title="Permalink to this definition">¶</a></dt>
<dd><p><em>2d np.array</em> &#8211; matrix used by <code class="xref any docutils literal"><span class="pre">function</span></code> to transform input from the
<a class="reference internal" href="MappingProjection.html#MappingProjection.MappingProjection.sender" title="MappingProjection.MappingProjection.sender"><code class="xref any py py-attr docutils literal"><span class="pre">sender</span></code></a> to the value provided to the <a class="reference internal" href="MappingProjection.html#MappingProjection.MappingProjection.receiver" title="MappingProjection.MappingProjection.receiver"><code class="xref any py py-attr docutils literal"><span class="pre">receiver</span></code></a>.</p>
</dd></dl>

<dl class="attribute">
<dt id="Function.BackPropagation.MappingProjection.has_learning_projection">
<code class="descname">has_learning_projection</code><a class="headerlink" href="#Function.BackPropagation.MappingProjection.has_learning_projection" title="Permalink to this definition">¶</a></dt>
<dd><p><em>bool : False</em> &#8211; identifies whether the MappingProjection&#8217;s <code class="xref any docutils literal"><span class="pre">MATRIX</span></code> <a class="reference internal" href="ParameterState.html"><span class="doc">parameterState</span></a> has been assigned a
<a class="reference internal" href="LearningProjection.html"><span class="doc">LearningProjection</span></a>.</p>
</dd></dl>

<dl class="attribute">
<dt id="Function.BackPropagation.MappingProjection.name">
<code class="descname">name</code><a class="headerlink" href="#Function.BackPropagation.MappingProjection.name" title="Permalink to this definition">¶</a></dt>
<dd><p><em>str : default MappingProjection-&lt;index&gt;</em> &#8211; the name of the MappingProjection.
Specified in the <a class="reference internal" href="#Function.BackPropagation.MappingProjection.name" title="Function.BackPropagation.MappingProjection.name"><code class="xref any py py-attr docutils literal"><span class="pre">name</span></code></a> argument of the constructor for the projection;
if not is specified, a default is assigned by ProjectionRegistry
(see <span class="xref doc">Registry</span> for conventions used in naming, including for default and duplicate names).</p>
</dd></dl>

<dl class="attribute">
<dt id="Function.BackPropagation.MappingProjection.prefs">
<code class="descname">prefs</code><a class="headerlink" href="#Function.BackPropagation.MappingProjection.prefs" title="Permalink to this definition">¶</a></dt>
<dd><p><em>PreferenceSet or specification dict : Projection.classPreferences</em> &#8211; the <code class="xref any docutils literal"><span class="pre">PreferenceSet</span></code> for projection.
Specified in the <a class="reference internal" href="#Function.BackPropagation.MappingProjection.prefs" title="Function.BackPropagation.MappingProjection.prefs"><code class="xref any py py-attr docutils literal"><span class="pre">prefs</span></code></a> argument of the constructor for the projection;
if it is not specified, a default is assigned using <code class="xref any docutils literal"><span class="pre">classPreferences</span></code> defined in __init__.py
(see <span class="xref doc">PreferenceSet</span> for details).</p>
</dd></dl>

<dl class="method">
<dt id="Function.BackPropagation.MappingProjection.execute">
<code class="descname">execute</code><span class="sig-paren">(</span><em>input=None</em>, <em>clock=&lt;PsyNeuLink.Globals.TimeScale.Clock object&gt;</em>, <em>time_scale=None</em>, <em>params=None</em>, <em>context=None</em><span class="sig-paren">)</span><a class="headerlink" href="#Function.BackPropagation.MappingProjection.execute" title="Permalink to this definition">¶</a></dt>
<dd><dl class="docutils">
<dt>If there is a functionParameterStates[LEARNING_PROJECTION], update the matrix parameterState:</dt>
<dd><blockquote class="first">
<div>it should set params[PARAMETER_STATE_PARAMS] = {kwLinearCombinationOperation:SUM (OR ADD??)}
and then call its super().execute</div></blockquote>
<ul class="last simple">
<li>use its value to update MATRIX using CombinationOperation (see State update ??execute method??)</li>
</ul>
</dd>
</dl>
<p>Assumes that if self.monitoringMechanism is assigned <em>and</em> parameterState[MATRIX] has been instantiated
then learningSignal exists;  this averts duck typing which otherwise would be required for the most
frequent cases (i.e., <em>no</em> learningSignal).</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="Function.BackPropagation.ParameterState">
<em class="property">class </em><code class="descclassname">BackPropagation.</code><code class="descname">ParameterState</code><span class="sig-paren">(</span><em>owner</em>, <em>reference_value=None                                             value=None</em>, <em>function=LinearCombination(operation=PRODUCT)</em>, <em>parameter_modulation_operation=ModulationOperation.MULTIPLY</em>, <em>params=None</em>, <em>name=None</em>, <em>prefs=None</em><span class="sig-paren">)</span><a class="headerlink" href="#Function.BackPropagation.ParameterState" title="Permalink to this definition">¶</a></dt>
<dd><p>Implements a subclass of <a class="reference internal" href="State.html"><span class="doc">States</span></a> that represents and possibly modifies the value of a parameter for a mechanism,
projection, or function.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>owner</strong> (<em>Mechanism or Projection</em>) &#8211; the <a class="reference internal" href="Mechanism.html"><span class="doc">mechanism</span></a> or <a class="reference internal" href="Projection.html"><span class="doc">projection</span></a> to which to which the parameterState belongs; it must
be specified or determinable from the context in which the parameterState is created. The owner of a
parameterState for the parameter of a <code class="xref std std-keyword docutils literal"><span class="pre">function</span></code> should be specified as the mechanism or projection
to which the function belongs.</li>
<li><strong>reference_value</strong> (<em>number, list or np.ndarray</em>) &#8211; specifies the default value of the parameter for which the parameterState is responsible.</li>
<li><strong>value</strong> (<em>number, list or np.ndarray</em>) &#8211; specifies the template for the parametersState&#8217;s <a class="reference internal" href="#Function.BackPropagation.ParameterState.variable" title="Function.BackPropagation.ParameterState.variable"><code class="xref any py py-attr docutils literal"><span class="pre">variable</span></code></a> (since a parameterState&#8217;s
<a class="reference internal" href="#Function.BackPropagation.ParameterState.variable" title="Function.BackPropagation.ParameterState.variable"><code class="xref any py py-attr docutils literal"><span class="pre">variable</span></code></a> and <a class="reference internal" href="ParameterState.html#ParameterState.ParameterState.value" title="ParameterState.ParameterState.value"><code class="xref any py py-attr docutils literal"><span class="pre">value</span></code></a> attributes must have the same format
(number and type of elements).</li>
<li><strong>function</strong> (<em>Function or method : default LinearCombination(operation=SUM)</em>) &#8211; specifies the function used to aggregate the values of the projections received by the parameterState.
It must produce a result that has the same format (number and type of elements) as its input.</li>
<li><strong>parameter_modulation_operation</strong> (<em>ModulationOperation : default ModulationOperation.MULTIPLY</em>) &#8211; specifies the operation by which the values of the projections received by the parameterState are used
to modify its <a class="reference internal" href="ParameterState.html#ParameterState.ParameterState.baseValue" title="ParameterState.ParameterState.baseValue"><code class="xref any py py-attr docutils literal"><span class="pre">baseValue</span></code></a> before assigning it as the value of the parameter for
which the parameterState is responsible.</li>
<li><strong>params</strong> (<em>Optional[Dict[param keyword, param value]]</em>) &#8211; a <a class="reference internal" href="ParameterState.html#parameterstate-specifying-parameters"><span class="std std-ref">parameter dictionary</span></a> that can be used to specify the parameters for
the parameterState or its function, and/or a custom function and its parameters.  Values specified for
parameters in the dictionary override any assigned to those parameters in arguments of the constructor.</li>
<li><strong>name</strong> (<em>str : default InputState-&lt;index&gt;</em>) &#8211; a string used for the name of the inputState.
If not is specified, a default is assigned by StateRegistry of the mechanism to which the inputState belongs
(see <span class="xref doc">Registry</span> for conventions used in naming, including for default and duplicate names).</li>
<li><strong>prefs</strong> (<em>Optional[PreferenceSet or specification dict : State.classPreferences]</em>) &#8211; the <code class="xref any docutils literal"><span class="pre">PreferenceSet</span></code> for the inputState.
If it is not specified, a default is assigned using <code class="xref any docutils literal"><span class="pre">classPreferences</span></code> defined in __init__.py
(see <span class="xref doc">PreferenceSet</span> for details).</li>
</ul>
</td>
</tr>
</tbody>
</table>
<dl class="attribute">
<dt id="Function.BackPropagation.ParameterState.owner">
<code class="descname">owner</code><a class="headerlink" href="#Function.BackPropagation.ParameterState.owner" title="Permalink to this definition">¶</a></dt>
<dd><p><em>Mechanism</em> &#8211; the mechanism to which the parameterState belongs.</p>
</dd></dl>

<dl class="attribute">
<dt id="Function.BackPropagation.ParameterState.receivesFromProjections">
<code class="descname">receivesFromProjections</code><a class="headerlink" href="#Function.BackPropagation.ParameterState.receivesFromProjections" title="Permalink to this definition">¶</a></dt>
<dd><p><em>Optional[List[Projection]]</em> &#8211; a list of the projections received by the parameterState (i.e., for which it is a
<code class="xref any docutils literal"><span class="pre">receiver</span></code>); generally these are <a class="reference internal" href="ControlProjection.html"><span class="doc">ControlProjection(s)</span></a>
and/or <a class="reference internal" href="LearningProjection.html"><span class="doc">LearningProjection(s)</span></a>.</p>
</dd></dl>

<dl class="attribute">
<dt id="Function.BackPropagation.ParameterState.variable">
<code class="descname">variable</code><a class="headerlink" href="#Function.BackPropagation.ParameterState.variable" title="Permalink to this definition">¶</a></dt>
<dd><p><em>number, list or np.ndarray</em> &#8211; the template for the <code class="xref any docutils literal"><span class="pre">value</span></code> of each projection that the parameterState receives,
each of which must match the format (number and types of elements) of the parameterState&#8217;s <code class="xref std std-keyword docutils literal"><span class="pre">variable</span></code>.</p>
</dd></dl>

<dl class="attribute">
<dt id="Function.BackPropagation.ParameterState.function">
<code class="descname">function</code><a class="headerlink" href="#Function.BackPropagation.ParameterState.function" title="Permalink to this definition">¶</a></dt>
<dd><p><em>CombinationFunction : default LinearCombination(operation=PRODUCT))</em> &#8211; performs an element-wise (Hadamard) aggregation  of the <code class="xref any docutils literal"><span class="pre">value</span></code> of each
projection received by the parameterState.</p>
</dd></dl>

<dl class="attribute">
<dt id="Function.BackPropagation.ParameterState.baseValue">
<code class="descname">baseValue</code><a class="headerlink" href="#Function.BackPropagation.ParameterState.baseValue" title="Permalink to this definition">¶</a></dt>
<dd><p><em>number, list or np.ndarray</em> &#8211; the default value for the parameterState.  It is combined with the aggregated value of any projections it
receives using its <a class="reference internal" href="ParameterState.html#ParameterState.ParameterState.parameterModulationOperation" title="ParameterState.ParameterState.parameterModulationOperation"><code class="xref any py py-attr docutils literal"><span class="pre">parameterModulationOperation</span></code></a>
and then assigned to <a class="reference internal" href="ParameterState.html#ParameterState.ParameterState.value" title="ParameterState.ParameterState.value"><code class="xref any py py-attr docutils literal"><span class="pre">value</span></code></a>.</p>
</dd></dl>

<dl class="attribute">
<dt id="Function.BackPropagation.ParameterState.parameterModulationOperation">
<code class="descname">parameterModulationOperation</code><a class="headerlink" href="#Function.BackPropagation.ParameterState.parameterModulationOperation" title="Permalink to this definition">¶</a></dt>
<dd><p><em>ModulationOperation : default ModulationOperation.PRODUCT</em> &#8211; the arithmetic operation used to combine the aggregated value of any projections is receives
(the result of the parameterState&#8217;s <a class="reference internal" href="#Function.BackPropagation.ParameterState.function" title="Function.BackPropagation.ParameterState.function"><code class="xref any py py-attr docutils literal"><span class="pre">function</span></code></a>) with its
<a class="reference internal" href="ParameterState.html#ParameterState.ParameterState.baseValue" title="ParameterState.ParameterState.baseValue"><code class="xref any py py-attr docutils literal"><span class="pre">baseValue</span></code></a>, the result of which is assigned to <a class="reference internal" href="ParameterState.html#ParameterState.ParameterState.value" title="ParameterState.ParameterState.value"><code class="xref any py py-attr docutils literal"><span class="pre">value</span></code></a>.</p>
</dd></dl>

<dl class="attribute">
<dt id="Function.BackPropagation.ParameterState.value">
<code class="descname">value</code><a class="headerlink" href="#Function.BackPropagation.ParameterState.value" title="Permalink to this definition">¶</a></dt>
<dd><p><em>number, list or np.ndarray</em> &#8211; the aggregated value of the projections received by the ParameterState, combined with the
<a class="reference internal" href="ParameterState.html#ParameterState.ParameterState.baseValue" title="ParameterState.ParameterState.baseValue"><code class="xref any py py-attr docutils literal"><span class="pre">baseValue</span></code></a> using its
<a class="reference internal" href="ParameterState.html#ParameterState.ParameterState.parameterModulationOperation" title="ParameterState.ParameterState.parameterModulationOperation"><code class="xref any py py-attr docutils literal"><span class="pre">parameterModulationOperation</span></code></a>
.  This is the value assigned to the parameter for which the parameterState is responsible.</p>
</dd></dl>

<dl class="attribute">
<dt id="Function.BackPropagation.ParameterState.name">
<code class="descname">name</code><a class="headerlink" href="#Function.BackPropagation.ParameterState.name" title="Permalink to this definition">¶</a></dt>
<dd><p><em>str : default &lt;State subclass&gt;-&lt;index&gt;</em> &#8211; the name of the inputState.
Specified in the <a class="reference internal" href="#Function.BackPropagation.ParameterState.name" title="Function.BackPropagation.ParameterState.name"><code class="xref any py py-attr docutils literal"><span class="pre">name</span></code></a> argument of the constructor for the outputState.  If not is specified, a default is
assigned by the StateRegistry of the mechanism to which the outputState belongs
(see <span class="xref doc">Registry</span> for conventions used in naming, including for default and duplicate names).</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Unlike other PsyNeuLink components, states names are &#8220;scoped&#8221; within a mechanism, meaning that states with
the same name are permitted in different mechanisms.  However, they are <em>not</em> permitted in the same
mechanism: states within a mechanism with the same base name are appended an index in the order of their
creation.</p>
</div>
</dd></dl>

<dl class="attribute">
<dt id="Function.BackPropagation.ParameterState.prefs">
<code class="descname">prefs</code><a class="headerlink" href="#Function.BackPropagation.ParameterState.prefs" title="Permalink to this definition">¶</a></dt>
<dd><p><em>PreferenceSet or specification dict : State.classPreferences</em> &#8211; the <code class="xref any docutils literal"><span class="pre">PreferenceSet</span></code> for the inputState.
Specified in the <a class="reference internal" href="#Function.BackPropagation.ParameterState.prefs" title="Function.BackPropagation.ParameterState.prefs"><code class="xref any py py-attr docutils literal"><span class="pre">prefs</span></code></a> argument of the constructor for the projection;  if it is not specified, a default is
assigned using <code class="xref any docutils literal"><span class="pre">classPreferences</span></code> defined in __init__.py
(see <span class="xref doc">PreferenceSet</span> for details).</p>
</dd></dl>

<dl class="method">
<dt id="Function.BackPropagation.ParameterState.update">
<code class="descname">update</code><span class="sig-paren">(</span><em>params=None</em>, <em>time_scale=&lt;TimeScale.TRIAL: 1&gt;</em>, <em>context=None</em><span class="sig-paren">)</span><a class="headerlink" href="#Function.BackPropagation.ParameterState.update" title="Permalink to this definition">¶</a></dt>
<dd><p>Parse params for parameterState params and XXX <a href="#id1"><span class="problematic" id="id2">**</span></a><a href="#id3"><span class="problematic" id="id4">*</span></a></p>
<dl class="docutils">
<dt># DOCUMENTATION:  MORE HERE:</dt>
<dd><ul class="first simple">
<li>get ParameterStateParams</li>
<li>pass params to super, which aggregates inputs from projections</li>
<li>combine input from projections (processed in super) with baseValue using paramModulationOperation</li>
<li>combine result with value specified at runtime in PARAMETER_STATE_PARAMS</li>
<li>assign result to self.value</li>
</ul>
<table class="last docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">param params:</th><td class="field-body"></td>
</tr>
<tr class="field-even field"><th class="field-name" colspan="2">param time_scale:</th></tr>
<tr class="field-even field"><td>&nbsp;</td><td class="field-body"></td>
</tr>
<tr class="field-odd field"><th class="field-name">param context:</th><td class="field-body"></td>
</tr>
<tr class="field-even field"><th class="field-name">return:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="method">
<dt id="Function.BackPropagation.function">
<code class="descclassname">BackPropagation.</code><code class="descname">function</code><span class="sig-paren">(</span><em>variable=None</em>, <em>params=None</em>, <em>time_scale=&lt;TimeScale.TRIAL: 1&gt;</em>, <em>context=None</em><span class="sig-paren">)</span><a class="headerlink" href="#Function.BackPropagation.function" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate and return a matrix of weight changes from an array of inputs, outputs and error terms</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Variables:</th><td class="field-body"><a class="reference internal" href="LearningProjection.html#LearningProjection.LearningProjection.variable" title="LearningProjection.LearningProjection.variable"><strong>variable</strong></a> &#8211; (list or np.array) len = 3 (input, output, error)</td>
</tr>
<tr class="field-even field"><th class="field-name">Parameters:</th><td class="field-body"><strong>params</strong> &#8211; <p>(dict) with entries specifying:
LEARNING_RATE: (float) - (default: 1)
kwTransferFunctionDerivative (function) - derivative of function that generated values</p>
<blockquote>
<div>(default: derivative of logistic function)</div></blockquote>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return number:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

</div>


           </div>
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="Run.html" class="btn btn-neutral float-right" title="Run" accesskey="n">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="MappingProjection.html" class="btn btn-neutral" title="MappingProjection" accesskey="p"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2016, Jonathan D. Cohen.

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'./',
            VERSION:'0.1',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true
        };
    </script>
      <script type="text/javascript" src="_static/jquery.js"></script>
      <script type="text/javascript" src="_static/underscore.js"></script>
      <script type="text/javascript" src="_static/doctools.js"></script>

  

  
  
    <script type="text/javascript" src="_static/js/theme.js"></script>
  

  
  
  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.StickyNav.enable();
      });
  </script>
   

</body>
</html>