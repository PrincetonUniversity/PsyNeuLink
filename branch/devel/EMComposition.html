


<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  <meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>EMComposition &mdash; PsyNeuLink 0.15.2.0+42.gcd06c82ae documentation</title>
  

  
  
  
  

  

  
  
    

  

  <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  <!-- <link rel="stylesheet" href="_static/pygments.css" type="text/css" /> -->
  <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="_static/css/custom.css" type="text/css" />
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Subsystems" href="Subystems.html" />
    <link rel="prev" title="ParameterEstimationComposition" href="ParameterEstimationComposition.html" /> 

  
  <script src="_static/js/modernizr.min.js"></script>

  <!-- Preload the theme fonts -->

<link rel="preload" href="_static/fonts/FreightSans/freight-sans-book.woff2" as="font" type="font/woff2" crossorigin="anonymous">
<link rel="preload" href="_static/fonts/FreightSans/freight-sans-medium.woff2" as="font" type="font/woff2" crossorigin="anonymous">
<link rel="preload" href="_static/fonts/IBMPlexMono/IBMPlexMono-Medium.woff2" as="font" type="font/woff2" crossorigin="anonymous">
<link rel="preload" href="_static/fonts/FreightSans/freight-sans-bold.woff2" as="font" type="font/woff2" crossorigin="anonymous">
<link rel="preload" href="_static/fonts/FreightSans/freight-sans-medium-italic.woff2" as="font" type="font/woff2" crossorigin="anonymous">
<link rel="preload" href="_static/fonts/IBMPlexMono/IBMPlexMono-SemiBold.woff2" as="font" type="font/woff2" crossorigin="anonymous">

<!-- Preload the katex fonts -->

<link rel="preload" href="https://cdn.jsdelivr.net/npm/katex@0.10.0/dist/fonts/KaTeX_Math-Italic.woff2" as="font" type="font/woff2" crossorigin="anonymous">
<link rel="preload" href="https://cdn.jsdelivr.net/npm/katex@0.10.0/dist/fonts/KaTeX_Main-Regular.woff2" as="font" type="font/woff2" crossorigin="anonymous">
<link rel="preload" href="https://cdn.jsdelivr.net/npm/katex@0.10.0/dist/fonts/KaTeX_Main-Bold.woff2" as="font" type="font/woff2" crossorigin="anonymous">
<link rel="preload" href="https://cdn.jsdelivr.net/npm/katex@0.10.0/dist/fonts/KaTeX_Size1-Regular.woff2" as="font" type="font/woff2" crossorigin="anonymous">
<link rel="preload" href="https://cdn.jsdelivr.net/npm/katex@0.10.0/dist/fonts/KaTeX_Size4-Regular.woff2" as="font" type="font/woff2" crossorigin="anonymous">
<link rel="preload" href="https://cdn.jsdelivr.net/npm/katex@0.10.0/dist/fonts/KaTeX_Size2-Regular.woff2" as="font" type="font/woff2" crossorigin="anonymous">
<link rel="preload" href="https://cdn.jsdelivr.net/npm/katex@0.10.0/dist/fonts/KaTeX_Size3-Regular.woff2" as="font" type="font/woff2" crossorigin="anonymous">
<link rel="preload" href="https://cdn.jsdelivr.net/npm/katex@0.10.0/dist/fonts/KaTeX_Caligraphic-Regular.woff2" as="font" type="font/woff2" crossorigin="anonymous">
</head>

<div class="container-fluid header-holder tutorials-header" id="header-holder">
  <div class="container">
    <div class="header-container">
      <a class="header-logo" href="https://princetonuniversity.github.io/PsyNeuLink/"></a>
<!--      <a class="header-logo"></a>-->
      <div class="main-menu">
        <ul>
          <li>
            <a href="https://github.com/PrincetonUniversity/PsyNeuLink">Github</a>
          </li>
        </ul>
      </div>

      <a class="main-menu-open-button" href="#" data-behavior="open-mobile-menu"></a>
    </div>

  </div>
</div>


<body class="psyneulink-body">

   

    

    <div class="table-of-contents-link-wrapper">
      <span>Table of Contents</span>
      <a href="#" class="toggle-table-of-contents" data-behavior="toggle-table-of-contents"></a>
    </div>

    <nav data-toggle="wy-nav-shift" class="psyneulink-left-menu" id="psyneulink-left-menu">
      <div class="psyneulink-side-scroll">
        <div class="psyneulink-menu psyneulink-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          <div class="psyneulink-left-menu-search">
            

            
              
              
                <div class="version">
                  0.15.2.0+42
                </div>
              
            

            


  


<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search Docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

            
          </div>
          
            
            
              
            
            
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="index.html">Welcome to PsyNeuLink </a></li>
<li class="toctree-l1"><a class="reference internal" href="BasicsAndPrimer.html">Basics and Primer</a></li>
<li class="toctree-l1"><a class="reference internal" href="QuickReference.html">Quick Reference</a></li>
<li class="toctree-l1"><a class="reference internal" href="Core.html">Core</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="Library.html">Library</a></li>
<li class="toctree-l1"><a class="reference internal" href="ContributorsGuide.html">Contributors Guide</a></li>
</ul>

            
          
          <div class="psyneulink-dev-mode-toggle">
          </div>
        </div>
      </div>
    </nav>
    <div class="psyneulink-container">
      <div class="psyneulink-page-level-bar" id="psyneulink-page-level-bar">
        <div class="psyneulink-breadcrumbs-wrapper">
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="psyneulink-breadcrumbs">
    
      <li>
        <a href="index.html">
          
            Docs
          
        </a> &gt;
      </li>

        
          <li><a href="Library.html">Library</a> &gt;</li>
        
          <li><a href="Compositions.html">Compositions</a> &gt;</li>
        
      <li>EMComposition</li>
    
  </ul>

  
</div>
        </div>

        <div class="psyneulink-shortcuts-wrapper" id="psyneulink-shortcuts-wrapper">
          Shortcuts
        </div>
      </div>

      <section data-toggle="wy-nav-shift" id="psyneulink-content-wrap" class="psyneulink-content-wrap">
        <div class="psyneulink-content-left">

        
          
          <div class="rst-content">
          
            <div role="main" class="main-content" itemscope="itemscope" itemtype="http://schema.org/Article">
             <article itemprop="articleBody" id="psyneulink-article" class="psyneulink-article">
              
  <section id="emcomposition">
<h1>EMComposition<a class="headerlink" href="#emcomposition" title="Permalink to this headline">¶</a></h1>
<div class="related docutils container">
<p><em>Related</em></p>
<ul class="simple">
<li><p><a class="reference internal" href="AutodiffComposition.html"><span class="doc">AutodiffComposition</span></a></p></li>
<li><p><a class="reference internal" href="Composition.html#composition-learning"><span class="std std-ref">Learning in a Composition</span></a></p></li>
<li><p><a class="reference internal" href="EpisodicMemoryMechanism.html"><span class="doc">EpisodicMemoryMechanism</span></a></p></li>
<li><p><a class="reference internal" href="MemoryFunctions.html#psyneulink.core.components.functions.stateful.memoryfunctions.ContentAddressableMemory" title="psyneulink.core.components.functions.stateful.memoryfunctions.ContentAddressableMemory"><code class="xref any py py-class docutils literal notranslate"><span class="pre">ContentAddressableMemory</span></code></a></p></li>
</ul>
</div>
<span class="target" id="module-psyneulink.library.compositions.emcomposition"></span><section id="contents">
<h2>Contents<a class="headerlink" href="#contents" title="Permalink to this headline">¶</a></h2>
<blockquote>
<div><ul class="simple">
<li><dl class="simple">
<dt><a class="reference internal" href="#emcomposition-overview"><span class="std std-ref">Overview</span></a></dt><dd><ul>
<li><p><a class="reference internal" href="#emcomposition-organization"><span class="std std-ref">Organization</span></a></p></li>
<li><p><a class="reference internal" href="#emcomposition-operation"><span class="std std-ref">Operation</span></a></p></li>
</ul>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><a class="reference internal" href="#emcomposition-creation"><span class="std std-ref">Creation</span></a></dt><dd><ul>
<li><p><a class="reference internal" href="#emcomposition-memory-specification"><span class="std std-ref">Memory</span></a></p></li>
<li><p><a class="reference internal" href="#emcomposition-memory-capacity"><span class="std std-ref">Capacity</span></a></p></li>
<li><p><a class="reference internal" href="#emcomposition-fields"><span class="std std-ref">Fields</span></a></p></li>
<li><p><a class="reference internal" href="#emcomposition-retrieval-storage"><span class="std std-ref">Storage and Retrieval</span></a></p></li>
<li><p><a class="reference internal" href="#emcomposition-learning"><span class="std std-ref">Learning</span></a></p></li>
</ul>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><a class="reference internal" href="#emcomposition-structure"><span class="std std-ref">Structure</span></a></dt><dd><ul>
<li><p><a class="reference internal" href="#emcomposition-input"><span class="std std-ref">Input</span></a></p></li>
<li><p><a class="reference internal" href="#emcomposition-memory-structure"><span class="std std-ref">Memory</span></a></p></li>
<li><p><a class="reference internal" href="#emcomposition-output"><span class="std std-ref">Output</span></a></p></li>
</ul>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><a class="reference internal" href="#emcomposition-execution"><span class="std std-ref">Execution</span></a></dt><dd><ul>
<li><p><a class="reference internal" href="#emcomposition-processing"><span class="std std-ref">Processing</span></a></p></li>
<li><p><a class="reference internal" href="#emcomposition-training"><span class="std std-ref">Learning</span></a></p></li>
</ul>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><a class="reference internal" href="#emcomposition-examples"><span class="std std-ref">Examples</span></a></dt><dd><ul>
<li><p><a class="reference internal" href="#emcomposition-example-memory-template"><span class="std std-ref">Memory Template and Fill</span></a></p></li>
<li><p><a class="reference internal" href="#emcomposition-example-field-weights"><span class="std std-ref">Field Weights</span></a></p></li>
</ul>
</dd>
</dl>
</li>
<li><p><a class="reference internal" href="#emcomposition-class-reference"><span class="std std-ref">Class Reference</span></a></p></li>
</ul>
</div></blockquote>
</section>
<section id="overview">
<span id="emcomposition-overview"></span><h2>Overview<a class="headerlink" href="#overview" title="Permalink to this headline">¶</a></h2>
<p>The EMComposition implements a configurable, content-addressable form of episodic (or external) memory. It emulates
an <a class="reference internal" href="EpisodicMemoryMechanism.html"><span class="doc">EpisodicMemoryMechanism</span></a> – reproducing all of the functionality of its <a class="reference internal" href="MemoryFunctions.html#psyneulink.core.components.functions.stateful.memoryfunctions.ContentAddressableMemory" title="psyneulink.core.components.functions.stateful.memoryfunctions.ContentAddressableMemory"><code class="xref any py py-class docutils literal notranslate"><span class="pre">ContentAddressableMemory</span></code></a> <a class="reference internal" href="Function.html"><span class="doc">Function</span></a> –
in the form of an <a class="reference internal" href="AutodiffComposition.html"><span class="doc">AutodiffComposition</span></a>. This allows it to backpropagate error signals based retrieved values to
it inputs, and learn how to differentially weight cues (queries) used for retrieval. It also adds the capability for
<a class="reference internal" href="#psyneulink.library.compositions.emcomposition.EMComposition.memory_decay_rate" title="psyneulink.library.compositions.emcomposition.EMComposition.memory_decay_rate"><code class="xref any py py-attr docutils literal notranslate"><span class="pre">memory_decay</span></code></a>. In these respects, it implements a variant of a <a class="reference external" href="https://en.wikipedia.org/wiki/Modern_Hopfield_network">Modern Hopfield
Network</a>, as well as some of the features of a <a class="reference external" href="https://en.wikipedia.org/wiki/Transformer_(deep_learning_architecture)">Transformer</a></p>
<p>The <a class="reference internal" href="#psyneulink.library.compositions.emcomposition.EMComposition.memory" title="psyneulink.library.compositions.emcomposition.EMComposition.memory"><code class="xref any py py-attr docutils literal notranslate"><span class="pre">memory</span></code></a> of an EMComposition is configured using two arguments of its constructor:
the <strong>memory_template</strong> argument, that defines the overall structure of its <a class="reference internal" href="#psyneulink.library.compositions.emcomposition.EMComposition.memory" title="psyneulink.library.compositions.emcomposition.EMComposition.memory"><code class="xref any py py-attr docutils literal notranslate"><span class="pre">memory</span></code></a> (the
number of fields in each entry, the length of each field, and the number of entries); and <strong>fields</strong> argument, that
defines which fields are used as cues for retrieval (i.e., as “keys”), including whether and how they are weighted in
the match process used for retrieval, which fields are treated as “values” that are stored retrieved but not used by
the match process, and which are involved in learning. The inputs to an EMComposition, corresponding to its keys and
values, are assigned to each of its <a class="reference internal" href="Composition.html#psyneulink.core.compositions.composition.NodeRole.INPUT" title="psyneulink.core.compositions.composition.NodeRole.INPUT"><code class="xref any py py-attr docutils literal notranslate"><span class="pre">INPUT</span></code></a> <a class="reference internal" href="Composition.html#composition-nodes"><span class="std std-ref">Nodes</span></a>: inputs to be matched to keys
(i.e., used as “queries”) are assigned to its <a class="reference internal" href="#psyneulink.library.compositions.emcomposition.EMComposition.query_input_nodes" title="psyneulink.library.compositions.emcomposition.EMComposition.query_input_nodes"><code class="xref any py py-attr docutils literal notranslate"><span class="pre">query_input_nodes</span></code></a>; and the remaining
inputs assigned to it <a class="reference internal" href="#psyneulink.library.compositions.emcomposition.EMComposition.value_input_nodes" title="psyneulink.library.compositions.emcomposition.EMComposition.value_input_nodes"><code class="xref any py py-attr docutils literal notranslate"><span class="pre">value_input_nodes</span></code></a>. When the EMComposition is executed, the
retrieved values for all fields are returned as the result, and recorded in its <code class="xref any docutils literal notranslate"><span class="pre">results</span></code>
attribute. The value for each field is assigned as the <a class="reference internal" href="OutputPort.html#psyneulink.core.components.ports.outputport.OutputPort.value" title="psyneulink.core.components.ports.outputport.OutputPort.value"><code class="xref any py py-attr docutils literal notranslate"><span class="pre">value</span></code></a> of its <a class="reference internal" href="Composition.html#psyneulink.core.compositions.composition.NodeRole.OUTPUT" title="psyneulink.core.compositions.composition.NodeRole.OUTPUT"><code class="xref any py py-attr docutils literal notranslate"><span class="pre">OUTPUT</span></code></a>
<a class="reference internal" href="Composition.html#composition-nodes"><span class="std std-ref">Nodes</span></a>. The input is then stored in its <a class="reference internal" href="#psyneulink.library.compositions.emcomposition.EMComposition.memory" title="psyneulink.library.compositions.emcomposition.EMComposition.memory"><code class="xref any py py-attr docutils literal notranslate"><span class="pre">memory</span></code></a>, with a probability
determined by its <a class="reference internal" href="#psyneulink.library.compositions.emcomposition.EMComposition.storage_prob" title="psyneulink.library.compositions.emcomposition.EMComposition.storage_prob"><code class="xref any py py-attr docutils literal notranslate"><span class="pre">storage_prob</span></code></a> <a class="reference internal" href="Parameters.html#psyneulink.core.globals.parameters.Parameter" title="psyneulink.core.globals.parameters.Parameter"><code class="xref any py py-class docutils literal notranslate"><span class="pre">Parameter</span></code></a>, and all previous memories decayed by its
<a class="reference internal" href="#psyneulink.library.compositions.emcomposition.EMComposition.memory_decay_rate" title="psyneulink.library.compositions.emcomposition.EMComposition.memory_decay_rate"><code class="xref any py py-attr docutils literal notranslate"><span class="pre">memory_decay_rate</span></code></a>. The <a class="reference internal" href="#psyneulink.library.compositions.emcomposition.EMComposition.memory" title="psyneulink.library.compositions.emcomposition.EMComposition.memory"><code class="xref any py py-attr docutils literal notranslate"><span class="pre">memory</span></code></a> can be accessed using its
<a class="reference internal" href="#psyneulink.library.compositions.emcomposition.EMComposition.memory" title="psyneulink.library.compositions.emcomposition.EMComposition.memory"><code class="xref any py py-attr docutils literal notranslate"><span class="pre">memory</span></code></a> Parameter.</p>
<blockquote>
<div><div class="technical-note docutils container">
<p>The memories of an EMComposition are actually stored in the <a class="reference internal" href="MappingProjection.html#psyneulink.core.components.projections.pathway.mappingprojection.MappingProjection.matrix" title="psyneulink.core.components.projections.pathway.mappingprojection.MappingProjection.matrix"><code class="xref any py py-attr docutils literal notranslate"><span class="pre">matrix</span></code></a> <a class="reference internal" href="Parameters.html#psyneulink.core.globals.parameters.Parameter" title="psyneulink.core.globals.parameters.Parameter"><code class="xref any py py-class docutils literal notranslate"><span class="pre">Parameter</span></code></a>
of a set of <a class="reference internal" href="MappingProjection.html"><span class="doc">MappingProjections</span></a> (see <a class="reference internal" href="#emcomposition-memory-storage"><span class="std std-ref">note below</span></a>). The
<a class="reference internal" href="#psyneulink.library.compositions.emcomposition.EMComposition.memory" title="psyneulink.library.compositions.emcomposition.EMComposition.memory"><code class="xref any py py-attr docutils literal notranslate"><span class="pre">memory</span></code></a> Parameter compiles and formats these as a single 3d array, the rows of which
(axis 0) are each entry, the columns of which (axis 1) are the fields of each entry, and the items of which
(axis 2)  are the values of each field (see <code class="xref any docutils literal notranslate"><span class="pre">EMComposition_Memory_Configuration</span></code> for additional details).</p>
</div>
</div></blockquote>
<p id="emcomposition-organization"><strong>Organization</strong></p>
<p id="emcomposition-entries-and-fields"><em>Entries and Fields</em>. Each entry in memory can have an arbitrary number of fields, and each field can have an arbitrary
length.  However, all entries must have the same number of fields, and the corresponding fields must all have the same
length across entries. Each field is treated as a separate “channel” for storage and retrieval, and is associated with
its own corresponding input (key or value) and output (retrieved value) <a class="reference internal" href="Composition.html#composition-nodes"><span class="std std-ref">Node</span></a>, some or all of
which can be used to compute the similarity of the input (key) to entries in memory, that is used for retreieval.
Fields can be differentially weighted to determine the influence they have on retrieval, using the <a class="reference internal" href="#psyneulink.library.compositions.emcomposition.EMComposition.field_weights" title="psyneulink.library.compositions.emcomposition.EMComposition.field_weights"><code class="xref any py py-attr docutils literal notranslate"><span class="pre">field_weights</span></code></a> parameter (see <a class="reference internal" href="#emcomposition-retrieval-storage"><span class="std std-ref">retrieval</span></a> below). The number and shape
of the fields in each entry is specified in the <strong>memory_template</strong> argument of the EMComposition’s constructor (see
<a class="reference internal" href="#emcomposition-memory-specification"><span class="std std-ref">memory_template</span></a>). Which fields treated as keys (i.e., matched against queries
during retrieval) and which are treated as values (i.e., retrieved but not used for matching retrieval) is specified in
the <strong>field_weights</strong> argument of the EMComposition’s constructor (see <a class="reference internal" href="#emcomposition-field-weights"><span class="std std-ref">field_weights</span></a>).</p>
<p id="emcomposition-operation"><strong>Operation</strong></p>
<p><em>Retrieval.</em>  The values retrieved from <a class="reference internal" href="MemoryFunctions.html#id0" title="psyneulink.core.components.functions.stateful.memoryfunctions.ContentAddressableMemory.memory"><code class="xref any py py-attr docutils literal notranslate"><span class="pre">memory</span></code></a> (one for each field) are based
on the relative similarity of the keys to the entries in memory, computed as the distance of each key and the
values in the corresponding field for each entry in memory. By default, for queries and keys that are vectors,
normalized dot products (comparable to cosine similarity) are used to compute the similarity of each query to each
key in memory; and if they are scalars the L0 norm is used.  These distances are then weighted by the corresponding
<a class="reference internal" href="#psyneulink.library.compositions.emcomposition.EMComposition.field_weights" title="psyneulink.library.compositions.emcomposition.EMComposition.field_weights"><code class="xref any py py-attr docutils literal notranslate"><span class="pre">field_weights</span></code></a> for each field (if specified) and then summed, and the sum is softmaxed
to produce a softmax distribution over the entries in memory. That is then used to generate a softmax-weighted average
of the retrieved values across all fields, which is returned as the <code class="xref any docutils literal notranslate"><span class="pre">result</span></code> of the EMComposition’s
<a class="reference internal" href="Composition.html#composition-execution"><span class="std std-ref">execution</span></a> (an EMComposition can also be configured to return the exact entry with the lowest
distance (weighted by field), however then it is not compatible with learning; see <a class="reference internal" href="#emcomposition-softmax-choice"><span class="std std-ref">softmax_choice</span></a>).</p>
<p><em>Storage.</em>  The <a class="reference internal" href="Composition.html#composition-input-external-inputports"><span class="std std-ref">inputs</span></a> to the EMComposition’s fields are stored
in <a class="reference internal" href="#psyneulink.library.compositions.emcomposition.EMComposition.memory" title="psyneulink.library.compositions.emcomposition.EMComposition.memory"><code class="xref any py py-attr docutils literal notranslate"><span class="pre">memory</span></code></a> after each execution, with a probability determined by <a class="reference internal" href="#psyneulink.library.compositions.emcomposition.EMComposition.storage_prob" title="psyneulink.library.compositions.emcomposition.EMComposition.storage_prob"><code class="xref any py py-attr docutils literal notranslate"><span class="pre">storage_prob</span></code></a>.  If <a class="reference internal" href="#psyneulink.library.compositions.emcomposition.EMComposition.memory_decay_rate" title="psyneulink.library.compositions.emcomposition.EMComposition.memory_decay_rate"><code class="xref any py py-attr docutils literal notranslate"><span class="pre">memory_decay_rate</span></code></a> is specified, then
the <a class="reference internal" href="#psyneulink.library.compositions.emcomposition.EMComposition.memory" title="psyneulink.library.compositions.emcomposition.EMComposition.memory"><code class="xref any py py-attr docutils literal notranslate"><span class="pre">memory</span></code></a> is decayed by that amount after each execution.  If <a class="reference internal" href="#psyneulink.library.compositions.emcomposition.EMComposition.memory_capacity" title="psyneulink.library.compositions.emcomposition.EMComposition.memory_capacity"><code class="xref any py py-attr docutils literal notranslate"><span class="pre">memory_capacity</span></code></a> has been reached, then each new memory replaces the weakest entry
(i.e., the one with the smallest norm across all of its fields) in <a class="reference internal" href="#psyneulink.library.compositions.emcomposition.EMComposition.memory" title="psyneulink.library.compositions.emcomposition.EMComposition.memory"><code class="xref any py py-attr docutils literal notranslate"><span class="pre">memory</span></code></a>.</p>
</section>
<section id="creation">
<span id="emcomposition-creation"></span><h2>Creation<a class="headerlink" href="#creation" title="Permalink to this headline">¶</a></h2>
<p>An EMComposition is created by calling its constructor.  There are four major elements that can be configured:
the structure of its <code class="xref any docutils literal notranslate"><span class="pre">memory</span></code> for the entries
in memory; how <a class="reference internal" href="#emcomposition-retrieval-storage"><span class="std std-ref">storage and retrieval</span></a> operate; and whether and how <a class="reference internal" href="#emcomposition-learning"><span class="std std-ref">learning</span></a> is carried out.</p>
<section id="memory-specification">
<span id="emcomposition-memory-specification"></span><h3><em>Memory Specification</em><a class="headerlink" href="#memory-specification" title="Permalink to this headline">¶</a></h3>
<p>These arguments are used to specify the shape and number of memory entries.</p>
<ul id="emcomposition-memory-template">
<li><p><strong>memory_template</strong>: This specifies the shape of the entries to be stored in the EMComposition’s <a class="reference internal" href="#psyneulink.library.compositions.emcomposition.EMComposition.memory" title="psyneulink.library.compositions.emcomposition.EMComposition.memory"><code class="xref any py py-attr docutils literal notranslate"><span class="pre">memory</span></code></a>, and can be used to initialize <a class="reference internal" href="#psyneulink.library.compositions.emcomposition.EMComposition.memory" title="psyneulink.library.compositions.emcomposition.EMComposition.memory"><code class="xref any py py-attr docutils literal notranslate"><span class="pre">memory</span></code></a> with pre-specified entries.
The <strong>memory_template</strong> argument can be specified in one of three ways (see <a class="reference internal" href="#emcomposition-examples"><span class="std std-ref">Examples</span></a> for
representative use cases):</p>
<ul>
<li><p><strong>tuple</strong>: interpreted as an np.array shape specification, that must be of length 2 or 3.  If it is a 3-item tuple,
then the first item specifies the number of entries in memory, the 2nd the number of fields in each entry, and the
3rd the length of each field.  If it is a 2-item tuple, this specifies the shape of an entry, and the number of
entries is specified by <a class="reference internal" href="#emcomposition-memory-capacity"><span class="std std-ref">memory_capacity</span></a>).  All entries are
filled with zeros or the value specified by <a class="reference internal" href="#emcomposition-memory-fill"><span class="std std-ref">memory_fill</span></a>.</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>If <strong>memory_template</strong> is specified with a 3-item tuple and <a class="reference internal" href="#emcomposition-memory-capacity"><span class="std std-ref">memory_capacity</span></a>
is also specified with a value that does not match the first item of <strong>memory_template</strong>, and error is
generated indicating the conflict in the number of entries specified.</p>
</div>
<div class="admonition hint">
<p class="admonition-title">Hint</p>
<p>To specify a single field, a list or array must be used (see below), as a 2-item tuple is interpreted as
specifying the shape of an entry, and so it can’t be used to specify the number of entries each of which
has a single field.</p>
</div>
</li>
<li><p><strong>2d list or array</strong>: interpreted as a template for memory entries. This can be used to specify fields of
different lengths (i.e., entries that are ragged arrays), with each item in the list (axis 0 of the array) used
to specify the length of the corresponding field.  The template is then used to initialze all entries in <a class="reference internal" href="#psyneulink.library.compositions.emcomposition.EMComposition.memory" title="psyneulink.library.compositions.emcomposition.EMComposition.memory"><code class="xref any py py-attr docutils literal notranslate"><span class="pre">memory</span></code></a>.  If the template includes any non-zero elements, then the array is replicated for all
entries in <a class="reference internal" href="#psyneulink.library.compositions.emcomposition.EMComposition.memory" title="psyneulink.library.compositions.emcomposition.EMComposition.memory"><code class="xref any py py-attr docutils literal notranslate"><span class="pre">memory</span></code></a>; otherwise, they are filled with either zeros or the value specified
in <a class="reference internal" href="#emcomposition-memory-fill"><span class="std std-ref">memory_fill</span></a>.</p>
<div class="admonition hint">
<p class="admonition-title">Hint</p>
<p>To specify a single entry, with all other entries filled with zeros
or the value specified in <strong>memory_fill</strong>, use a 3d array as described below.</p>
</div>
</li>
<li><p><strong>3d list or array</strong>: used to initialize <a class="reference internal" href="#psyneulink.library.compositions.emcomposition.EMComposition.memory" title="psyneulink.library.compositions.emcomposition.EMComposition.memory"><code class="xref any py py-attr docutils literal notranslate"><span class="pre">memory</span></code></a> directly with the entries specified in
the outer dimension (axis 0) of the list or array.  If <a class="reference internal" href="#emcomposition-memory-capacity"><span class="std std-ref">memory_capacity</span></a> is not
specified, then it is set to the number of entries in the list or array. If <strong>memory_capacity</strong> <em>is</em> specified,
then the number of entries specified in <strong>memory_template</strong> must be less than or equal to <strong>memory_capacity</strong>.  If
is less than <strong>memory_capacity</strong>, then the remaining entries in <a class="reference internal" href="#psyneulink.library.compositions.emcomposition.EMComposition.memory" title="psyneulink.library.compositions.emcomposition.EMComposition.memory"><code class="xref any py py-attr docutils literal notranslate"><span class="pre">memory</span></code></a> are filled with
zeros or the value specified in <strong>memory_fill</strong> (see below):  if all of the entries specified contain only
zeros, and <strong>memory_fill</strong> is specified, then the matrix is filled with the value specified in <strong>memory_fill</strong>;
otherwise, zeros are used to fill all entries.</p></li>
</ul>
</li>
</ul>
<ul id="emcomposition-memory-fill">
<li><p><strong>memory_fill</strong>: specifies the value used to fill the <a class="reference internal" href="#psyneulink.library.compositions.emcomposition.EMComposition.memory" title="psyneulink.library.compositions.emcomposition.EMComposition.memory"><code class="xref any py py-attr docutils literal notranslate"><span class="pre">memory</span></code></a>, based on the shape specified
in the <strong>memory_template</strong> (see above).  The value can be a scalar, or a tuple to specify an interval over which
to draw random values to fill <a class="reference internal" href="#psyneulink.library.compositions.emcomposition.EMComposition.memory" title="psyneulink.library.compositions.emcomposition.EMComposition.memory"><code class="xref any py py-attr docutils literal notranslate"><span class="pre">memory</span></code></a> — both should be scalars, with the first specifying
the lower bound and the second the upper bound.  If <strong>memory_fill</strong> is not specified, and no entries are specified
in <strong>memory_template</strong>, then <a class="reference internal" href="#psyneulink.library.compositions.emcomposition.EMComposition.memory" title="psyneulink.library.compositions.emcomposition.EMComposition.memory"><code class="xref any py py-attr docutils literal notranslate"><span class="pre">memory</span></code></a> is filled with zeros.</p>
<div class="admonition hint">
<p class="admonition-title">Hint</p>
<p>If memory is initialized with all zeros and <strong>normalize_memories</strong> set to <code class="docutils literal notranslate"><span class="pre">True</span></code> (see <a class="reference internal" href="#emcomposition-retrieval-storage"><span class="std std-ref">below</span></a>) then a numpy.linalg warning is issued about divide by zero.
This can be ignored, as it does not affect the results of execution, but it can be averted by specifying
<a class="reference internal" href="#emcomposition-memory-fill"><span class="std std-ref">memory_fill</span></a> to use small random values (e.g., <code class="docutils literal notranslate"><span class="pre">memory_fill=(0,.001)</span></code>).</p>
</div>
</li>
</ul>
<ul class="simple" id="emcomposition-memory-capacity">
<li><p><strong>memory_capacity</strong>: specifies the number of items that can be stored in the EMComposition’s memory; when
<a class="reference internal" href="#psyneulink.library.compositions.emcomposition.EMComposition.memory_capacity" title="psyneulink.library.compositions.emcomposition.EMComposition.memory_capacity"><code class="xref any py py-attr docutils literal notranslate"><span class="pre">memory_capacity</span></code></a> is reached, each new entry overwrites the weakest entry (i.e., the
one with the smallest norm across all of its fields) in <a class="reference internal" href="#psyneulink.library.compositions.emcomposition.EMComposition.memory" title="psyneulink.library.compositions.emcomposition.EMComposition.memory"><code class="xref any py py-attr docutils literal notranslate"><span class="pre">memory</span></code></a>.  If <a class="reference internal" href="#emcomposition-memory-template"><span class="std std-ref">memory_template</span></a> is specified as a 3-item tuple or 3d list or array (see above), then that is used
to determine <a class="reference internal" href="#psyneulink.library.compositions.emcomposition.EMComposition.memory_capacity" title="psyneulink.library.compositions.emcomposition.EMComposition.memory_capacity"><code class="xref any py py-attr docutils literal notranslate"><span class="pre">memory_capacity</span></code></a> (if it is specified and conflicts with either of those
an error is generated).  Otherwise, it can be specified using a numerical value, with a default of 1000.  The
<a class="reference internal" href="#psyneulink.library.compositions.emcomposition.EMComposition.memory_capacity" title="psyneulink.library.compositions.emcomposition.EMComposition.memory_capacity"><code class="xref any py py-attr docutils literal notranslate"><span class="pre">memory_capacity</span></code></a> cannot be modified once the EMComposition has been constructed.</p></li>
</ul>
</section>
<section id="fields">
<span id="emcomposition-fields"></span><h3><em>Fields</em><a class="headerlink" href="#fields" title="Permalink to this headline">¶</a></h3>
<p>These arguments are used to specify the names of the fields in a memory entry, which are used for its keys and values,
how keys are weighted for retrieval, whether those weights are learned, and which fields are used for computing error
that is propagated through the EMComposition.</p>
<ul id="emcomposition-field-specification-dict">
<li><p><strong>fields</strong>: a dict that specifies the names of the fields and their attributes. There must be an entry for each
field specified in the <strong>memory_template</strong>, and must have the following format:</p>
<ul class="simple">
<li><p><em>key</em>:  a string that specifies the name of the field.</p></li>
<li><p><em>value</em>: a dict or tuple with three entries; if a dict, the key to each entry must be the keyword specified below,
and if a tuple, the entries must appear in the following order:</p>
<ul>
<li><p><em>FIELD_WEIGHT</em> <a class="reference internal" href="#emcomposition-field-weights"><span class="std std-ref">specification</span></a> - value must be a scalar or None. If it is a scalar,
the field is treated as a <a class="reference internal" href="#emcomposition-field-weights"><span class="std std-ref">retrieval key</span></a> in <a class="reference internal" href="#psyneulink.library.compositions.emcomposition.EMComposition.memory" title="psyneulink.library.compositions.emcomposition.EMComposition.memory"><code class="xref any py py-attr docutils literal notranslate"><span class="pre">memory</span></code></a> that
is weighted by that value during retrieval; if None, it is treated as a value in <a class="reference internal" href="#psyneulink.library.compositions.emcomposition.EMComposition.memory" title="psyneulink.library.compositions.emcomposition.EMComposition.memory"><code class="xref any py py-attr docutils literal notranslate"><span class="pre">memory</span></code></a>
and the field cannot be reconfigured later.</p></li>
<li><p><em>LEARN_FIELD_WEIGHT</em> <a class="reference internal" href="#emcomposition-field-weights-learning"><span class="std std-ref">specification</span></a> - value must be a boolean or a float;
if False, the field_weight for that field is not learned; if True, the field weight is learned using the
EMComposition’s <a class="reference internal" href="#psyneulink.library.compositions.emcomposition.EMComposition.learning_rate" title="psyneulink.library.compositions.emcomposition.EMComposition.learning_rate"><code class="xref any py py-attr docutils literal notranslate"><span class="pre">learning_rate</span></code></a>; if a float, that is used as its learning_rate.</p></li>
<li><p><em>TARGET_FIELD</em> <a class="reference internal" href="#emcomposition-target-fields"><span class="std std-ref">specification</span></a> - value must be a boolean; if True, the value of the
<a class="reference internal" href="#psyneulink.library.compositions.emcomposition.EMComposition.retrieved_nodes" title="psyneulink.library.compositions.emcomposition.EMComposition.retrieved_nodes"><code class="xref any py py-attr docutils literal notranslate"><span class="pre">retrieved_node</span></code></a> for that field conrtributes to the error computed during learning
and backpropagated through the EMComposition (see <code class="xref any docutils literal notranslate"><span class="pre">Backpropagation</span> <span class="pre">of</span></code>);
if False, the retrieved value for that field does not contribute to the error; however, its field_weight can still
be learned if that is specfified in <a class="reference internal" href="#emcomposition-field-weights-learning"><span class="std std-ref">learn_field_weight</span></a>.</p></li>
</ul>
</li>
</ul>
<p>The specifications provided in the <strong>fields</strong> argument are assigned to the corresponding Parameters of
the EMComposition which, alternatively, can  be specified individually using the <strong>field_names</strong>, <strong>field_weights</strong>,
<strong>learn_field_weights</strong> and <strong>target_fields</strong> arguments of the EMComposition’s constructor, as described below.
However, these and the <strong>fields</strong> argument cannot both be used together; doing so raises an error.</p>
</li>
</ul>
<ul class="simple" id="emcomposition-field-names">
<li><p><strong>field_names</strong>: a list specifies names that can be assigned to the fields. The number of names specified must match
the number of fields specified in the memory_template.  If specified, the names are used to label the nodes of the
EMComposition; otherwise, the fields are labeled generically as “Key 0”, “Key 1”, and “Value 1”, “Value 2”, etc..</p></li>
</ul>
<ul id="emcomposition-field-weights">
<li><p><strong>field_weights</strong>: specifies which fields are used as keys, and how they are weighted during retrieval. Fields
designated as keys used to match inputs (queries) against entries in memory for retrieval (see <a class="reference internal" href="#emcomposition-processing"><span class="std std-ref">Match memories by
field</span></a>); entries designated as <em>values</em> are ignored during the matching process, but
their values in memory are retrieved and assigned as the <a class="reference internal" href="Mechanism.html#psyneulink.core.components.mechanisms.mechanism.Mechanism_Base.value" title="psyneulink.core.components.mechanisms.mechanism.Mechanism_Base.value"><code class="xref any py py-attr docutils literal notranslate"><span class="pre">value</span></code></a> of the corresponding
<a class="reference internal" href="#psyneulink.library.compositions.emcomposition.EMComposition.retrieved_nodes" title="psyneulink.library.compositions.emcomposition.EMComposition.retrieved_nodes"><code class="xref any py py-attr docutils literal notranslate"><span class="pre">retrieved_node</span></code></a>. This distinction between keys and value corresponds
to the format of a standard “dictionary,” though in that case only a single key and value are allowed, whereas
in an EMComposition there can be one or more keys and any number of values; if all fields are keys, this implements a
full form of content-addressable memory. The following options can be used to specify <strong>field_weights</strong>:</p>
<blockquote>
<div><ul>
<li><p><em>None</em> (the default): all fields except the last are treated as keys, and are assigned a weight of 1,
while the last field is treated as a value field (same as assiging it None in a list or tuple (see below).</p></li>
<li><p><em>scalar</em>: all fields are treated as keys (i.e., used for retrieval) and weighted equally for retrieval.  If
<a class="reference internal" href="#emcomposition-normalize-field-weights"><span class="std std-ref">normalize_field_weights</span></a> is True, the value is divided by the number
of keys, whereas if <a class="reference internal" href="#emcomposition-normalize-field-weights"><span class="std std-ref">normalize_field_weights</span></a> is False, then the value
specified is used to weight the retrieval of all keys with that value.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>At present these have the same result, since the <a class="reference internal" href="TransferFunctions.html#psyneulink.core.components.functions.transferfunctions.SoftMax" title="psyneulink.core.components.functions.transferfunctions.SoftMax"><code class="xref any py py-class docutils literal notranslate"><span class="pre">SoftMax</span></code></a> function is used to normalize the match between
queries and keys.  However, other retrieval functions could be used in the future that would be affected by
the value of the <a class="reference internal" href="#psyneulink.library.compositions.emcomposition.EMComposition.field_weights" title="psyneulink.library.compositions.emcomposition.EMComposition.field_weights"><code class="xref any py py-attr docutils literal notranslate"><span class="pre">field_weights</span></code></a>.  Therefore, it is recommended to leave
<a class="reference internal" href="#emcomposition-normalize-field-weights"><span class="std std-ref">normalize_field_weights</span></a> set to True (the default) to ensure that
the <a class="reference internal" href="#psyneulink.library.compositions.emcomposition.EMComposition.field_weights" title="psyneulink.library.compositions.emcomposition.EMComposition.field_weights"><code class="xref any py py-attr docutils literal notranslate"><span class="pre">field_weights</span></code></a> are normalized to sum to 1.0.</p>
</div>
</li>
<li><p><em>list or tuple</em>: the number of entries must match the number of fields specified in <strong>memory_template</strong>, and
all entries must be either 0, a positive scalar value, or None.  If all entries are identical, they are treated
as if a single value  was specified (see above); if the entries are non-identical, any entries that are not None
are used to weight the corresponding fields during retrieval (see <a class="reference internal" href="#emcomposition-processing"><span class="std std-ref">Weight fields</span></a>),
including those that are 0 (though these will not be used in the retrieval process unless/until they are changed
to a positive value). If <a class="reference internal" href="#emcomposition-normalize-field-weights"><span class="std std-ref">normalize_field_weights</span></a> is True, all non-None
entries are normalized so that they sum to 1.0; if False, the raw values are used to weight the retrieval of
the corresponding fields. All entries of None are treated as value fields, are not assigned a <a class="reference internal" href="#psyneulink.library.compositions.emcomposition.EMComposition.field_weight_nodes" title="psyneulink.library.compositions.emcomposition.EMComposition.field_weight_nodes"><code class="xref any py py-attr docutils literal notranslate"><span class="pre">field_weight_node</span></code></a>, and are ignored during retrieval.  These <em>cannot be modified</em> after the
EMComposition has been constructed (see note below).</p></li>
</ul>
<div class="admonition note" id="emcomposition-field-weights-change-note">
<p class="admonition-title">Note</p>
<p>The field_weights can be modified after the EMComposition has been constructed, by assigning a new set of weights
to its <a class="reference internal" href="#psyneulink.library.compositions.emcomposition.EMComposition.field_weights" title="psyneulink.library.compositions.emcomposition.EMComposition.field_weights"><code class="xref any py py-attr docutils literal notranslate"><span class="pre">field_weights</span></code></a> <a class="reference internal" href="Parameters.html#psyneulink.core.globals.parameters.Parameter" title="psyneulink.core.globals.parameters.Parameter"><code class="xref any py py-class docutils literal notranslate"><span class="pre">Parameter</span></code></a>.  However, only field_weights associated with
key fields (i.e., that were initially assigned non-zero field_weights) can be modified; the weights for value
fields (i.e., ones that were initially assigned a field_weight of None) cannot be modified, and doing so raises
an error. If a field that will be used initially as a value may later need to be used as a key, it should be
assigned a <a class="reference internal" href="#psyneulink.library.compositions.emcomposition.EMComposition.field_weights" title="psyneulink.library.compositions.emcomposition.EMComposition.field_weights"><code class="xref any py py-attr docutils literal notranslate"><span class="pre">field_weight</span></code></a> of 0 at construction (rather than None), which can then
later be changed as needed.</p>
</div>
<div class="technical-note docutils container">
<p>The reason that field_weights can be modified only for keys is that <a class="reference internal" href="#psyneulink.library.compositions.emcomposition.EMComposition.field_weight_nodes" title="psyneulink.library.compositions.emcomposition.EMComposition.field_weight_nodes"><code class="xref any py py-attr docutils literal notranslate"><span class="pre">field_weight_nodes</span></code></a> are constructed only for keys, since ones for values would have no effect
on the retrieval process and therefore are uncecessary (and can be misleading).</p>
</div>
</div></blockquote>
</li>
<li><p><strong>learn_field_weights</strong>:  if <strong>enable_learning</strong> is True, this specifies which field_weights are subject to learning,
and optionally the <a class="reference internal" href="#psyneulink.library.compositions.emcomposition.EMComposition.learning_rate" title="psyneulink.library.compositions.emcomposition.EMComposition.learning_rate"><code class="xref any py py-attr docutils literal notranslate"><span class="pre">learning_rate</span></code></a> for each (see <a class="reference internal" href="#emcomposition-field-weights-learning"><span class="std std-ref">learn_field_weights</span></a> below for details of specification).</p></li>
</ul>
<ul class="simple" id="emcomposition-normalize-field-weights">
<li><dl class="simple">
<dt><strong>normalize_field_weights</strong>: specifies whether the <a class="reference internal" href="#psyneulink.library.compositions.emcomposition.EMComposition.field_weights" title="psyneulink.library.compositions.emcomposition.EMComposition.field_weights"><code class="xref any py py-attr docutils literal notranslate"><span class="pre">field_weights</span></code></a> are normalized or</dt><dd><p>their raw values are used.  If True, the value of all non-None <a class="reference internal" href="#psyneulink.library.compositions.emcomposition.EMComposition.field_weights" title="psyneulink.library.compositions.emcomposition.EMComposition.field_weights"><code class="xref any py py-attr docutils literal notranslate"><span class="pre">field_weights</span></code></a> are
normalized so that they sum to 1.0, and the normalized values are used to weight (i.e., multiply) the corresponding
fields during retrieval (see <a class="reference internal" href="#emcomposition-processing"><span class="std std-ref">Weight fields</span></a>). If False, the raw values of the
<a class="reference internal" href="#psyneulink.library.compositions.emcomposition.EMComposition.field_weights" title="psyneulink.library.compositions.emcomposition.EMComposition.field_weights"><code class="xref any py py-attr docutils literal notranslate"><span class="pre">field_weights</span></code></a> are used to weight the retrieved value of each field. This setting
is ignored if <strong>field_weights</strong> is None or <a class="reference internal" href="#emcomposition-concatenate-queries"><span class="std std-ref">concatenate_queries</span></a> is True.</p>
</dd>
</dl>
</li>
</ul>
<ul id="emcomposition-concatenate-queries">
<li><p><strong>concatenate_queries</strong>:  specifies whether keys are concatenated before a match is made to items in memory.
This is False by default. It is also ignored if the <a class="reference internal" href="#psyneulink.library.compositions.emcomposition.EMComposition.field_weights" title="psyneulink.library.compositions.emcomposition.EMComposition.field_weights"><code class="xref any py py-attr docutils literal notranslate"><span class="pre">field_weights</span></code></a> for all keys are
not all equal (i.e., all non-zero weights are not equal – see <a class="reference internal" href="#emcomposition-field-weights"><span class="std std-ref">field_weights</span></a>) and/or
<a class="reference internal" href="#psyneulink.library.compositions.emcomposition.EMComposition.normalize_memories" title="psyneulink.library.compositions.emcomposition.EMComposition.normalize_memories"><code class="xref any py py-attr docutils literal notranslate"><span class="pre">normalize_memories</span></code></a> is set to False. Setting concatenate_queries to True in either
of those cases issues a warning, and the setting is ignored. If the key <a class="reference internal" href="#psyneulink.library.compositions.emcomposition.EMComposition.field_weights" title="psyneulink.library.compositions.emcomposition.EMComposition.field_weights"><code class="xref any py py-attr docutils literal notranslate"><span class="pre">field_weights</span></code></a>
(i.e., all non-zero values) are all equal <em>and</em> <strong>normalize_memories</strong> is set to True, then setting
<strong>concatenate_queries</strong> causes a <a class="reference internal" href="#psyneulink.library.compositions.emcomposition.EMComposition.concatenate_queries_node" title="psyneulink.library.compositions.emcomposition.EMComposition.concatenate_queries_node"><code class="xref any py py-attr docutils literal notranslate"><span class="pre">concatenate_queries_node</span></code></a> to be created
that receives input from all of the <a class="reference internal" href="#psyneulink.library.compositions.emcomposition.EMComposition.query_input_nodes" title="psyneulink.library.compositions.emcomposition.EMComposition.query_input_nodes"><code class="xref any py py-attr docutils literal notranslate"><span class="pre">query_input_nodes</span></code></a> and passes them as a single
vector to the <a class="reference internal" href="#psyneulink.library.compositions.emcomposition.EMComposition.match_nodes" title="psyneulink.library.compositions.emcomposition.EMComposition.match_nodes"><code class="xref any py py-attr docutils literal notranslate"><span class="pre">mactch_node</span></code></a>.</p>
<blockquote>
<div><div class="admonition note">
<p class="admonition-title">Note</p>
<p>While this is computationally more efficient, it can affect the outcome of the <a class="reference internal" href="#emcomposition-processing"><span class="std std-ref">matching process</span></a>, since computing the distance of a single vector comprised of the concatentated
inputs is not identical to computing the distance of each field independently and then combining the results.</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>All <a class="reference internal" href="#psyneulink.library.compositions.emcomposition.EMComposition.query_input_nodes" title="psyneulink.library.compositions.emcomposition.EMComposition.query_input_nodes"><code class="xref any py py-attr docutils literal notranslate"><span class="pre">query_input_nodes</span></code></a> and <a class="reference internal" href="#psyneulink.library.compositions.emcomposition.EMComposition.retrieved_nodes" title="psyneulink.library.compositions.emcomposition.EMComposition.retrieved_nodes"><code class="xref any py py-attr docutils literal notranslate"><span class="pre">retrieved_nodes</span></code></a>
are always preserved, even when <a class="reference internal" href="#psyneulink.library.compositions.emcomposition.EMComposition.concatenate_queries" title="psyneulink.library.compositions.emcomposition.EMComposition.concatenate_queries"><code class="xref any py py-attr docutils literal notranslate"><span class="pre">concatenate_queries</span></code></a> is True, so that
separate inputs can be provided for each key, and the value of each key can be retrieved separately.</p>
</div>
</div></blockquote>
</li>
</ul>
</section>
<section id="retrieval-and-storage">
<span id="emcomposition-retrieval-storage"></span><h3><em>Retrieval and Storage</em><a class="headerlink" href="#retrieval-and-storage" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li><p><strong>storage_prob</strong>: specifies the probability that the inputs to the EMComposition will be stored as an item in
<a class="reference internal" href="#psyneulink.library.compositions.emcomposition.EMComposition.memory" title="psyneulink.library.compositions.emcomposition.EMComposition.memory"><code class="xref any py py-attr docutils literal notranslate"><span class="pre">memory</span></code></a> on each execution.</p></li>
<li><p><strong>normalize_memories</strong>: specifies whether queries and keys in memory are normalized before computing their dot
products.</p></li>
</ul>
<ul id="emcomposition-softmax-gain">
<li><p><strong>softmax_gain</strong>: specifies the gain (inverse temperature) used for softmax normalizing the combined distances
used for retrieval (see <a class="reference internal" href="#emcomposition-execution"><span class="std std-ref">Execution</span></a> below).  The following options can be used:</p>
<ul class="simple">
<li><p>numeric value: the value is used as the gain of the <a class="reference internal" href="TransferFunctions.html#psyneulink.core.components.functions.transferfunctions.SoftMax" title="psyneulink.core.components.functions.transferfunctions.SoftMax"><code class="xref any py py-class docutils literal notranslate"><span class="pre">SoftMax</span></code></a> Function for the EMComposition’s
<a class="reference internal" href="#psyneulink.library.compositions.emcomposition.EMComposition.softmax_node" title="psyneulink.library.compositions.emcomposition.EMComposition.softmax_node"><code class="xref any py py-attr docutils literal notranslate"><span class="pre">softmax_node</span></code></a>.</p></li>
<li><p><em>ADAPTIVE</em>: the <a class="reference internal" href="TransferFunctions.html#psyneulink.core.components.functions.transferfunctions.SoftMax.adapt_gain" title="psyneulink.core.components.functions.transferfunctions.SoftMax.adapt_gain"><code class="xref any py py-meth docutils literal notranslate"><span class="pre">adapt_gain</span></code></a> method of the <a class="reference internal" href="TransferFunctions.html#psyneulink.core.components.functions.transferfunctions.SoftMax" title="psyneulink.core.components.functions.transferfunctions.SoftMax"><code class="xref any py py-class docutils literal notranslate"><span class="pre">SoftMax</span></code></a> Function is used to adaptively set
the <a class="reference internal" href="#psyneulink.library.compositions.emcomposition.EMComposition.softmax_gain" title="psyneulink.library.compositions.emcomposition.EMComposition.softmax_gain"><code class="xref any py py-attr docutils literal notranslate"><span class="pre">softmax_gain</span></code></a> based on the entropy of the distances, in order to preserve
the distribution over non- (or near) zero entries irrespective of how many (near) zero entries there are
(see <a class="reference internal" href="TransferFunctions.html#softmax-adaptgain"><span class="std std-ref">Thresholding and Adaptive Gain</span></a> for additional details).</p></li>
<li><p><em>CONTROL</em>: a <a class="reference internal" href="ControlMechanism.html"><span class="doc">ControlMechanism</span></a> is created, and its <a class="reference internal" href="ControlSignal.html"><span class="doc">ControlSignal</span></a> is used to modulate the <a class="reference internal" href="#psyneulink.library.compositions.emcomposition.EMComposition.softmax_gain" title="psyneulink.library.compositions.emcomposition.EMComposition.softmax_gain"><code class="xref any py py-attr docutils literal notranslate"><span class="pre">softmax_gain</span></code></a> parameter of the <a class="reference internal" href="TransferFunctions.html#psyneulink.core.components.functions.transferfunctions.SoftMax" title="psyneulink.core.components.functions.transferfunctions.SoftMax"><code class="xref any py py-class docutils literal notranslate"><span class="pre">SoftMax</span></code></a> function of the EMComposition’s <a class="reference internal" href="#psyneulink.library.compositions.emcomposition.EMComposition.softmax_node" title="psyneulink.library.compositions.emcomposition.EMComposition.softmax_node"><code class="xref any py py-attr docutils literal notranslate"><span class="pre">softmax_node</span></code></a>.</p></li>
</ul>
<p>If <em>None</em> is specified, the default value for the <a class="reference internal" href="TransferFunctions.html#psyneulink.core.components.functions.transferfunctions.SoftMax" title="psyneulink.core.components.functions.transferfunctions.SoftMax"><code class="xref any py py-class docutils literal notranslate"><span class="pre">SoftMax</span></code></a> function is used.</p>
</li>
</ul>
<ul class="simple" id="emcomposition-softmax-threshold">
<li><p><strong>softmax_threshold</strong>: if this is specified, and <strong>softmax_gain</strong> is specified with a numeric value,
then any values below the specified threshold are set to 0 before the distances are softmaxed
(see <em>mask_threhold</em> under <a class="reference internal" href="TransferFunctions.html#softmax-adaptgain"><span class="std std-ref">Thresholding and Adaptive Gain</span></a> for additional details).</p></li>
</ul>
<ul id="emcomposition-softmax-choice">
<li><p><strong>softmax_choice</strong>: specifies how the <a class="reference internal" href="TransferFunctions.html#psyneulink.core.components.functions.transferfunctions.SoftMax" title="psyneulink.core.components.functions.transferfunctions.SoftMax"><code class="xref any py py-class docutils literal notranslate"><span class="pre">SoftMax</span></code></a> Function of the EMComposition’s <a class="reference internal" href="#psyneulink.library.compositions.emcomposition.EMComposition.softmax_node" title="psyneulink.library.compositions.emcomposition.EMComposition.softmax_node"><code class="xref any py py-attr docutils literal notranslate"><span class="pre">softmax_node</span></code></a> is used, with the combined distances, to generate a retrieved item;
the following are the options that can be used and the retrieved value they produce:</p>
<ul class="simple">
<li><p><em>WEIGHTED_AVG</em> (default): softmax-weighted average based on combined distances of queries and keys in memory.</p></li>
<li><p><em>ARG_MAX</em>: entry with the smallest distance (one with lowest index in <a class="reference internal" href="#psyneulink.library.compositions.emcomposition.EMComposition.memory" title="psyneulink.library.compositions.emcomposition.EMComposition.memory"><code class="xref any py py-attr docutils literal notranslate"><span class="pre">memory</span></code></a>)               if there are identical ones).</p></li>
<li><p><em>PROBABISTIC</em>: probabilistically chosen entry based on softmax-transformed distribution of combined distance.</p></li>
</ul>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>Use of the <em>ARG_MAX</em> and <em>PROBABILISTIC</em> options is not compatible with learning, as these implement a discrete
choice and thus are not differentiable. Constructing an EMComposition with <strong>softmax_choice</strong> set to either of
these options and <strong>learn_field_weights</strong> set to True (or a list with any True entries) will generate a warning, and
calling the EMComposition’s <a class="reference internal" href="Composition.html#psyneulink.core.compositions.composition.Composition.learn" title="psyneulink.core.compositions.composition.Composition.learn"><code class="xref any py py-meth docutils literal notranslate"><span class="pre">learn</span></code></a> method will generate an error; it must be changed to
<em>WEIGHTED_AVG</em> to execute learning.</p>
</div>
<div class="technical-note docutils container">
<p>The <em>WEIGHTED_AVG</em> option is passed as <em>ALL</em> to the <strong>output</strong> argument of the <a class="reference internal" href="TransferFunctions.html#psyneulink.core.components.functions.transferfunctions.SoftMax" title="psyneulink.core.components.functions.transferfunctions.SoftMax"><code class="xref any py py-class docutils literal notranslate"><span class="pre">SoftMax</span></code></a> Function, <em>ARG_MAX</em> is
passed as <em>ARG_MAX_INDICATOR</em>; and <em>PROBALISTIC</em> is passed as <em>PROB_INDICATOR</em>; the other SoftMax options are
not currently supported.</p>
</div>
</li>
</ul>
<ul class="simple" id="emcomposition-memory-decay-rate">
<li><p><strong>memory_decay_rate</strong>: specifies the rate at which items in the EMComposition’s memory decay;  the default rate
is <em>AUTO</em>, which sets it to  1 / <a class="reference internal" href="#psyneulink.library.compositions.emcomposition.EMComposition.memory_capacity" title="psyneulink.library.compositions.emcomposition.EMComposition.memory_capacity"><code class="xref any py py-attr docutils literal notranslate"><span class="pre">memory_capacity</span></code></a>, such that the oldest memories
are the most likely to be replaced when <a class="reference internal" href="#psyneulink.library.compositions.emcomposition.EMComposition.memory_capacity" title="psyneulink.library.compositions.emcomposition.EMComposition.memory_capacity"><code class="xref any py py-attr docutils literal notranslate"><span class="pre">memory_capacity</span></code></a> is reached.  If
<strong>memory_decay_rate</strong> is set to 0 None or False, then memories do not decay and, when <a class="reference internal" href="#psyneulink.library.compositions.emcomposition.EMComposition.memory_capacity" title="psyneulink.library.compositions.emcomposition.EMComposition.memory_capacity"><code class="xref any py py-attr docutils literal notranslate"><span class="pre">memory_capacity</span></code></a> is reached, the weakest memories are replaced, irrespective of order of entry.</p></li>
</ul>
<ul class="simple" id="emcomposition-purge-by-weight">
<li><p><strong>purge_by_field_weight</strong>: specifies whether <a class="reference internal" href="#psyneulink.library.compositions.emcomposition.EMComposition.field_weights" title="psyneulink.library.compositions.emcomposition.EMComposition.field_weights"><code class="xref any py py-attr docutils literal notranslate"><span class="pre">field_weights</span></code></a> are used in determining
which memory entry is replaced when a new memory is <a class="reference internal" href="#emcomposition-storage"><span class="std std-ref">stored</span></a>.  If True, the norm of each
entry is multiplied by its <a class="reference internal" href="#emcomposition-field-weighting"><span class="std std-ref">field_weight</span></a> to determine which entry is the weakest and
will be replaced.</p></li>
</ul>
</section>
<section id="learning">
<span id="emcomposition-learning"></span><h3><em>Learning</em><a class="headerlink" href="#learning" title="Permalink to this headline">¶</a></h3>
<p>EMComposition supports two forms of learning: error backpropagation through the entire Composition, and the learning
of <a class="reference internal" href="#psyneulink.library.compositions.emcomposition.EMComposition.field_weights" title="psyneulink.library.compositions.emcomposition.EMComposition.field_weights"><code class="xref any py py-attr docutils literal notranslate"><span class="pre">field_weights</span></code></a> within it. Learning is enabled by setting the <strong>enable_learning</strong>
argument of the EMComposition’s constructor to True, and optionally specifying the <strong>learn_field_weights</strong> argument
(as detailed below). If <strong>enable_learning</strong> is False, no learning of any kind occurs; if it is True, then both forms
of learning are enable.</p>
<p><em>Backpropagation of error</em>.  If <strong>enable_learning</strong> is True, then the values retrieved from <a class="reference internal" href="#psyneulink.library.compositions.emcomposition.EMComposition.memory" title="psyneulink.library.compositions.emcomposition.EMComposition.memory"><code class="xref any py py-attr docutils literal notranslate"><span class="pre">memory</span></code></a> when the EMComposition is executed during learning can be used for error computation
and backpropagation through the EMComposition to its inputs.  By default, the values of all of its <a class="reference internal" href="#psyneulink.library.compositions.emcomposition.EMComposition.retrieved_nodes" title="psyneulink.library.compositions.emcomposition.EMComposition.retrieved_nodes"><code class="xref any py py-attr docutils literal notranslate"><span class="pre">retrieved_nodes</span></code></a> are included. For those that do not project to an outer Composition (i.e., one in
which the EMComposition is <a class="reference internal" href="Composition.html#composition-nested"><span class="std std-ref">nested</span></a>), a <a class="reference internal" href="Composition.html#psyneulink.core.compositions.composition.NodeRole.TARGET" title="psyneulink.core.compositions.composition.NodeRole.TARGET"><code class="xref any py py-attr docutils literal notranslate"><span class="pre">TARGET</span></code></a> node is constructed
for each, and used to compute errors that are backpropagated through the network to its <a class="reference internal" href="#psyneulink.library.compositions.emcomposition.EMComposition.query_input_nodes" title="psyneulink.library.compositions.emcomposition.EMComposition.query_input_nodes"><code class="xref any py py-attr docutils literal notranslate"><span class="pre">query_input_nodes</span></code></a> and <a class="reference internal" href="#psyneulink.library.compositions.emcomposition.EMComposition.value_input_nodes" title="psyneulink.library.compositions.emcomposition.EMComposition.value_input_nodes"><code class="xref any py py-attr docutils literal notranslate"><span class="pre">value_input_nodes</span></code></a>, and on to any
nodes that project to those from a Composition within which the EMComposition is <a class="reference internal" href="Composition.html#composition-nested"><span class="std std-ref">nested</span></a>.
Retrieved_nodes that <em>do</em> project to an outer Composition receive their errors from those nodes, which are also
backpropagated through the EMComposition. Fields can be selecdtively specified for learning in the <strong>fields</strong> argument
or the <strong>target_fields</strong> argument of the EMComposition’s constructor, as detailed below.</p>
<p><em>Field Weight Learning</em>.  If <strong>enable_learning</strong> is True, then the <a class="reference internal" href="#psyneulink.library.compositions.emcomposition.EMComposition.field_weights" title="psyneulink.library.compositions.emcomposition.EMComposition.field_weights"><code class="xref any py py-attr docutils literal notranslate"><span class="pre">field_weights</span></code></a> can
be learned, by specifing these either in the <strong>fields</strong> argument or the <strong>learn_field_weights</strong> argument of the
EMComposition’s constructor, as detailed below. Learning field_weights implements a function comparable to the learning
in an attention head of the <a class="reference external" href="https://arxiv.org/abs/1706.03762">Transformer</a> architecture, although at present the
field can only be scalar values rather than vectors or matrices, and it cannot receive input. These capabilities will
be added in the future.</p>
<p>The following arguments of the EMComposition’s constructor can be used to configure learning:</p>
<ul class="simple">
<li><p><strong>enable_learning</strong>: specifies whether any learning is enabled for the EMComposition.  If False,
no learning occurs; ` if True, then both error backpropagation and learning of <a class="reference internal" href="#psyneulink.library.compositions.emcomposition.EMComposition.field_weights" title="psyneulink.library.compositions.emcomposition.EMComposition.field_weights"><code class="xref any py py-attr docutils literal notranslate"><span class="pre">field_weights</span></code></a> can occur. If <strong>enable_learning</strong> is True, <strong>use_gating_for_weighting</strong>
must be False (see <a class="reference internal" href="#emcomposition-gating-for-weighting"><span class="std std-ref">note</span></a>).</p></li>
</ul>
<ul class="simple" id="emcomposition-target-fields">
<li><p><strong>target_fields</strong>: specifies which <a class="reference internal" href="#psyneulink.library.compositions.emcomposition.EMComposition.retrieved_nodes" title="psyneulink.library.compositions.emcomposition.EMComposition.retrieved_nodes"><code class="xref any py py-attr docutils literal notranslate"><span class="pre">retrieved_nodes</span></code></a> are used to compute
errors, and propagate these back through the EMComposition to its <a class="reference internal" href="#psyneulink.library.compositions.emcomposition.EMComposition.query_input_nodes" title="psyneulink.library.compositions.emcomposition.EMComposition.query_input_nodes"><code class="xref any py py-attr docutils literal notranslate"><span class="pre">query</span></code></a> and
<a class="reference internal" href="#psyneulink.library.compositions.emcomposition.EMComposition.value_input_nodes" title="psyneulink.library.compositions.emcomposition.EMComposition.value_input_nodes"><code class="xref any py py-attr docutils literal notranslate"><span class="pre">value_input_nodes</span></code></a>. If this is None (the default), all <a class="reference internal" href="#psyneulink.library.compositions.emcomposition.EMComposition.retrieved_nodes" title="psyneulink.library.compositions.emcomposition.EMComposition.retrieved_nodes"><code class="xref any py py-attr docutils literal notranslate"><span class="pre">retrieved_nodes</span></code></a> are used;  if it is a list or tuple, then it must have the same number of entries
as there are fields, and each entry must be a boolean specifying whether the corresponding <a class="reference internal" href="#psyneulink.library.compositions.emcomposition.EMComposition.retrieved_nodes" title="psyneulink.library.compositions.emcomposition.EMComposition.retrieved_nodes"><code class="xref any py py-attr docutils literal notranslate"><span class="pre">retrieved_nodes</span></code></a> participate in learning, and errors are computed only for those nodes. This can
also be specified in a dict for the <strong>fields</strong> argument (see <a class="reference internal" href="#emcomposition-field-specification-dict"><span class="std std-ref">fields</span></a>).</p></li>
</ul>
<ul class="simple" id="emcomposition-field-weights-learning">
<li><p><strong>learn_field_weights</strong>: specifies which field_weights are subject to learning, and optionally the <a class="reference internal" href="#psyneulink.library.compositions.emcomposition.EMComposition.learning_rate" title="psyneulink.library.compositions.emcomposition.EMComposition.learning_rate"><code class="xref any py py-attr docutils literal notranslate"><span class="pre">learning_rate</span></code></a> for each; this can also be specified in a dict for the <strong>fields</strong> argument (see
<a class="reference internal" href="#emcomposition-field-specification-dict"><span class="std std-ref">fields</span></a>). The following specfications can be used:</p>
<ul>
<li><p><em>None</em>: all field_weights are subject to learning, and the <a class="reference internal" href="#psyneulink.library.compositions.emcomposition.EMComposition.learning_rate" title="psyneulink.library.compositions.emcomposition.EMComposition.learning_rate"><code class="xref any py py-attr docutils literal notranslate"><span class="pre">learning_rate</span></code></a> for the
EMComposition is used as the learning_rate for all field_weights.</p></li>
<li><p><em>bool</em>: If True, all field_weights are subject to learning, and the <a class="reference internal" href="#psyneulink.library.compositions.emcomposition.EMComposition.learning_rate" title="psyneulink.library.compositions.emcomposition.EMComposition.learning_rate"><code class="xref any py py-attr docutils literal notranslate"><span class="pre">learning_rate</span></code></a>
for the EMComposition is used as the learning rate for all field_weights; if False, no field_weights are
subject to learning, regardless of <a class="reference internal" href="#psyneulink.library.compositions.emcomposition.EMComposition.enable_learning" title="psyneulink.library.compositions.emcomposition.EMComposition.enable_learning"><code class="xref any py py-attr docutils literal notranslate"><span class="pre">enable_learning</span></code></a>.</p></li>
<li><p><em>list</em> or <em>tuple</em>: must be the same length as the number of fields specified in the memory_template, and each entry
must be either True, False or a positive scalar value.  If True, the corresponding field_weight is subject to
learning and the <a class="reference internal" href="#psyneulink.library.compositions.emcomposition.EMComposition.learning_rate" title="psyneulink.library.compositions.emcomposition.EMComposition.learning_rate"><code class="xref any py py-attr docutils literal notranslate"><span class="pre">learning_rate</span></code></a> for the EMComposition is used to specify the
<a class="reference internal" href="#learning">learning</a> rate for that field; if False, the corresponding field_weight is not subject to learning; if a scalar
value is specified, it is used as the <a class="reference internal" href="KohonenMechanism.html#psyneulink.library.components.mechanisms.processing.transfer.kohonenmechanism.KohonenMechanism.learning_rate" title="psyneulink.library.components.mechanisms.processing.transfer.kohonenmechanism.KohonenMechanism.learning_rate"><code class="xref any py py-attr docutils literal notranslate"><span class="pre">learning_rate</span></code></a> for that field.</p></li>
</ul>
</li>
<li><p><strong>learning_rate</strong>: specifies the learning_rate for any <a class="reference internal" href="#psyneulink.library.compositions.emcomposition.EMComposition.field_weights" title="psyneulink.library.compositions.emcomposition.EMComposition.field_weights"><code class="xref any py py-attr docutils literal notranslate"><span class="pre">field_weights</span></code></a> for which a
learning_rate is not individually specified in the <strong>learn_field_weights</strong> argument (see above).</p></li>
</ul>
</section>
</section>
<section id="structure">
<span id="emcomposition-structure"></span><h2>Structure<a class="headerlink" href="#structure" title="Permalink to this headline">¶</a></h2>
<section id="input">
<span id="emcomposition-input"></span><h3><em>Input</em><a class="headerlink" href="#input" title="Permalink to this headline">¶</a></h3>
<p>The inputs corresponding to each key and value field are represented as <a class="reference internal" href="Composition.html#psyneulink.core.compositions.composition.NodeRole.INPUT" title="psyneulink.core.compositions.composition.NodeRole.INPUT"><code class="xref any py py-attr docutils literal notranslate"><span class="pre">INPUT</span></code></a> <a class="reference internal" href="Composition.html#composition-nodes"><span class="std std-ref">Nodes</span></a> of the EMComposition, listed in its <a class="reference internal" href="#psyneulink.library.compositions.emcomposition.EMComposition.query_input_nodes" title="psyneulink.library.compositions.emcomposition.EMComposition.query_input_nodes"><code class="xref any py py-attr docutils literal notranslate"><span class="pre">query_input_nodes</span></code></a>
and <a class="reference internal" href="#psyneulink.library.compositions.emcomposition.EMComposition.value_input_nodes" title="psyneulink.library.compositions.emcomposition.EMComposition.value_input_nodes"><code class="xref any py py-attr docutils literal notranslate"><span class="pre">value_input_nodes</span></code></a> attributes, respectively,</p>
</section>
<section id="memory">
<span id="emcomposition-memory-structure"></span><h3><em>Memory</em><a class="headerlink" href="#memory" title="Permalink to this headline">¶</a></h3>
<p>The <a class="reference internal" href="#psyneulink.library.compositions.emcomposition.EMComposition.memory" title="psyneulink.library.compositions.emcomposition.EMComposition.memory"><code class="xref any py py-attr docutils literal notranslate"><span class="pre">memory</span></code></a> attribute contains a record of the entries in the EMComposition’s memory. This
is in the form of a 3d array, in which rows (axis 0) are entries, columns (axis 1) are fields, and items (axis 2) are
the values of an entry in a given field.  The number of fields is determined by the <a class="reference internal" href="#emcomposition-memory-template"><span class="std std-ref">memory_template</span></a> argument of the EMComposition’s constructor, and the number of entries is determined
by the <a class="reference internal" href="#emcomposition-memory-capacity"><span class="std std-ref">memory_capacity</span></a> argument.  Information about the fields is stored in the
<a class="reference internal" href="#psyneulink.library.compositions.emcomposition.EMComposition.fields" title="psyneulink.library.compositions.emcomposition.EMComposition.fields"><code class="xref any py py-attr docutils literal notranslate"><span class="pre">fields</span></code></a> attribute, which is a list of <code class="xref any docutils literal notranslate"><span class="pre">Field</span></code> objects containing information about the nodes
and values associated with each field.</p>
<blockquote>
<div><div class="technical-note docutils container" id="emcomposition-memory-storage">
<p>The memories are actually stored in the <a class="reference internal" href="MappingProjection.html#psyneulink.core.components.projections.pathway.mappingprojection.MappingProjection.matrix" title="psyneulink.core.components.projections.pathway.mappingprojection.MappingProjection.matrix"><code class="xref any py py-attr docutils literal notranslate"><span class="pre">matrix</span></code></a> parameters of the`MappingProjections`
from the <a class="reference internal" href="#psyneulink.library.compositions.emcomposition.EMComposition.combined_matches_node" title="psyneulink.library.compositions.emcomposition.EMComposition.combined_matches_node"><code class="xref any py py-attr docutils literal notranslate"><span class="pre">combined_matches_node</span></code></a> to each of the <a class="reference internal" href="#psyneulink.library.compositions.emcomposition.EMComposition.retrieved_nodes" title="psyneulink.library.compositions.emcomposition.EMComposition.retrieved_nodes"><code class="xref any py py-attr docutils literal notranslate"><span class="pre">retrieved_nodes</span></code></a>. Memories associated with each key are also stored (in inverted form) in the
<a class="reference internal" href="MappingProjection.html#psyneulink.core.components.projections.pathway.mappingprojection.MappingProjection.matrix" title="psyneulink.core.components.projections.pathway.mappingprojection.MappingProjection.matrix"><code class="xref any py py-attr docutils literal notranslate"><span class="pre">matrix</span></code></a> parameters of the <a class="reference internal" href="MappingProjection.html"><span class="doc">MappingProjection</span></a> from the
<a class="reference internal" href="#psyneulink.library.compositions.emcomposition.EMComposition.query_input_nodes" title="psyneulink.library.compositions.emcomposition.EMComposition.query_input_nodes"><code class="xref any py py-attr docutils literal notranslate"><span class="pre">query_input_nodes</span></code></a> to each of the corresponding <a class="reference internal" href="#psyneulink.library.compositions.emcomposition.EMComposition.match_nodes" title="psyneulink.library.compositions.emcomposition.EMComposition.match_nodes"><code class="xref any py py-attr docutils literal notranslate"><span class="pre">match_nodes</span></code></a>. This is done so that the match of each query to the keys in memory for the
corresponding field can be computed simply by passing the input for each query through the Projection (which
computes the distance of the input with the Projection’s <a class="reference internal" href="MappingProjection.html#psyneulink.core.components.projections.pathway.mappingprojection.MappingProjection.matrix" title="psyneulink.core.components.projections.pathway.mappingprojection.MappingProjection.matrix"><code class="xref any py py-attr docutils literal notranslate"><span class="pre">matrix</span></code></a> parameter) to the
corresponding match_node; and, similarly, retrieivals can be computed by passing the softmax distributions for
each field computed in the <a class="reference internal" href="#psyneulink.library.compositions.emcomposition.EMComposition.combined_matches_node" title="psyneulink.library.compositions.emcomposition.EMComposition.combined_matches_node"><code class="xref any py py-attr docutils literal notranslate"><span class="pre">combined_matches_node</span></code></a> through its Projection
to each <a class="reference internal" href="#psyneulink.library.compositions.emcomposition.EMComposition.retrieved_nodes" title="psyneulink.library.compositions.emcomposition.EMComposition.retrieved_nodes"><code class="xref any py py-attr docutils literal notranslate"><span class="pre">retrieved_node</span></code></a> (which are inverted versions of the matrices of the
<a class="reference internal" href="MappingProjection.html"><span class="doc">MappingProjections</span></a> from the <a class="reference internal" href="#psyneulink.library.compositions.emcomposition.EMComposition.query_input_nodes" title="psyneulink.library.compositions.emcomposition.EMComposition.query_input_nodes"><code class="xref any py py-attr docutils literal notranslate"><span class="pre">query_input_nodes</span></code></a> to each
of the corresponding <a class="reference internal" href="#psyneulink.library.compositions.emcomposition.EMComposition.match_nodes" title="psyneulink.library.compositions.emcomposition.EMComposition.match_nodes"><code class="xref any py py-attr docutils literal notranslate"><span class="pre">match_nodes</span></code></a>), to compute the distance of the weighted
softmax over entries with the corresponding field of each entry that yields the retreieved value for each field.</p>
</div>
</div></blockquote>
</section>
<section id="output">
<span id="emcomposition-output"></span><h3><em>Output</em><a class="headerlink" href="#output" title="Permalink to this headline">¶</a></h3>
<p>The outputs corresponding to retrieved value for each field are represented as <a class="reference internal" href="Composition.html#psyneulink.core.compositions.composition.NodeRole.INPUT" title="psyneulink.core.compositions.composition.NodeRole.INPUT"><code class="xref any py py-attr docutils literal notranslate"><span class="pre">OUTPUT</span></code></a> <a class="reference internal" href="Composition.html#composition-nodes"><span class="std std-ref">Nodes</span></a> of the EMComposition, listed in its <a class="reference internal" href="#psyneulink.library.compositions.emcomposition.EMComposition.retrieved_nodes" title="psyneulink.library.compositions.emcomposition.EMComposition.retrieved_nodes"><code class="xref any py py-attr docutils literal notranslate"><span class="pre">retrieved_nodes</span></code></a> attribute.</p>
</section>
</section>
<section id="execution">
<span id="emcomposition-execution"></span><h2>Execution<a class="headerlink" href="#execution" title="Permalink to this headline">¶</a></h2>
<p>The arguments of the <a class="reference internal" href="Composition.html#psyneulink.core.compositions.composition.Composition.run" title="psyneulink.core.compositions.composition.Composition.run"><code class="xref any py py-meth docutils literal notranslate"><span class="pre">run</span></code></a> , <a class="reference internal" href="Composition.html#psyneulink.core.compositions.composition.Composition.learn" title="psyneulink.core.compositions.composition.Composition.learn"><code class="xref any py py-meth docutils literal notranslate"><span class="pre">learn</span></code></a> and <a class="reference internal" href="Composition.html#psyneulink.core.compositions.composition.Composition.execute" title="psyneulink.core.compositions.composition.Composition.execute"><code class="xref any py py-meth docutils literal notranslate"><span class="pre">Composition.execute</span></code></a>
methods are the same as those of a <a class="reference internal" href="Composition.html"><span class="doc">Composition</span></a>, and they can be passed any of the arguments valid for
an <a class="reference internal" href="AutodiffComposition.html"><span class="doc">AutodiffComposition</span></a>.  The details of how the EMComposition executes are described below.</p>
<section id="processing">
<span id="emcomposition-processing"></span><h3><em>Processing</em><a class="headerlink" href="#processing" title="Permalink to this headline">¶</a></h3>
<p>When the EMComposition is executed, the following sequence of operations occur
(also see <a class="reference internal" href="#emcomposition-example-fig"><span class="std std-ref">figure</span></a>):</p>
<ul class="simple">
<li><p><strong>Input</strong>.  The inputs to the EMComposition are provided to the <a class="reference internal" href="#psyneulink.library.compositions.emcomposition.EMComposition.query_input_nodes" title="psyneulink.library.compositions.emcomposition.EMComposition.query_input_nodes"><code class="xref any py py-attr docutils literal notranslate"><span class="pre">query_input_nodes</span></code></a>
and <a class="reference internal" href="#psyneulink.library.compositions.emcomposition.EMComposition.value_input_nodes" title="psyneulink.library.compositions.emcomposition.EMComposition.value_input_nodes"><code class="xref any py py-attr docutils literal notranslate"><span class="pre">value_input_nodes</span></code></a>.  The former are used for matching to the corresponding
<a class="reference internal" href="#emcomposition-entries-and-fields"><span class="std std-ref">fields</span></a> of the <a class="reference internal" href="#psyneulink.library.compositions.emcomposition.EMComposition.memory" title="psyneulink.library.compositions.emcomposition.EMComposition.memory"><code class="xref any py py-attr docutils literal notranslate"><span class="pre">memory</span></code></a>, while the latter are retrieved
but not used for matching.</p></li>
<li><p><strong>Concatenation</strong>. By default, the input to every <a class="reference internal" href="#psyneulink.library.compositions.emcomposition.EMComposition.query_input_nodes" title="psyneulink.library.compositions.emcomposition.EMComposition.query_input_nodes"><code class="xref any py py-attr docutils literal notranslate"><span class="pre">query_input_node</span></code></a> is passed to a
to its own <a class="reference internal" href="#psyneulink.library.compositions.emcomposition.EMComposition.match_nodes" title="psyneulink.library.compositions.emcomposition.EMComposition.match_nodes"><code class="xref any py py-attr docutils literal notranslate"><span class="pre">match_node</span></code></a> through a <a class="reference internal" href="MappingProjection.html"><span class="doc">MappingProjection</span></a> that computes its
distance with the corresponding field of each entry in <a class="reference internal" href="#psyneulink.library.compositions.emcomposition.EMComposition.memory" title="psyneulink.library.compositions.emcomposition.EMComposition.memory"><code class="xref any py py-attr docutils literal notranslate"><span class="pre">memory</span></code></a>.  In this way, each
match is normalized so that, absent <a class="reference internal" href="#emcomposition-field-weights"><span class="std std-ref">field_weighting</span></a>, all keys contribute equally to
retrieval irrespective of relative differences in the norms of the queries or the keys in memory. However, if the
<a class="reference internal" href="#psyneulink.library.compositions.emcomposition.EMComposition.field_weights" title="psyneulink.library.compositions.emcomposition.EMComposition.field_weights"><code class="xref any py py-attr docutils literal notranslate"><span class="pre">field_weights</span></code></a> are the same for all <a class="reference internal" href="#emcomposition-field-weights"><span class="std std-ref">keys</span></a> and
<a class="reference internal" href="#psyneulink.library.compositions.emcomposition.EMComposition.normalize_memories" title="psyneulink.library.compositions.emcomposition.EMComposition.normalize_memories"><code class="xref any py py-attr docutils literal notranslate"><span class="pre">normalize_memories</span></code></a> is True, then the inputs provided to the <a class="reference internal" href="#psyneulink.library.compositions.emcomposition.EMComposition.query_input_nodes" title="psyneulink.library.compositions.emcomposition.EMComposition.query_input_nodes"><code class="xref any py py-attr docutils literal notranslate"><span class="pre">query_input_nodes</span></code></a> are concatenated into a single vector (in the
<a class="reference internal" href="#psyneulink.library.compositions.emcomposition.EMComposition.concatenate_queries_node" title="psyneulink.library.compositions.emcomposition.EMComposition.concatenate_queries_node"><code class="xref any py py-attr docutils literal notranslate"><span class="pre">concatenate_queries_node</span></code></a>), which is passed to a single <a class="reference internal" href="#psyneulink.library.compositions.emcomposition.EMComposition.match_nodes" title="psyneulink.library.compositions.emcomposition.EMComposition.match_nodes"><code class="xref any py py-attr docutils literal notranslate"><span class="pre">match_node</span></code></a>.  This may be more computationally efficient than passing each query through its own
<a class="reference internal" href="#psyneulink.library.compositions.emcomposition.EMComposition.match_nodes" title="psyneulink.library.compositions.emcomposition.EMComposition.match_nodes"><code class="xref any py py-attr docutils literal notranslate"><span class="pre">match_node</span></code></a>,
however it will not necessarily produce the same results as passing each query through its own <a class="reference internal" href="#psyneulink.library.compositions.emcomposition.EMComposition.match_nodes" title="psyneulink.library.compositions.emcomposition.EMComposition.match_nodes"><code class="xref any py py-attr docutils literal notranslate"><span class="pre">match_node</span></code></a> (see <code class="xref any docutils literal notranslate"><span class="pre">concatenate</span> <span class="pre">keys</span></code> for additional information).</p></li>
</ul>
<ul class="simple" id="emcomposition-distance-computation">
<li><p><strong>Match memories by field</strong>. The values of each <a class="reference internal" href="#psyneulink.library.compositions.emcomposition.EMComposition.query_input_nodes" title="psyneulink.library.compositions.emcomposition.EMComposition.query_input_nodes"><code class="xref any py py-attr docutils literal notranslate"><span class="pre">query_input_node</span></code></a>
(or the <a class="reference internal" href="#psyneulink.library.compositions.emcomposition.EMComposition.concatenate_queries_node" title="psyneulink.library.compositions.emcomposition.EMComposition.concatenate_queries_node"><code class="xref any py py-attr docutils literal notranslate"><span class="pre">concatenate_queries_node</span></code></a> if <a class="reference internal" href="#emcomposition-concatenate-queries"><span class="std std-ref">concatenate_queries</span></a> attribute is True) are passed through a <a class="reference internal" href="MappingProjection.html"><span class="doc">MappingProjection</span></a> that
computes the distance between the corresponding input (query) and each memory (key) for the corresponding field,
the result of which is possed to the corresponding <a class="reference internal" href="#psyneulink.library.compositions.emcomposition.EMComposition.match_nodes" title="psyneulink.library.compositions.emcomposition.EMComposition.match_nodes"><code class="xref any py py-attr docutils literal notranslate"><span class="pre">match_node</span></code></a>. By default, the distance
is computed as the normalized dot product (i.e., between the normalized query vector and the normalized key for the
corresponding <a class="reference internal" href="#emcomposition-entries-and-fields"><span class="std std-ref">field</span></a>, that is comparable to using cosine similarity). However,
if <a class="reference internal" href="#psyneulink.library.compositions.emcomposition.EMComposition.normalize_memories" title="psyneulink.library.compositions.emcomposition.EMComposition.normalize_memories"><code class="xref any py py-attr docutils literal notranslate"><span class="pre">normalize_memories</span></code></a> is set to False, just the raw dot product is computed.
The distance can also be customized by specifying a different <code class="xref any docutils literal notranslate"><span class="pre">function</span></code> for the
<a class="reference internal" href="MappingProjection.html"><span class="doc">MappingProjection</span></a> to the <a class="reference internal" href="#psyneulink.library.compositions.emcomposition.EMComposition.match_nodes" title="psyneulink.library.compositions.emcomposition.EMComposition.match_nodes"><code class="xref any py py-attr docutils literal notranslate"><span class="pre">match_node</span></code></a>. The result is assigned as the <a class="reference internal" href="Mechanism.html#psyneulink.core.components.mechanisms.mechanism.Mechanism_Base.value" title="psyneulink.core.components.mechanisms.mechanism.Mechanism_Base.value"><code class="xref any py py-attr docutils literal notranslate"><span class="pre">value</span></code></a> of the corresponding <a class="reference internal" href="#psyneulink.library.compositions.emcomposition.EMComposition.match_nodes" title="psyneulink.library.compositions.emcomposition.EMComposition.match_nodes"><code class="xref any py py-attr docutils literal notranslate"><span class="pre">match_node</span></code></a>.</p></li>
</ul>
<ul id="emcomposition-field-weighting">
<li><p><strong>Weight distances</strong>. If <a class="reference internal" href="#emcomposition-field-weights"><span class="std std-ref">field weights</span></a> are specified, then the distance computed
by the <a class="reference internal" href="MappingProjection.html"><span class="doc">MappingProjection</span></a> to each <a class="reference internal" href="#psyneulink.library.compositions.emcomposition.EMComposition.match_nodes" title="psyneulink.library.compositions.emcomposition.EMComposition.match_nodes"><code class="xref any py py-attr docutils literal notranslate"><span class="pre">match_node</span></code></a> is multiplied by the corresponding
<a class="reference internal" href="#psyneulink.library.compositions.emcomposition.EMComposition.field_weights" title="psyneulink.library.compositions.emcomposition.EMComposition.field_weights"><code class="xref any py py-attr docutils literal notranslate"><span class="pre">field_weight</span></code></a> using the <a class="reference internal" href="#psyneulink.library.compositions.emcomposition.EMComposition.field_weight_nodes" title="psyneulink.library.compositions.emcomposition.EMComposition.field_weight_nodes"><code class="xref any py py-attr docutils literal notranslate"><span class="pre">field_weight_node</span></code></a>.
By default (if <code class="xref any docutils literal notranslate"><span class="pre">use_gating_for_weighting</span></code> is False), this is done using
the <a class="reference internal" href="#psyneulink.library.compositions.emcomposition.EMComposition.weighted_match_nodes" title="psyneulink.library.compositions.emcomposition.EMComposition.weighted_match_nodes"><code class="xref any py py-attr docutils literal notranslate"><span class="pre">weighted_match_nodes</span></code></a>, each of which receives a Projection from a
<a class="reference internal" href="#psyneulink.library.compositions.emcomposition.EMComposition.match_nodes" title="psyneulink.library.compositions.emcomposition.EMComposition.match_nodes"><code class="xref any py py-attr docutils literal notranslate"><span class="pre">match_node</span></code></a> and the corresponding <a class="reference internal" href="#psyneulink.library.compositions.emcomposition.EMComposition.field_weight_nodes" title="psyneulink.library.compositions.emcomposition.EMComposition.field_weight_nodes"><code class="xref any py py-attr docutils literal notranslate"><span class="pre">field_weight_node</span></code></a>
and multiplies them to produce the weighted distance for that field as its output.  However, if
<code class="xref any docutils literal notranslate"><span class="pre">use_gating_for_weighting</span></code> is True, the <a class="reference internal" href="#psyneulink.library.compositions.emcomposition.EMComposition.field_weight_nodes" title="psyneulink.library.compositions.emcomposition.EMComposition.field_weight_nodes"><code class="xref any py py-attr docutils literal notranslate"><span class="pre">field_weight_nodes</span></code></a> are implemented
as <a class="reference internal" href="GatingMechanism.html"><span class="doc">GatingMechanisms</span></a>, each of which uses its <a class="reference internal" href="#psyneulink.library.compositions.emcomposition.EMComposition.field_weights" title="psyneulink.library.compositions.emcomposition.EMComposition.field_weights"><code class="xref any py py-attr docutils literal notranslate"><span class="pre">field</span> <span class="pre">weight</span></code></a> as a
<a class="reference internal" href="GatingSignal.html"><span class="doc">GatingSignal</span></a> to output gate (i.e., multiplicatively modulate the output of) the corresponding
<a class="reference internal" href="#psyneulink.library.compositions.emcomposition.EMComposition.match_nodes" title="psyneulink.library.compositions.emcomposition.EMComposition.match_nodes"><code class="xref any py py-attr docutils literal notranslate"><span class="pre">match_node</span></code></a>. In this case, the <a class="reference internal" href="#psyneulink.library.compositions.emcomposition.EMComposition.weighted_match_nodes" title="psyneulink.library.compositions.emcomposition.EMComposition.weighted_match_nodes"><code class="xref any py py-attr docutils literal notranslate"><span class="pre">weighted_match_nodes</span></code></a> are not implemented,
and the output of the <a class="reference internal" href="#psyneulink.library.compositions.emcomposition.EMComposition.match_nodes" title="psyneulink.library.compositions.emcomposition.EMComposition.match_nodes"><code class="xref any py py-attr docutils literal notranslate"><span class="pre">match_node</span></code></a> is passed directly to the <a class="reference internal" href="#psyneulink.library.compositions.emcomposition.EMComposition.combined_matches_node" title="psyneulink.library.compositions.emcomposition.EMComposition.combined_matches_node"><code class="xref any py py-attr docutils literal notranslate"><span class="pre">combined_matches_node</span></code></a>.</p>
<div class="admonition note" id="emcomposition-gating-for-weighting">
<p class="admonition-title">Note</p>
<p>Setting <code class="xref any docutils literal notranslate"><span class="pre">use_gating_for_weighting</span></code> to True reduces the size and
complexity of the EMComposition, by eliminating the <a class="reference internal" href="#psyneulink.library.compositions.emcomposition.EMComposition.weighted_match_nodes" title="psyneulink.library.compositions.emcomposition.EMComposition.weighted_match_nodes"><code class="xref any py py-attr docutils literal notranslate"><span class="pre">weighted_match_nodes</span></code></a>.
However, doing to precludes the ability to learn the <a class="reference internal" href="#psyneulink.library.compositions.emcomposition.EMComposition.field_weights" title="psyneulink.library.compositions.emcomposition.EMComposition.field_weights"><code class="xref any py py-attr docutils literal notranslate"><span class="pre">field_weights</span></code></a>,
since <a class="reference internal" href="GatingSignal.html"><span class="doc">GatingSignals</span></a> are  <code class="xref any docutils literal notranslate"><span class="pre">ModulatorySignal&gt;</span></code> that cannot be learned.  If learning is required,
then <code class="xref any docutils literal notranslate"><span class="pre">use_gating_for_weighting</span></code> should be set to False.</p>
</div>
</li>
<li><p><strong>Combine distances</strong>.  If <a class="reference internal" href="#emcomposition-field-weights"><span class="std std-ref">field weights</span></a> are used to specify more than one <a class="reference internal" href="#emcomposition-fields"><span class="std std-ref">key field</span></a>, then the (weighted) distances computed for each field (see above) are summed across fields
by the <a class="reference internal" href="#psyneulink.library.compositions.emcomposition.EMComposition.combined_matches_node" title="psyneulink.library.compositions.emcomposition.EMComposition.combined_matches_node"><code class="xref any py py-attr docutils literal notranslate"><span class="pre">combined_matches_node</span></code></a>, before being passed to the <a class="reference internal" href="#psyneulink.library.compositions.emcomposition.EMComposition.softmax_node" title="psyneulink.library.compositions.emcomposition.EMComposition.softmax_node"><code class="xref any py py-attr docutils literal notranslate"><span class="pre">softmax_node</span></code></a>. If only one key field is specified, then the output of the <a class="reference internal" href="#psyneulink.library.compositions.emcomposition.EMComposition.match_nodes" title="psyneulink.library.compositions.emcomposition.EMComposition.match_nodes"><code class="xref any py py-attr docutils literal notranslate"><span class="pre">match_node</span></code></a> is passed directly to the <a class="reference internal" href="#psyneulink.library.compositions.emcomposition.EMComposition.softmax_node" title="psyneulink.library.compositions.emcomposition.EMComposition.softmax_node"><code class="xref any py py-attr docutils literal notranslate"><span class="pre">softmax_node</span></code></a>.</p></li>
<li><p><strong>Softmax normalize distances</strong>. The distances, passed either from the <a class="reference internal" href="#psyneulink.library.compositions.emcomposition.EMComposition.combined_matches_node" title="psyneulink.library.compositions.emcomposition.EMComposition.combined_matches_node"><code class="xref any py py-attr docutils literal notranslate"><span class="pre">combined_matches_node</span></code></a>, or directly from the <a class="reference internal" href="#psyneulink.library.compositions.emcomposition.EMComposition.match_nodes" title="psyneulink.library.compositions.emcomposition.EMComposition.match_nodes"><code class="xref any py py-attr docutils literal notranslate"><span class="pre">match_node</span></code></a> if there is
only one key field, are passed to the <a class="reference internal" href="#psyneulink.library.compositions.emcomposition.EMComposition.softmax_node" title="psyneulink.library.compositions.emcomposition.EMComposition.softmax_node"><code class="xref any py py-attr docutils literal notranslate"><span class="pre">softmax_node</span></code></a>, which applies the <a class="reference internal" href="TransferFunctions.html#psyneulink.core.components.functions.transferfunctions.SoftMax" title="psyneulink.core.components.functions.transferfunctions.SoftMax"><code class="xref any py py-class docutils literal notranslate"><span class="pre">SoftMax</span></code></a>
Function, which generates the softmax distribution used to retrieve entries from <a class="reference internal" href="#psyneulink.library.compositions.emcomposition.EMComposition.memory" title="psyneulink.library.compositions.emcomposition.EMComposition.memory"><code class="xref any py py-attr docutils literal notranslate"><span class="pre">memory</span></code></a>.
If a numerical value is specified for <a class="reference internal" href="#psyneulink.library.compositions.emcomposition.EMComposition.softmax_gain" title="psyneulink.library.compositions.emcomposition.EMComposition.softmax_gain"><code class="xref any py py-attr docutils literal notranslate"><span class="pre">softmax_gain</span></code></a>, that is used as the gain (inverse
temperature) for the SoftMax Function; if <em>ADAPTIVE</em> is specified, then the <a class="reference internal" href="TransferFunctions.html#psyneulink.core.components.functions.transferfunctions.SoftMax.adapt_gain" title="psyneulink.core.components.functions.transferfunctions.SoftMax.adapt_gain"><code class="xref any py py-meth docutils literal notranslate"><span class="pre">SoftMax.adapt_gain</span></code></a> function is used
to adaptively set the gain based on the summed distance (i.e., the output of the <a class="reference internal" href="#psyneulink.library.compositions.emcomposition.EMComposition.combined_matches_node" title="psyneulink.library.compositions.emcomposition.EMComposition.combined_matches_node"><code class="xref any py py-attr docutils literal notranslate"><span class="pre">combined_matches_node</span></code></a>;  if <em>CONTROL</em> is specified, then the summed distance is monitored by a
<a class="reference internal" href="ControlMechanism.html"><span class="doc">ControlMechanism</span></a> that uses the <code class="xref any docutils literal notranslate"><span class="pre">adapt_gain</span></code> method of the <a class="reference internal" href="TransferFunctions.html#psyneulink.core.components.functions.transferfunctions.SoftMax" title="psyneulink.core.components.functions.transferfunctions.SoftMax"><code class="xref any py py-class docutils literal notranslate"><span class="pre">SoftMax</span></code></a> Function to modulate its
<code class="xref any docutils literal notranslate"><span class="pre">gain</span></code> parameter; if None is specified, the default value of the <code class="xref any docutils literal notranslate"><span class="pre">Softmax</span></code> Function is used as the
<code class="xref any docutils literal notranslate"><span class="pre">gain</span></code> parameter (see <a class="reference internal" href="#emcomposition-softmax-gain"><span class="std std-ref">Softmax_Gain</span></a> for additional  details).</p></li>
</ul>
<ul id="emcomposition-retreived-values">
<li><p><strong>Retrieve values by field</strong>. The vector of softmax weights for each memory generated by the <a class="reference internal" href="#psyneulink.library.compositions.emcomposition.EMComposition.softmax_node" title="psyneulink.library.compositions.emcomposition.EMComposition.softmax_node"><code class="xref any py py-attr docutils literal notranslate"><span class="pre">softmax_node</span></code></a> is passed through the Projections to the each of the <a class="reference internal" href="#psyneulink.library.compositions.emcomposition.EMComposition.retrieved_nodes" title="psyneulink.library.compositions.emcomposition.EMComposition.retrieved_nodes"><code class="xref any py py-attr docutils literal notranslate"><span class="pre">retrieved_nodes</span></code></a> to compute the retrieved value for each field, which is assigned as the value
of the corresponding <a class="reference internal" href="#psyneulink.library.compositions.emcomposition.EMComposition.retrieved_nodes" title="psyneulink.library.compositions.emcomposition.EMComposition.retrieved_nodes"><code class="xref any py py-attr docutils literal notranslate"><span class="pre">retrieved_node</span></code></a>.</p></li>
<li><p><strong>Decay memories</strong>.  If <code class="xref any docutils literal notranslate"><span class="pre">memory_decay</span></code> is True, then each of the memories is decayed
by the amount specified in <a class="reference internal" href="#psyneulink.library.compositions.emcomposition.EMComposition.memory_decay_rate" title="psyneulink.library.compositions.emcomposition.EMComposition.memory_decay_rate"><code class="xref any py py-attr docutils literal notranslate"><span class="pre">memory_decay_rate</span></code></a>.</p>
<blockquote>
<div><div class="technical-note docutils container">
<p>This is done by multiplying the <a class="reference internal" href="MappingProjection.html#psyneulink.core.components.projections.pathway.mappingprojection.MappingProjection.matrix" title="psyneulink.core.components.projections.pathway.mappingprojection.MappingProjection.matrix"><code class="xref any py py-attr docutils literal notranslate"><span class="pre">matrix</span></code></a> parameter of the <a class="reference internal" href="MappingProjection.html"><span class="doc">MappingProjection</span></a> from
the <a class="reference internal" href="#psyneulink.library.compositions.emcomposition.EMComposition.combined_matches_node" title="psyneulink.library.compositions.emcomposition.EMComposition.combined_matches_node"><code class="xref any py py-attr docutils literal notranslate"><span class="pre">combined_matches_node</span></code></a> to each of the <a class="reference internal" href="#psyneulink.library.compositions.emcomposition.EMComposition.retrieved_nodes" title="psyneulink.library.compositions.emcomposition.EMComposition.retrieved_nodes"><code class="xref any py py-attr docutils literal notranslate"><span class="pre">retrieved_nodes</span></code></a>, as well as the <a class="reference internal" href="MappingProjection.html#psyneulink.core.components.projections.pathway.mappingprojection.MappingProjection.matrix" title="psyneulink.core.components.projections.pathway.mappingprojection.MappingProjection.matrix"><code class="xref any py py-attr docutils literal notranslate"><span class="pre">matrix</span></code></a> parameter of the
<a class="reference internal" href="MappingProjection.html"><span class="doc">MappingProjection</span></a> from each <a class="reference internal" href="#psyneulink.library.compositions.emcomposition.EMComposition.query_input_nodes" title="psyneulink.library.compositions.emcomposition.EMComposition.query_input_nodes"><code class="xref any py py-attr docutils literal notranslate"><span class="pre">query_input_node</span></code></a> to the corresponding
<a class="reference internal" href="#psyneulink.library.compositions.emcomposition.EMComposition.match_nodes" title="psyneulink.library.compositions.emcomposition.EMComposition.match_nodes"><code class="xref any py py-attr docutils literal notranslate"><span class="pre">match_node</span></code></a> by <a class="reference internal" href="#psyneulink.library.compositions.emcomposition.EMComposition.memory_decay_rate" title="psyneulink.library.compositions.emcomposition.EMComposition.memory_decay_rate"><code class="xref any py py-attr docutils literal notranslate"><span class="pre">memory_decay</span></code></a>,</p>
<blockquote>
<div><p>by 1 - <a class="reference internal" href="#psyneulink.library.compositions.emcomposition.EMComposition.memory_decay_rate" title="psyneulink.library.compositions.emcomposition.EMComposition.memory_decay_rate"><code class="xref any py py-attr docutils literal notranslate"><span class="pre">memory_decay</span></code></a>.</p>
</div></blockquote>
</div>
</div></blockquote>
</li>
</ul>
<ul id="emcomposition-storage">
<li><p><strong>Store memories</strong>. After the values have been retrieved, the <a class="reference internal" href="#psyneulink.library.compositions.emcomposition.EMComposition.storage_node" title="psyneulink.library.compositions.emcomposition.EMComposition.storage_node"><code class="xref any py py-attr docutils literal notranslate"><span class="pre">storage_node</span></code></a>
adds the inputs to each field (i.e., values in the <a class="reference internal" href="#psyneulink.library.compositions.emcomposition.EMComposition.query_input_nodes" title="psyneulink.library.compositions.emcomposition.EMComposition.query_input_nodes"><code class="xref any py py-attr docutils literal notranslate"><span class="pre">query_input_nodes</span></code></a> and
<a class="reference internal" href="#psyneulink.library.compositions.emcomposition.EMComposition.value_input_nodes" title="psyneulink.library.compositions.emcomposition.EMComposition.value_input_nodes"><code class="xref any py py-attr docutils literal notranslate"><span class="pre">value_input_nodes</span></code></a>) as a new entry in <a class="reference internal" href="#psyneulink.library.compositions.emcomposition.EMComposition.memory" title="psyneulink.library.compositions.emcomposition.EMComposition.memory"><code class="xref any py py-attr docutils literal notranslate"><span class="pre">memory</span></code></a>,
replacing the weakest one. The weakest memory is the one with the lowest norm, multipled  by its <a class="reference internal" href="#psyneulink.library.compositions.emcomposition.EMComposition.field_weights" title="psyneulink.library.compositions.emcomposition.EMComposition.field_weights"><code class="xref any py py-attr docutils literal notranslate"><span class="pre">field_weight</span></code></a> if <code class="xref any docutils literal notranslate"><span class="pre">purge_by_field_weight</span></code> is True.</p>
<blockquote>
<div><div class="technical-note docutils container">
<p>The norm of each entry is calculated by adding the input vectors to the the corresponding rows of
the <a class="reference internal" href="MappingProjection.html#psyneulink.core.components.projections.pathway.mappingprojection.MappingProjection.matrix" title="psyneulink.core.components.projections.pathway.mappingprojection.MappingProjection.matrix"><code class="xref any py py-attr docutils literal notranslate"><span class="pre">matrix</span></code></a> of the <a class="reference internal" href="MappingProjection.html"><span class="doc">MappingProjection</span></a> from the <a class="reference internal" href="#psyneulink.library.compositions.emcomposition.EMComposition.combined_matches_node" title="psyneulink.library.compositions.emcomposition.EMComposition.combined_matches_node"><code class="xref any py py-attr docutils literal notranslate"><span class="pre">combined_matches_node</span></code></a> to each of the <a class="reference internal" href="#psyneulink.library.compositions.emcomposition.EMComposition.retrieved_nodes" title="psyneulink.library.compositions.emcomposition.EMComposition.retrieved_nodes"><code class="xref any py py-attr docutils literal notranslate"><span class="pre">retrieved_nodes</span></code></a>,
as well as the <a class="reference internal" href="MappingProjection.html#psyneulink.core.components.projections.pathway.mappingprojection.MappingProjection.matrix" title="psyneulink.core.components.projections.pathway.mappingprojection.MappingProjection.matrix"><code class="xref any py py-attr docutils literal notranslate"><span class="pre">matrix</span></code></a> parameter of the <a class="reference internal" href="MappingProjection.html"><span class="doc">MappingProjection</span></a> from each
<a class="reference internal" href="#psyneulink.library.compositions.emcomposition.EMComposition.query_input_nodes" title="psyneulink.library.compositions.emcomposition.EMComposition.query_input_nodes"><code class="xref any py py-attr docutils literal notranslate"><span class="pre">query_input_node</span></code></a> to the corresponding <a class="reference internal" href="#psyneulink.library.compositions.emcomposition.EMComposition.match_nodes" title="psyneulink.library.compositions.emcomposition.EMComposition.match_nodes"><code class="xref any py py-attr docutils literal notranslate"><span class="pre">match_node</span></code></a> (see note <a class="reference internal" href="#emcomposition-memory-storage"><span class="std std-ref">above</span></a> for additional details).</p>
</div>
</div></blockquote>
</li>
</ul>
</section>
<section id="training">
<span id="emcomposition-training"></span><h3><em>Training</em><a class="headerlink" href="#training" title="Permalink to this headline">¶</a></h3>
<p>If <a class="reference internal" href="Composition.html#psyneulink.core.compositions.composition.Composition.learn" title="psyneulink.core.compositions.composition.Composition.learn"><code class="xref any py py-meth docutils literal notranslate"><span class="pre">learn</span></code></a> is called, <a class="reference internal" href="#psyneulink.library.compositions.emcomposition.EMComposition.enable_learning" title="psyneulink.library.compositions.emcomposition.EMComposition.enable_learning"><code class="xref any py py-attr docutils literal notranslate"><span class="pre">enable_learning</span></code></a> is True, then errors
will be computed for each of the <a class="reference internal" href="#psyneulink.library.compositions.emcomposition.EMComposition.retrieved_nodes" title="psyneulink.library.compositions.emcomposition.EMComposition.retrieved_nodes"><code class="xref any py py-attr docutils literal notranslate"><span class="pre">retrieved_nodes</span></code></a> that is specified for learning
(see <a class="reference internal" href="#emcomposition-learning"><span class="std std-ref">Learning</span></a> for details about specification). These errors are derived either from any
errors backprpated to the EMComposition from an outer Composition in which it is <a class="reference internal" href="Composition.html#composition-nested"><span class="std std-ref">nested</span></a>,
or locally by the difference between the <a class="reference internal" href="#psyneulink.library.compositions.emcomposition.EMComposition.retrieved_nodes" title="psyneulink.library.compositions.emcomposition.EMComposition.retrieved_nodes"><code class="xref any py py-attr docutils literal notranslate"><span class="pre">retrieved_nodes</span></code></a> and the <code class="xref any docutils literal notranslate"><span class="pre">target_nodes</span></code> that are created for each of the <a class="reference internal" href="#psyneulink.library.compositions.emcomposition.EMComposition.retrieved_nodes" title="psyneulink.library.compositions.emcomposition.EMComposition.retrieved_nodes"><code class="xref any py py-attr docutils literal notranslate"><span class="pre">retrieved_nodes</span></code></a>
that do not project to an outer Composition. These errors are then backpropagated through the EMComposition to the
<a class="reference internal" href="#psyneulink.library.compositions.emcomposition.EMComposition.query_input_nodes" title="psyneulink.library.compositions.emcomposition.EMComposition.query_input_nodes"><code class="xref any py py-attr docutils literal notranslate"><span class="pre">query_input_nodes</span></code></a> and <a class="reference internal" href="#psyneulink.library.compositions.emcomposition.EMComposition.value_input_nodes" title="psyneulink.library.compositions.emcomposition.EMComposition.value_input_nodes"><code class="xref any py py-attr docutils literal notranslate"><span class="pre">value_input_nodes</span></code></a>,
and on to any nodes that project to it from a composition in which the EMComposition is <a class="reference internal" href="Composition.html#composition-nested"><span class="std std-ref">nested</span></a>.</p>
<p>If <a class="reference internal" href="#psyneulink.library.compositions.emcomposition.EMComposition.learn_field_weights" title="psyneulink.library.compositions.emcomposition.EMComposition.learn_field_weights"><code class="xref any py py-attr docutils literal notranslate"><span class="pre">learn_field_weights</span></code></a> is also specified, then the corresponding <a class="reference internal" href="#psyneulink.library.compositions.emcomposition.EMComposition.field_weights" title="psyneulink.library.compositions.emcomposition.EMComposition.field_weights"><code class="xref any py py-attr docutils literal notranslate"><span class="pre">field_weights</span></code></a> are
modified to minimize the error passed to the EMComposition retrieved nodes that have been specified for learning,
using the <a class="reference internal" href="#psyneulink.library.compositions.emcomposition.EMComposition.learning_rate" title="psyneulink.library.compositions.emcomposition.EMComposition.learning_rate"><code class="xref any py py-attr docutils literal notranslate"><span class="pre">learning_rate</span></code></a> for them in <a class="reference internal" href="#psyneulink.library.compositions.emcomposition.EMComposition.learn_field_weights" title="psyneulink.library.compositions.emcomposition.EMComposition.learn_field_weights"><code class="xref any py py-attr docutils literal notranslate"><span class="pre">learn_field_weights</span></code></a> or the default <a class="reference internal" href="#psyneulink.library.compositions.emcomposition.EMComposition.learning_rate" title="psyneulink.library.compositions.emcomposition.EMComposition.learning_rate"><code class="xref any py py-attr docutils literal notranslate"><span class="pre">learning</span> <span class="pre">rate</span></code></a> for the EMComposition.
If <a class="reference internal" href="#psyneulink.library.compositions.emcomposition.EMComposition.enable_learning" title="psyneulink.library.compositions.emcomposition.EMComposition.enable_learning"><code class="xref any py py-attr docutils literal notranslate"><span class="pre">enable_learning</span></code></a> is False (or <a class="reference internal" href="Composition.html#psyneulink.core.compositions.composition.Composition.run" title="psyneulink.core.compositions.composition.Composition.run"><code class="xref any py py-meth docutils literal notranslate"><span class="pre">run</span></code></a> is called rather than
<a class="reference internal" href="Composition.html#psyneulink.core.compositions.composition.Composition.learn" title="psyneulink.core.compositions.composition.Composition.learn"><code class="xref any py py-meth docutils literal notranslate"><span class="pre">learn</span></code></a>, then the <a class="reference internal" href="#psyneulink.library.compositions.emcomposition.EMComposition.field_weights" title="psyneulink.library.compositions.emcomposition.EMComposition.field_weights"><code class="xref any py py-attr docutils literal notranslate"><span class="pre">field_weights</span></code></a> are not modified, and no error
signals are passed to the nodes that project to  its <a class="reference internal" href="#psyneulink.library.compositions.emcomposition.EMComposition.query_input_nodes" title="psyneulink.library.compositions.emcomposition.EMComposition.query_input_nodes"><code class="xref any py py-attr docutils literal notranslate"><span class="pre">query_input_nodes</span></code></a> and
<a class="reference internal" href="#psyneulink.library.compositions.emcomposition.EMComposition.value_input_nodes" title="psyneulink.library.compositions.emcomposition.EMComposition.value_input_nodes"><code class="xref any py py-attr docutils literal notranslate"><span class="pre">value_input_nodes</span></code></a>.</p>
<blockquote>
<div><div class="admonition note">
<p class="admonition-title">Note</p>
<p>The only parameters modifable by learning in the EMComposition are its <a class="reference internal" href="#psyneulink.library.compositions.emcomposition.EMComposition.field_weights" title="psyneulink.library.compositions.emcomposition.EMComposition.field_weights"><code class="xref any py py-attr docutils literal notranslate"><span class="pre">field_weights</span></code></a>; all other parameters (including all other Projection <a class="reference internal" href="MappingProjection.html#psyneulink.core.components.projections.pathway.mappingprojection.MappingProjection.matrix" title="psyneulink.core.components.projections.pathway.mappingprojection.MappingProjection.matrix"><code class="xref any py py-attr docutils literal notranslate"><span class="pre">matrices</span></code></a>) are fixed, and used only to compute gradients and backpropagate errors.</p>
</div>
<div class="technical-note docutils container">
<p>Although memory storage is implemented as a form of learning (though modification of MappingProjection
<a class="reference internal" href="MappingProjection.html#psyneulink.core.components.projections.pathway.mappingprojection.MappingProjection.matrix" title="psyneulink.core.components.projections.pathway.mappingprojection.MappingProjection.matrix"><code class="xref any py py-attr docutils literal notranslate"><span class="pre">matrix</span></code></a> parameters; see <a class="reference internal" href="#emcomposition-memory-storage"><span class="std std-ref">memory storage</span></a>),
this occurs irrespective of how EMComposition is run (i.e., whether <a class="reference internal" href="Composition.html#psyneulink.core.compositions.composition.Composition.learn" title="psyneulink.core.compositions.composition.Composition.learn"><code class="xref any py py-meth docutils literal notranslate"><span class="pre">learn</span></code></a> or <a class="reference internal" href="Composition.html#psyneulink.core.compositions.composition.Composition.run" title="psyneulink.core.compositions.composition.Composition.run"><code class="xref any py py-meth docutils literal notranslate"><span class="pre">run</span></code></a> is called), and is not affected by the <a class="reference internal" href="#psyneulink.library.compositions.emcomposition.EMComposition.enable_learning" title="psyneulink.library.compositions.emcomposition.EMComposition.enable_learning"><code class="xref any py py-attr docutils literal notranslate"><span class="pre">enable_learning</span></code></a>
or <a class="reference internal" href="#psyneulink.library.compositions.emcomposition.EMComposition.learning_rate" title="psyneulink.library.compositions.emcomposition.EMComposition.learning_rate"><code class="xref any py py-attr docutils literal notranslate"><span class="pre">learning_rate</span></code></a> attributes, which pertain only to whether the <a class="reference internal" href="#psyneulink.library.compositions.emcomposition.EMComposition.field_weights" title="psyneulink.library.compositions.emcomposition.EMComposition.field_weights"><code class="xref any py py-attr docutils literal notranslate"><span class="pre">field_weights</span></code></a> are modified during learning.  Furthermore, when run in PyTorch mode, storage
is executed after the forward() and backward() passes are complete, and is not considered as part of the
gradient calculations.</p>
</div>
</div></blockquote>
<p class="rubric" id="emcomposition-examples">Examples</p>
<p>The following are examples of how to configure and initialize the EMComposition’s <a class="reference internal" href="#psyneulink.library.compositions.emcomposition.EMComposition.memory" title="psyneulink.library.compositions.emcomposition.EMComposition.memory"><code class="xref any py py-attr docutils literal notranslate"><span class="pre">memory</span></code></a>:</p>
</section>
<section id="visualizing-the-emcomposition">
<h3><em>Visualizing the EMComposition</em><a class="headerlink" href="#visualizing-the-emcomposition" title="Permalink to this headline">¶</a></h3>
<p>The EMComposition can be visualized graphically, like any <a class="reference internal" href="Composition.html"><span class="doc">Composition</span></a>, using its <a class="reference internal" href="Visualization.html#showgraph-show-graph-method"><span class="std std-ref">show_graph</span></a> method.  For example, the figure below shows an EMComposition that
implements a simple dictionary, with one key field and one value field, each of length 5:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">psyneulink</span> <span class="k">as</span> <span class="nn">pnl</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">em</span> <span class="o">=</span> <span class="n">EMComposition</span><span class="p">(</span><span class="n">memory_template</span><span class="o">=</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">5</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">em</span><span class="o">.</span><span class="n">show_graph</span><span class="p">()</span>
</pre></div>
</div>
<figure class="align-left" id="emcomposition-example-fig">
<img alt="Exxample of an EMComposition" src="_images/EMComposition_Example_fig.svg" /></figure>
</section>
<section id="memory-template">
<span id="emcomposition-example-memory-template"></span><h3><em>Memory Template</em><a class="headerlink" href="#memory-template" title="Permalink to this headline">¶</a></h3>
<p>The <a class="reference internal" href="#emcomposition-memory-template"><span class="std std-ref">memory_template</span></a> argument of a EMComposition’s constructor is used to configure
it <a class="reference internal" href="#psyneulink.library.compositions.emcomposition.EMComposition.memory" title="psyneulink.library.compositions.emcomposition.EMComposition.memory"><code class="xref any py py-attr docutils literal notranslate"><span class="pre">memory</span></code></a>, which can be specified using either a tuple or a list or array.</p>
<p id="emcomposition-example-tuple-spec"><strong>Tuple specification</strong></p>
<p>The simplest form of specification is a tuple, that uses the <a class="reference external" href="https://numpy.org/doc/stable/reference/generated/numpy.shape.html">numpy shape</a> format.  If it has two elements (as in the
example above), the first specifies the number of fields, and the second the length of each field.  In this case,
a default number of entries (1000) is created:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">em</span><span class="o">.</span><span class="n">memory_capacity</span>
<span class="go">1000</span>
</pre></div>
</div>
<p>The number of entries can be specified explicitly in the EMComposition’s constructor, using either the
<a class="reference internal" href="#emcomposition-memory-capacity"><span class="std std-ref">memory_capacity</span></a> argument, or by using a 3-item tuple to specify the
<a class="reference internal" href="#emcomposition-memory-template"><span class="std std-ref">memory_template</span></a> argument, in which case the first element specifies
the  number of entries, while the second and their specify the number of fields and the length of each field,
respectively.  The following are equivalent:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">em</span> <span class="o">=</span> <span class="n">EMComposition</span><span class="p">(</span><span class="n">memory_template</span><span class="o">=</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">5</span><span class="p">),</span> <span class="n">memory_capcity</span><span class="o">=</span><span class="mi">4</span><span class="p">)</span>
</pre></div>
</div>
<p>and</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">em</span> <span class="o">=</span> <span class="n">EMComposition</span><span class="p">(</span><span class="n">memory_template</span><span class="o">=</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">5</span><span class="p">))</span>
</pre></div>
</div>
<p>both of which create a memory with 4 entries, each with 2 fields of length 5. The contents of <a class="reference internal" href="#emcomposition-memory-specification"><span class="std std-ref">memory</span></a> can be inspected using the <a class="reference internal" href="#psyneulink.library.compositions.emcomposition.EMComposition.memory" title="psyneulink.library.compositions.emcomposition.EMComposition.memory"><code class="xref any py py-attr docutils literal notranslate"><span class="pre">memory</span></code></a> attribute:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">em</span><span class="o">.</span><span class="n">memory</span>
<span class="go">[[array([0., 0., 0., 0., 0.]), array([0., 0., 0., 0., 0.])],</span>
<span class="go"> [array([0., 0., 0., 0., 0.]), array([0., 0., 0., 0., 0.])],</span>
<span class="go"> [array([0., 0., 0., 0., 0.]), array([0., 0., 0., 0., 0.])],</span>
<span class="go"> [array([0., 0., 0., 0., 0.]), array([0., 0., 0., 0., 0.])]]</span>
</pre></div>
</div>
<p>The default for <a class="reference internal" href="#psyneulink.library.compositions.emcomposition.EMComposition.memory_capacity" title="psyneulink.library.compositions.emcomposition.EMComposition.memory_capacity"><code class="xref any py py-attr docutils literal notranslate"><span class="pre">memory_capacity</span></code></a> is 1000, which is used if it is not otherwise
specified.</p>
<p><strong>List or array specification</strong></p>
<p>Note that in the example above the two fields have the same length (5). This is always the case when a tuple is used,
as it generates a regular array.  A list or numpy array can also be used to specify the <strong>memory_template</strong> argument.
For example, the following is equivalent to the examples above:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">em</span> <span class="o">=</span> <span class="n">EMComposition</span><span class="p">(</span><span class="n">memory_template</span><span class="o">=</span><span class="p">[[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">],[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]],</span> <span class="n">memory_capacity</span><span class="o">=</span><span class="mi">4</span><span class="p">)</span>
</pre></div>
</div>
<p>However, a list or array can be used to specify fields of different length (i.e., as a ragged array).  For example,
the following specifies one field of length 3 and another of length 1:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">em</span> <span class="o">=</span> <span class="n">EMComposition</span><span class="p">(</span><span class="n">memory_template</span><span class="o">=</span><span class="p">[[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">],[</span><span class="mi">0</span><span class="p">]],</span> <span class="n">memory_capacity</span><span class="o">=</span><span class="mi">4</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">em</span><span class="o">.</span><span class="n">memory</span>
<span class="go">[[[array([0., 0., 0.]), array([0.])]],</span>
<span class="go"> [[array([0., 0., 0.]), array([0.])]],</span>
<span class="go"> [[array([0., 0., 0.]), array([0.])]],</span>
<span class="go"> [[array([0., 0., 0.]), array([0.])]]]</span>
</pre></div>
</div>
<p id="emcomposition-example-memory-fill"><strong>Memory fill</strong></p>
<p>Note that the examples above generate a warning about the use of zeros to initialize the memory. This is
because the default value for <strong>memory_fill</strong> is <code class="docutils literal notranslate"><span class="pre">0</span></code>, and the default value for <a class="reference internal" href="#psyneulink.library.compositions.emcomposition.EMComposition.normalize_memories" title="psyneulink.library.compositions.emcomposition.EMComposition.normalize_memories"><code class="xref any py py-attr docutils literal notranslate"><span class="pre">normalize_memories</span></code></a> is True, which will cause a divide by zero warning when memories are
normalized. While this doesn’t crash, it will result in nan’s that are likely to cauase problems elsewhere.
This can be avoided by specifying a non-zero  value for <strong>memory_fill</strong>, such as small number:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">em</span> <span class="o">=</span> <span class="n">EMComposition</span><span class="p">(</span><span class="n">memory_template</span><span class="o">=</span><span class="p">[[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">],[</span><span class="mi">0</span><span class="p">]],</span> <span class="n">memory_capacity</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span> <span class="n">memory_fill</span><span class="o">=</span><span class="mf">.001</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">em</span><span class="o">.</span><span class="n">memory</span>
<span class="go">[[[array([0.001, 0.001, 0.001]), array([0.001])]],</span>
<span class="go"> [[array([0.001, 0.001, 0.001]), array([0.001])]],</span>
<span class="go"> [[array([0.001, 0.001, 0.001]), array([0.001])]],</span>
<span class="go"> [[array([0.001, 0.001, 0.001]), array([0.001])]]]</span>
</pre></div>
</div>
<p>Here, a single value was specified for <strong>memory_fill</strong> (which can be a float or int), that is used to fill all values.
Random values can be assigned using a tuple to specify and internval between the first and second elements.  For
example, the following uses random values between 0 and 0.01 to fill all entries:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">em</span> <span class="o">=</span> <span class="n">EMComposition</span><span class="p">(</span><span class="n">memory_template</span><span class="o">=</span><span class="p">[[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">],[</span><span class="mi">0</span><span class="p">]],</span> <span class="n">memory_capacity</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span> <span class="n">memory_fill</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mf">0.01</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">em</span><span class="o">.</span><span class="n">memory</span>
<span class="go">[[[array([0.00298981, 0.00563404, 0.00444073]), array([0.00245373])]],</span>
<span class="go"> [[array([0.00148447, 0.00666486, 0.00228882]), array([0.00237541])]],</span>
<span class="go"> [[array([0.00432786, 0.00035378, 0.00265932]), array([0.00980598])]],</span>
<span class="go"> [[array([0.00151163, 0.00889032, 0.00899815]), array([0.00854529])]]]</span>
</pre></div>
</div>
<p id="emcomposition-example-multiple-entries"><strong>Multiple entries</strong></p>
<p>In the examples above, a single entry was specified, and that was used as a template for initializing the remaining
entries in memory. However, a list or array can be used to directly initialize any or all entries. For example, the
following initializes memory with two specific entries:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">em</span> <span class="o">=</span> <span class="n">EMComposition</span><span class="p">(</span><span class="n">memory_template</span><span class="o">=</span><span class="p">[[[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">],[</span><span class="mi">4</span><span class="p">]],[[</span><span class="mi">100</span><span class="p">,</span><span class="mi">101</span><span class="p">,</span><span class="mi">102</span><span class="p">],[</span><span class="mi">103</span><span class="p">]]],</span> <span class="n">memory_capacity</span><span class="o">=</span><span class="mi">4</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">em</span><span class="o">.</span><span class="n">memory</span>
<span class="go">[[[array([1., 2., 3.]), array([4.])]],</span>
<span class="go"> [[array([100., 101., 102.]), array([103.])]],</span>
<span class="go"> [[array([0., 0., 0.]), array([0.])]],</span>
<span class="go"> [[array([0., 0., 0.]), array([0.])]]]</span>
</pre></div>
</div>
<p>Note that the two entries must have exactly the same shapes. If they do not, an error is generated.
Also note that the remaining entries are filled with zeros (the default value for <strong>memory_fill</strong>).
Here again, <strong>memory_fill</strong> can be used to specify a different value:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">em</span> <span class="o">=</span> <span class="n">EMComposition</span><span class="p">(</span><span class="n">memory_template</span><span class="o">=</span><span class="p">[[[</span><span class="mi">7</span><span class="p">],[</span><span class="mi">24</span><span class="p">,</span><span class="mi">5</span><span class="p">]],[[</span><span class="mi">100</span><span class="p">],[</span><span class="mi">3</span><span class="p">,</span><span class="mi">106</span><span class="p">]]],</span> <span class="n">memory_capacity</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span> <span class="n">memory_fill</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mf">.01</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">em</span><span class="o">.</span><span class="n">memory</span>
<span class="go">[[[array([7.]), array([24.,  5.])]],</span>
<span class="go"> [[array([100.]), array([  3., 106.])]],</span>
<span class="go"> [[array([0.00803646]), array([0.00341276, 0.00286969])]],</span>
<span class="go"> [[array([0.00143196]), array([0.00079033, 0.00710556])]]]</span>
</pre></div>
</div>
</section>
<section id="field-weights">
<span id="emcomposition-example-field-weights"></span><h3><em>Field Weights</em><a class="headerlink" href="#field-weights" title="Permalink to this headline">¶</a></h3>
<p>By default, all of the fields specified are treated as keys except the last, which is treated as a “value” field –
that is, one that is not included in the matching process, but for which a value is retrieved along with the key fields.
For example, in the <a class="reference internal" href="#emcomposition-example-fig"><span class="std std-ref">figure</span></a> above, the first field specified was used as a key field,
and the last as a value field. However, the <strong>field_weights</strong> argument can be used to modify this, specifying which
fields should be used as keys fields – including the relative contribution that each makes to the matching process
– and which should be used as value fields.  Non-zero elements in the <strong>field_weights</strong> argument designate key fields,
and zeros specify value fields. For example, the following specifies that the first two fields should be used as keys
while the last two should be used as values:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">em</span> <span class="o">=</span> <span class="n">EMComposition</span><span class="p">(</span><span class="n">memory_template</span><span class="o">=</span><span class="p">[[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">],[</span><span class="mi">0</span><span class="p">],[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">],[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]],</span> <span class="n">memory_capacity</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">field_weights</span><span class="o">=</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">em</span><span class="o">.</span><span class="n">show_graph</span><span class="p">()</span>
</pre></div>
</div>
<figure class="align-default" id="id6">
<span id="emcomposition-example-field-weights-equal-fig"></span><img alt="_images/EMComposition_field_weights_equal_fig.svg" src="_images/EMComposition_field_weights_equal_fig.svg" /><figcaption>
<p><span class="caption-text"><strong>Use of field_weights to specify keys and values.</strong></span><a class="headerlink" href="#id6" title="Permalink to this image">¶</a></p>
</figcaption>
</figure>
<p>Note that the figure now shows <a class="reference internal" href="#psyneulink.library.compositions.emcomposition.EMComposition.field_weight_nodes" title="psyneulink.library.compositions.emcomposition.EMComposition.field_weight_nodes"><code class="xref any py py-attr docutils literal notranslate"><span class="pre">&lt;QUERY&gt;</span> <span class="pre">[WEIGHT]</span></code></a> <code class="xref any docutils literal notranslate"><span class="pre">nodes</span></code>,
that are used to implement the relative contribution that each key field makes to the matching process specifed in
<a class="reference internal" href="#psyneulink.library.compositions.emcomposition.EMComposition.field_weights" title="psyneulink.library.compositions.emcomposition.EMComposition.field_weights"><code class="xref any py py-attr docutils literal notranslate"><span class="pre">field_weights</span></code></a> argument.  By default, these are equal (all assigned a value of 1),
but different values can be used to weight the relative contribution of each key field.  The values are normalized so
that they sum 1, and the relative contribution of each is determined by the ratio of its value to the sum of all
non-zero values.  For example, the following specifies that the first two fields should be used as keys,
with the first contributing 75% to the matching process and the second field contributing 25%:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">em</span> <span class="o">=</span> <span class="n">EMComposition</span><span class="p">(</span><span class="n">memory_template</span><span class="o">=</span><span class="p">[[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">],[</span><span class="mi">0</span><span class="p">],[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]],</span> <span class="n">memory_capacity</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">field_weights</span><span class="o">=</span><span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">])</span>
</pre></div>
</div>
</section>
</section>
<section id="class-reference">
<span id="emcomposition-class-reference"></span><h2>Class Reference<a class="headerlink" href="#class-reference" title="Permalink to this headline">¶</a></h2>
<dl class="py class">
<dt class="sig sig-object py" id="psyneulink.library.compositions.emcomposition.EMComposition">
<em class="property"><span class="pre">class</span> </em><span class="sig-prename descclassname"><span class="pre">psyneulink.library.compositions.emcomposition.</span></span><span class="sig-name descname"><span class="pre">EMComposition</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">memory_template</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">[[0],</span> <span class="pre">[0]]</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">memory_capacity</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">memory_fill</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fields</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">field_names</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">field_weights</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">learn_field_weights</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">learning_rate</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">normalize_field_weights</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">concatenate_queries</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">normalize_memories</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">softmax_gain</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">softmax_threshold</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.001</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">softmax_choice</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'all'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">storage_prob</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">memory_decay_rate</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'auto'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">purge_by_field_weights</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">enable_learning</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">target_fields</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">use_storage_node</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">use_gating_for_weighting</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">random_state</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">seed</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">name</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'EM_Composition'</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#psyneulink.library.compositions.emcomposition.EMComposition" title="Permalink to this definition">¶</a></dt>
<dd><p>Subclass of <a class="reference internal" href="AutodiffComposition.html"><span class="doc">AutodiffComposition</span></a> that implements the functions of an <a class="reference internal" href="EpisodicMemoryMechanism.html"><span class="doc">EpisodicMemoryMechanism</span></a> in a
differentiable form and in which it’s <a class="reference internal" href="#psyneulink.library.compositions.emcomposition.EMComposition.field_weights" title="psyneulink.library.compositions.emcomposition.EMComposition.field_weights"><code class="xref any py py-attr docutils literal notranslate"><span class="pre">field_weights</span></code></a> parameter can be learned.</p>
<p>Takes only the following arguments, all of which are optional</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>memory_template</strong> (<em>tuple</em><em>, </em><em>list</em><em>, </em><em>2d</em><em> or </em><em>3d array : default</em><em> [</em><em>[</em><em>0</em><em>]</em><em>,</em><em>[</em><em>0</em><em>]</em><em>]</em>) – specifies the shape of an item to be stored in the EMComposition’s memory
(see <a class="reference internal" href="#emcomposition-memory-template"><span class="std std-ref">memory_template</span></a> for details).</p></li>
<li><p><strong>memory_fill</strong> (<em>scalar</em><em> or </em><em>tuple : default 0</em>) – specifies the value used to fill the memory when it is initialized
(see <a class="reference internal" href="#emcomposition-memory-fill"><span class="std std-ref">memory_fill</span></a> for details).</p></li>
<li><p><strong>memory_capacity</strong> (<em>int : default None</em>) – specifies the number of items that can be stored in the EMComposition’s memory;
(see <a class="reference internal" href="#emcomposition-memory-capacity"><span class="std std-ref">memory_capacity</span></a> for details).</p></li>
<li><p><strong>fields</strong> (<em>dict</em><em>[</em><em>tuple</em><em>[</em><em>field weight</em><em>, </em><em>learning specification</em><em>]</em><em>] </em><em>: default None</em>) – each key must a string that is the name of a field, and its value a dict or tuple that specifies that field’s
<a class="reference internal" href="#psyneulink.library.compositions.emcomposition.EMComposition.field_weights" title="psyneulink.library.compositions.emcomposition.EMComposition.field_weights"><code class="xref any py py-attr docutils literal notranslate"><span class="pre">field_weight</span></code></a>, <a class="reference internal" href="#psyneulink.library.compositions.emcomposition.EMComposition.learn_field_weights" title="psyneulink.library.compositions.emcomposition.EMComposition.learn_field_weights"><code class="xref any py py-attr docutils literal notranslate"><span class="pre">learn_field_weights</span></code></a>, and
<a class="reference internal" href="#psyneulink.library.compositions.emcomposition.EMComposition.target_fields" title="psyneulink.library.compositions.emcomposition.EMComposition.target_fields"><code class="xref any py py-attr docutils literal notranslate"><span class="pre">target_fields</span></code></a> specifications (see <a class="reference internal" href="#emcomposition-fields"><span class="std std-ref">fields</span></a> for details
of specificaton format). The <strong>fields</strong> arg replaces the <strong>field_names</strong>, <strong>field_weights</strong>
<strong>learn_field_weights</strong>, and <strong>target_fields</strong> arguments, and specifying any of these raises an error.</p></li>
<li><p><strong>field_names</strong> (<em>list</em><em> or </em><em>tuple : default None</em>) – specifies the names assigned to each field in the memory_template (see <a class="reference internal" href="#emcomposition-field-names"><span class="std std-ref">field names</span></a>
for details). If the <strong>fields</strong> argument is specified, this is not necessary and specifying raises an error.</p></li>
<li><p><strong>field_weights</strong> (<em>list</em><em> or </em><em>tuple : default</em><em> (</em><em>1</em><em>,</em><em>0</em><em>)</em>) – specifies the relative weight assigned to each key when matching an item in memory (see <a class="reference internal" href="#emcomposition-field-weights"><span class="std std-ref">field weights</span></a> for additional details). If the <strong>fields</strong> argument is specified, this
is not necessary and specifying raises an error.</p></li>
<li><p><strong>learn_field_weights</strong> (<em>bool</em><em> or </em><em>list</em><em>[</em><em>bool</em><em>, </em><em>int</em><em>, </em><em>float</em><em>]</em><em>: default False</em>) – specifies whether the <a class="reference internal" href="#psyneulink.library.compositions.emcomposition.EMComposition.field_weights" title="psyneulink.library.compositions.emcomposition.EMComposition.field_weights"><code class="xref any py py-attr docutils literal notranslate"><span class="pre">field_weights</span></code></a> are learnable and, if so, optionally what
the learning_rate is for each field (see <a class="reference internal" href="#emcomposition-field-weights-learning"><span class="std std-ref">learn_field_weights</span></a> for
specifications). If the <strong>fields</strong> argument is specified, this is not necessary and specifying raises an error.</p></li>
<li><p><strong>learning_rate</strong> (<em>float : default .01</em>) – specifies the default learning_rate for <a class="reference internal" href="#psyneulink.library.compositions.emcomposition.EMComposition.field_weights" title="psyneulink.library.compositions.emcomposition.EMComposition.field_weights"><code class="xref any py py-attr docutils literal notranslate"><span class="pre">field_weights</span></code></a> not
specified in <a class="reference internal" href="#psyneulink.library.compositions.emcomposition.EMComposition.learn_field_weights" title="psyneulink.library.compositions.emcomposition.EMComposition.learn_field_weights"><code class="xref any py py-attr docutils literal notranslate"><span class="pre">learn_field_weights</span></code></a> (see <a class="reference internal" href="#emcomposition-field-weights-learning"><span class="std std-ref">learning_rate</span></a> for additional details).</p></li>
<li><p><strong>normalize_field_weights</strong> (<em>bool : default True</em>) – specifies whether the <strong>fields_weights</strong> are normalized over the number of keys, or used as absolute
weighting values when retrieving an item from memory (see <a class="reference internal" href="#emcomposition-normalize-field-weights"><span class="std std-ref">normalize_field weights</span></a> for additional details).</p></li>
<li><p><strong>concatenate_queries</strong> (<em>bool : default False</em>) – specifies whether to concatenate the keys into a single field before matching them to items in
the corresponding fields in memory (see <a class="reference internal" href="#emcomposition-concatenate-queries"><span class="std std-ref">concatenate keys</span></a> for details).</p></li>
<li><p><strong>normalize_memories</strong> (<em>bool : default True</em>) – specifies whether keys and memories are normalized before computing their dot product (similarity)
(see <a class="reference internal" href="#emcomposition-processing"><span class="std std-ref">Match memories by field</span></a> for additional details).</p></li>
<li><p><strong>softmax_gain</strong> (<em>float</em><em>, </em><em>ADAPTIVE</em><em> or </em><em>CONTROL : default 1.0</em>) – specifies the temperature used for softmax normalizing the distance of queries and keys in memory
(see <a class="reference internal" href="#emcomposition-processing"><span class="std std-ref">Softmax normalize matches over fields</span></a> for additional details).</p></li>
<li><p><strong>softmax_threshold</strong> (<em>float : default .0001</em>) – specifies the threshold used to mask out small values in the softmax calculation
see <em>mask_threshold</em> under <a class="reference internal" href="TransferFunctions.html#softmax-adaptgain"><span class="std std-ref">Thresholding and Adaptive Gain</span></a> for details).</p></li>
<li><p><strong>softmax_choice</strong> (<em>WEIGHTED_AVG</em><em>, </em><em>ARG_MAX</em><em>, </em><em>PROBABILISTIC : default WEIGHTED_AVG</em>) – specifies how the softmax over distances of queries and keys in memory is used for retrieval
(see <a class="reference internal" href="#emcomposition-softmax-choice"><span class="std std-ref">softmax_choice</span></a> for a description of each option).</p></li>
<li><p><strong>storage_prob</strong> (<em>float : default 1.0</em>) – specifies the probability that an item will be stored in <a class="reference internal" href="#psyneulink.library.compositions.emcomposition.EMComposition.memory" title="psyneulink.library.compositions.emcomposition.EMComposition.memory"><code class="xref any py py-attr docutils literal notranslate"><span class="pre">memory</span></code></a>
when the EMComposition is executed (see <a class="reference internal" href="#emcomposition-storage"><span class="std std-ref">Retrieval and Storage</span></a> for
additional details).</p></li>
<li><p><strong>memory_decay_rate</strong> (<em>float : AUTO</em>) – specifies the rate at which items in the EMComposition’s memory decay
(see <a class="reference internal" href="#emcomposition-memory-decay-rate"><span class="std std-ref">memory_decay_rate</span></a> for details).</p></li>
<li><p><strong>purge_by_field_weights</strong> (<em>bool : False</em>) – specifies whether <a class="reference internal" href="#psyneulink.library.compositions.emcomposition.EMComposition.field_weights" title="psyneulink.library.compositions.emcomposition.EMComposition.field_weights"><code class="xref any py py-attr docutils literal notranslate"><span class="pre">fields_weights</span></code></a> are used to determine which memory to
replace when a new one is stored (see <a class="reference internal" href="#emcomposition-purge-by-weight"><span class="std std-ref">purge_by_field_weight</span></a> for details).</p></li>
<li><p><strong>enable_learning</strong> (<em>bool : default True</em>) – specifies whether learning is enabled for the EMCComposition (see <a class="reference internal" href="#emcomposition-learning"><span class="std std-ref">Learning</span></a>
for additional details); <strong>use_gating_for_weighting</strong> must be False.</p></li>
<li><p><strong>target_fields</strong> (<em>list</em><em>[</em><em>bool</em><em>]</em><em>: default None</em>) – <p>specifies whether a learning pathway is constructed for each <a class="reference internal" href="#emcomposition-entries-and-fields"><span class="std std-ref">field</span></a>
of the EMComposition.  If it is a list, each item must be <code class="docutils literal notranslate"><span class="pre">True</span></code> or <code class="docutils literal notranslate"><span class="pre">False</span></code> and the number of items
must be equal to the number of <a href="#id2"><span class="problematic" id="id3">`</span></a>fields &lt;EMComposition_Fields&gt; specified (see <a href="#id4"><span class="problematic" id="id5">`</span></a>Target Fields</p>
<blockquote>
<div><p>&lt;EMComposition_Target_Fields&gt;` for additional details). If the <strong>fields</strong> argument is specified,
this is not necessary and specifying raises an error.</p>
</div></blockquote>
</p></li>
<li><p><strong>FIX</strong> (<em># 7/10/24</em>) – </p></li>
<li><p><strong>technical_note::</strong> (<em>.</em>) – <dl class="simple">
<dt>use_storage_node<span class="classifier">bool</span><span class="classifier">default True</span></dt><dd><p>specifies whether to use a <a class="reference internal" href="LearningMechanism.html"><span class="doc">LearningMechanism</span></a> to store entries in <a class="reference internal" href="#psyneulink.library.compositions.emcomposition.EMComposition.memory" title="psyneulink.library.compositions.emcomposition.EMComposition.memory"><code class="xref any py py-attr docutils literal notranslate"><span class="pre">memory</span></code></a>.
If False, a method on EMComposition is used rather than a LearningMechanism. This is meant for
debugging, and precludes use of <a class="reference internal" href="Composition.html#psyneulink.core.compositions.composition.Composition.import_composition" title="psyneulink.core.compositions.composition.Composition.import_composition"><code class="xref any py py-meth docutils literal notranslate"><span class="pre">import_composition</span></code></a> to integrate
the EMComposition into another Composition;  to do so, use_storage_node must be True (default).</p>
</dd>
</dl>
</p></li>
<li><p><strong>use_gating_for_weighting</strong> (<em>bool : default False</em>) – specifies whether to use output gating to weight the <code class="xref any docutils literal notranslate"><span class="pre">match_nodes</span></code> instead of
a standard input (see <a class="reference internal" href="#emcomposition-field-weighting"><span class="std std-ref">Weight distances</span></a> for additional details).</p></li>
</ul>
</dd>
</dl>
<dl class="py attribute">
<dt class="sig sig-object py" id="psyneulink.library.compositions.emcomposition.EMComposition.memory">
<span class="sig-name descname"><span class="pre">memory</span></span><a class="headerlink" href="#psyneulink.library.compositions.emcomposition.EMComposition.memory" title="Permalink to this definition">¶</a></dt>
<dd><p>3d array of entries in memory, in which each row (axis 0) is an entry, each column (axis 1) is a field, and
each item (axis 2) is the value for the corresponding field (see <a class="reference internal" href="#emcomposition-memory-specification"><span class="std std-ref">Memory Specification</span></a>  for
additional details).</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This is a read-only attribute;  memories can be added to the EMComposition’s memory either by
executing its <a class="reference internal" href="Composition.html#psyneulink.core.compositions.composition.Composition.run" title="psyneulink.core.compositions.composition.Composition.run"><code class="xref any py py-meth docutils literal notranslate"><span class="pre">run</span></code></a> or learn methods with the entry as the <code class="docutils literal notranslate"><span class="pre">inputs</span></code> argument.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>ndarray</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="psyneulink.library.compositions.emcomposition.EMComposition.fields">
<span class="sig-name descname"><span class="pre">fields</span></span><a class="headerlink" href="#psyneulink.library.compositions.emcomposition.EMComposition.fields" title="Permalink to this definition">¶</a></dt>
<dd><p>list of <code class="xref any docutils literal notranslate"><span class="pre">Field</span></code> objects, each of which contains information about the nodes and values of a field in the
EMComposition’s memory (see <code class="xref any docutils literal notranslate"><span class="pre">Field</span></code>).</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>ContentAddressableList[Field]</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">..</span> <span class="pre">_EMComposition_Parameters</span></span></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="psyneulink.library.compositions.emcomposition.EMComposition.memory_capacity">
<span class="sig-name descname"><span class="pre">memory_capacity</span></span><a class="headerlink" href="#psyneulink.library.compositions.emcomposition.EMComposition.memory_capacity" title="Permalink to this definition">¶</a></dt>
<dd><p>determines the number of items that can be stored in <a class="reference internal" href="#psyneulink.library.compositions.emcomposition.EMComposition.memory" title="psyneulink.library.compositions.emcomposition.EMComposition.memory"><code class="xref any py py-attr docutils literal notranslate"><span class="pre">memory</span></code></a>
(see <a class="reference internal" href="#emcomposition-memory-capacity"><span class="std std-ref">memory_capacity</span></a> for additional details).</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>int</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="psyneulink.library.compositions.emcomposition.EMComposition.field_names">
<span class="sig-name descname"><span class="pre">field_names</span></span><a class="headerlink" href="#psyneulink.library.compositions.emcomposition.EMComposition.field_names" title="Permalink to this definition">¶</a></dt>
<dd><p>determines which names that can be used to label fields in <a class="reference internal" href="#psyneulink.library.compositions.emcomposition.EMComposition.memory" title="psyneulink.library.compositions.emcomposition.EMComposition.memory"><code class="xref any py py-attr docutils literal notranslate"><span class="pre">memory</span></code></a>
(see <a class="reference internal" href="#emcomposition-field-names"><span class="std std-ref">field_names</span></a> for additional details).</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>list[str]</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="psyneulink.library.compositions.emcomposition.EMComposition.field_weights">
<span class="sig-name descname"><span class="pre">field_weights</span></span><a class="headerlink" href="#psyneulink.library.compositions.emcomposition.EMComposition.field_weights" title="Permalink to this definition">¶</a></dt>
<dd><p>determines which fields of the input are treated as “keys” (non-zero values) that are used to match entries in
<a class="reference internal" href="#psyneulink.library.compositions.emcomposition.EMComposition.memory" title="psyneulink.library.compositions.emcomposition.EMComposition.memory"><code class="xref any py py-attr docutils literal notranslate"><span class="pre">memory</span></code></a> for retrieval, and which are used as “values” (zero values) that are stored
and retrieved from memory but not used in the match process (see <a class="reference internal" href="#emcomposition-processing"><span class="std std-ref">Match memories by field</span></a>; also determines the relative contribution of each key field to the match process;
see <a class="reference internal" href="#emcomposition-field-weights"><span class="std std-ref">field_weights</span></a> additional details. The field_weights can be changed by
assigning a new list of weights to the <a class="reference internal" href="#psyneulink.library.compositions.emcomposition.EMComposition.field_weights" title="psyneulink.library.compositions.emcomposition.EMComposition.field_weights"><code class="xref any py py-attr docutils literal notranslate"><span class="pre">field_weights</span></code></a> attribute, however only
the weights for fields used as <a class="reference internal" href="#emcomposition-entries-and-fields"><span class="std std-ref">keys</span></a> can be changed (see
<code class="xref any docutils literal notranslate"><span class="pre">EMComposition_Field_Weights_Change_Note</span></code> for additional details).</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>tuple[float]</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="psyneulink.library.compositions.emcomposition.EMComposition.learn_field_weights">
<span class="sig-name descname"><span class="pre">learn_field_weights</span></span><a class="headerlink" href="#psyneulink.library.compositions.emcomposition.EMComposition.learn_field_weights" title="Permalink to this definition">¶</a></dt>
<dd><p>determines whether the <a class="reference internal" href="#psyneulink.library.compositions.emcomposition.EMComposition.field_weights" title="psyneulink.library.compositions.emcomposition.EMComposition.field_weights"><code class="xref any py py-attr docutils literal notranslate"><span class="pre">field_weight</span></code></a> for each <code class="xref any docutils literal notranslate"><span class="pre">field</span></code> for additional details).</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>bool or list[bool, int, float]</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="psyneulink.library.compositions.emcomposition.EMComposition.learning_rate">
<span class="sig-name descname"><span class="pre">learning_rate</span></span><a class="headerlink" href="#psyneulink.library.compositions.emcomposition.EMComposition.learning_rate" title="Permalink to this definition">¶</a></dt>
<dd><p>determines the default learning_rate for <a class="reference internal" href="#psyneulink.library.compositions.emcomposition.EMComposition.field_weights" title="psyneulink.library.compositions.emcomposition.EMComposition.field_weights"><code class="xref any py py-attr docutils literal notranslate"><span class="pre">field_weights</span></code></a>
not specified in <a class="reference internal" href="#psyneulink.library.compositions.emcomposition.EMComposition.learn_field_weights" title="psyneulink.library.compositions.emcomposition.EMComposition.learn_field_weights"><code class="xref any py py-attr docutils literal notranslate"><span class="pre">learn_field_weights</span></code></a>
(see <a class="reference internal" href="#emcomposition-field-weights-learning"><span class="std std-ref">learning_rate</span></a> for additional details).</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>float</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="psyneulink.library.compositions.emcomposition.EMComposition.normalize_field_weights">
<span class="sig-name descname"><span class="pre">normalize_field_weights</span></span><a class="headerlink" href="#psyneulink.library.compositions.emcomposition.EMComposition.normalize_field_weights" title="Permalink to this definition">¶</a></dt>
<dd><p>determines whether <a class="reference internal" href="#psyneulink.library.compositions.emcomposition.EMComposition.field_weights" title="psyneulink.library.compositions.emcomposition.EMComposition.field_weights"><code class="xref any py py-attr docutils literal notranslate"><span class="pre">fields_weights</span></code></a> are normalized over the number of keys, or
used as absolute weighting values when retrieving an item from memory (see <a class="reference internal" href="#emcomposition-normalize-field-weights"><span class="std std-ref">normalize_field weights</span></a> for additional details).</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>bool</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="psyneulink.library.compositions.emcomposition.EMComposition.concatenate_queries">
<span class="sig-name descname"><span class="pre">concatenate_queries</span></span><a class="headerlink" href="#psyneulink.library.compositions.emcomposition.EMComposition.concatenate_queries" title="Permalink to this definition">¶</a></dt>
<dd><p>determines whether keys are concatenated into a single field before matching them to items in <code class="xref any docutils literal notranslate"><span class="pre">memory</span></code> for additional details).</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>bool</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="psyneulink.library.compositions.emcomposition.EMComposition.normalize_memories">
<span class="sig-name descname"><span class="pre">normalize_memories</span></span><a class="headerlink" href="#psyneulink.library.compositions.emcomposition.EMComposition.normalize_memories" title="Permalink to this definition">¶</a></dt>
<dd><p>determines whether keys and memories are normalized before computing their dot product (similarity)
(see <a class="reference internal" href="#emcomposition-processing"><span class="std std-ref">Match memories by field</span></a> for additional details).</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>bool</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="psyneulink.library.compositions.emcomposition.EMComposition.softmax_gain">
<span class="sig-name descname"><span class="pre">softmax_gain</span></span><a class="headerlink" href="#psyneulink.library.compositions.emcomposition.EMComposition.softmax_gain" title="Permalink to this definition">¶</a></dt>
<dd><p>determines gain (inverse temperature) used for softmax normalizing the summed distances of queries
and keys in memory by the <a class="reference internal" href="TransferFunctions.html#psyneulink.core.components.functions.transferfunctions.SoftMax" title="psyneulink.core.components.functions.transferfunctions.SoftMax"><code class="xref any py py-class docutils literal notranslate"><span class="pre">SoftMax</span></code></a> Function of the <a class="reference internal" href="#psyneulink.library.compositions.emcomposition.EMComposition.softmax_node" title="psyneulink.library.compositions.emcomposition.EMComposition.softmax_node"><code class="xref any py py-attr docutils literal notranslate"><span class="pre">softmax_node</span></code></a>
(see <a class="reference internal" href="#emcomposition-processing"><span class="std std-ref">Softmax normalize distances</span></a> for additional details).</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>float, ADAPTIVE or CONTROL</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="psyneulink.library.compositions.emcomposition.EMComposition.softmax_threshold">
<span class="sig-name descname"><span class="pre">softmax_threshold</span></span><a class="headerlink" href="#psyneulink.library.compositions.emcomposition.EMComposition.softmax_threshold" title="Permalink to this definition">¶</a></dt>
<dd><p>determines the threshold used to mask out small values in the softmax calculation
(see <em>mask_threshold</em> under <a class="reference internal" href="TransferFunctions.html#softmax-adaptgain"><span class="std std-ref">Thresholding and Adaptive Gain</span></a> for details).</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>float</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="psyneulink.library.compositions.emcomposition.EMComposition.softmax_choice">
<span class="sig-name descname"><span class="pre">softmax_choice</span></span><a class="headerlink" href="#psyneulink.library.compositions.emcomposition.EMComposition.softmax_choice" title="Permalink to this definition">¶</a></dt>
<dd><p>determines how the softmax over distances of queries and keys in memory is used for retrieval
(see <a class="reference internal" href="#emcomposition-softmax-choice"><span class="std std-ref">softmax_choice</span></a> for a description of each option).</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>WEIGHTED_AVG, ARG_MAX or PROBABILISTIC</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="psyneulink.library.compositions.emcomposition.EMComposition.storage_prob">
<span class="sig-name descname"><span class="pre">storage_prob</span></span><a class="headerlink" href="#psyneulink.library.compositions.emcomposition.EMComposition.storage_prob" title="Permalink to this definition">¶</a></dt>
<dd><p>determines the probability that an item will be stored in <a class="reference internal" href="#psyneulink.library.compositions.emcomposition.EMComposition.memory" title="psyneulink.library.compositions.emcomposition.EMComposition.memory"><code class="xref any py py-attr docutils literal notranslate"><span class="pre">memory</span></code></a>
when the EMComposition is executed (see <a class="reference internal" href="#emcomposition-storage"><span class="std std-ref">Retrieval and Storage</span></a> for
additional details).</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>float</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="psyneulink.library.compositions.emcomposition.EMComposition.memory_decay_rate">
<span class="sig-name descname"><span class="pre">memory_decay_rate</span></span><a class="headerlink" href="#psyneulink.library.compositions.emcomposition.EMComposition.memory_decay_rate" title="Permalink to this definition">¶</a></dt>
<dd><p>determines the rate at which items in the EMComposition’s memory decay
(see <a class="reference internal" href="#emcomposition-memory-decay-rate"><span class="std std-ref">memory_decay_rate</span></a> for details).</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>float</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="psyneulink.library.compositions.emcomposition.EMComposition.purge_by_field_weights">
<span class="sig-name descname"><span class="pre">purge_by_field_weights</span></span><a class="headerlink" href="#psyneulink.library.compositions.emcomposition.EMComposition.purge_by_field_weights" title="Permalink to this definition">¶</a></dt>
<dd><p>determines whether <a class="reference internal" href="#psyneulink.library.compositions.emcomposition.EMComposition.field_weights" title="psyneulink.library.compositions.emcomposition.EMComposition.field_weights"><code class="xref any py py-attr docutils literal notranslate"><span class="pre">fields_weights</span></code></a> are used to determine which memory to
replace when a new one is stored (see <a class="reference internal" href="#emcomposition-purge-by-weight"><span class="std std-ref">purge_by_field_weight</span></a> for details).</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>bool</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="psyneulink.library.compositions.emcomposition.EMComposition.enable_learning">
<span class="sig-name descname"><span class="pre">enable_learning</span></span><a class="headerlink" href="#psyneulink.library.compositions.emcomposition.EMComposition.enable_learning" title="Permalink to this definition">¶</a></dt>
<dd><p>determines whether learning is enabled for the EMCComposition
(see <a class="reference internal" href="#emcomposition-learning"><span class="std std-ref">Learning</span></a> for additional details).</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>bool</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="psyneulink.library.compositions.emcomposition.EMComposition.target_fields">
<span class="sig-name descname"><span class="pre">target_fields</span></span><a class="headerlink" href="#psyneulink.library.compositions.emcomposition.EMComposition.target_fields" title="Permalink to this definition">¶</a></dt>
<dd><p>determines which fields convey error signals during learning
(see <a class="reference internal" href="#emcomposition-target-fields"><span class="std std-ref">Target Fields</span></a> for additional details).</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>list[bool]</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">..</span> <span class="pre">_EMComposition_Nodes</span></span></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="psyneulink.library.compositions.emcomposition.EMComposition.query_input_nodes">
<span class="sig-name descname"><span class="pre">query_input_nodes</span></span><a class="headerlink" href="#psyneulink.library.compositions.emcomposition.EMComposition.query_input_nodes" title="Permalink to this definition">¶</a></dt>
<dd><p><a class="reference internal" href="Composition.html#psyneulink.core.compositions.composition.NodeRole.INPUT" title="psyneulink.core.compositions.composition.NodeRole.INPUT"><code class="xref any py py-attr docutils literal notranslate"><span class="pre">INPUT</span></code></a> <a class="reference internal" href="Composition.html#composition-nodes"><span class="std std-ref">Nodes</span></a> that receive keys used to determine the item
to be retrieved from <a class="reference internal" href="#psyneulink.library.compositions.emcomposition.EMComposition.memory" title="psyneulink.library.compositions.emcomposition.EMComposition.memory"><code class="xref any py py-attr docutils literal notranslate"><span class="pre">memory</span></code></a>, and then themselves stored in <a class="reference internal" href="#psyneulink.library.compositions.emcomposition.EMComposition.memory" title="psyneulink.library.compositions.emcomposition.EMComposition.memory"><code class="xref any py py-attr docutils literal notranslate"><span class="pre">memory</span></code></a> (see <a class="reference internal" href="#emcomposition-processing"><span class="std std-ref">Match memories by field</span></a> for additional details).
By default these are assigned the name <em>KEY_n_INPUT</em> where n is the field number (starting from 0);
however, if <a class="reference internal" href="#psyneulink.library.compositions.emcomposition.EMComposition.field_names" title="psyneulink.library.compositions.emcomposition.EMComposition.field_names"><code class="xref any py py-attr docutils literal notranslate"><span class="pre">field_names</span></code></a> is specified, then the name of each query_input_node
is assigned the corresponding field name appended with * [QUERY]*.</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>list[<a class="reference internal" href="ProcessingMechanism.html#psyneulink.core.components.mechanisms.processing.processingmechanism.ProcessingMechanism" title="psyneulink.core.components.mechanisms.processing.processingmechanism.ProcessingMechanism">ProcessingMechanism</a>]</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="psyneulink.library.compositions.emcomposition.EMComposition.value_input_nodes">
<span class="sig-name descname"><span class="pre">value_input_nodes</span></span><a class="headerlink" href="#psyneulink.library.compositions.emcomposition.EMComposition.value_input_nodes" title="Permalink to this definition">¶</a></dt>
<dd><p><a class="reference internal" href="Composition.html#psyneulink.core.compositions.composition.NodeRole.INPUT" title="psyneulink.core.compositions.composition.NodeRole.INPUT"><code class="xref any py py-attr docutils literal notranslate"><span class="pre">INPUT</span></code></a> <a class="reference internal" href="Composition.html#composition-nodes"><span class="std std-ref">Nodes</span></a> that receive values to be stored in <a class="reference internal" href="#psyneulink.library.compositions.emcomposition.EMComposition.memory" title="psyneulink.library.compositions.emcomposition.EMComposition.memory"><code class="xref any py py-attr docutils literal notranslate"><span class="pre">memory</span></code></a>; these are not used in the matching process used for retrieval.  By default these
are assigned the name <em>VALUE_n_INPUT</em> where n is the field number (starting from 0);  however, if
<a class="reference internal" href="#psyneulink.library.compositions.emcomposition.EMComposition.field_names" title="psyneulink.library.compositions.emcomposition.EMComposition.field_names"><code class="xref any py py-attr docutils literal notranslate"><span class="pre">field_names</span></code></a> is specified, then the name of each value_input_node is assigned
the corresponding field name appended with * [VALUE]*.</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>list[<a class="reference internal" href="ProcessingMechanism.html#psyneulink.core.components.mechanisms.processing.processingmechanism.ProcessingMechanism" title="psyneulink.core.components.mechanisms.processing.processingmechanism.ProcessingMechanism">ProcessingMechanism</a>]</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="psyneulink.library.compositions.emcomposition.EMComposition.concatenate_queries_node">
<span class="sig-name descname"><span class="pre">concatenate_queries_node</span></span><a class="headerlink" href="#psyneulink.library.compositions.emcomposition.EMComposition.concatenate_queries_node" title="Permalink to this definition">¶</a></dt>
<dd><p><a class="reference internal" href="ProcessingMechanism.html"><span class="doc">ProcessingMechanism</span></a> that concatenates the inputs to <a class="reference internal" href="#psyneulink.library.compositions.emcomposition.EMComposition.query_input_nodes" title="psyneulink.library.compositions.emcomposition.EMComposition.query_input_nodes"><code class="xref any py py-attr docutils literal notranslate"><span class="pre">query_input_nodes</span></code></a>
into a single vector used for the matching processing if <a class="reference internal" href="#psyneulink.library.compositions.emcomposition.EMComposition.concatenate_queries" title="psyneulink.library.compositions.emcomposition.EMComposition.concatenate_queries"><code class="xref any py py-attr docutils literal notranslate"><span class="pre">concatenate</span> <span class="pre">keys</span></code></a>
is True. This is not created if the <strong>concatenate_queries</strong> argument to the EMComposition’s constructor is
False or is overridden (see <a class="reference internal" href="#emcomposition-concatenate-queries"><span class="std std-ref">concatenate_queries</span></a>), or there is only one
query_input_node. This node is named <em>CONCATENATE_QUERIES</em></p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p><a class="reference internal" href="ProcessingMechanism.html#psyneulink.core.components.mechanisms.processing.processingmechanism.ProcessingMechanism" title="psyneulink.core.components.mechanisms.processing.processingmechanism.ProcessingMechanism">ProcessingMechanism</a></p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="psyneulink.library.compositions.emcomposition.EMComposition.match_nodes">
<span class="sig-name descname"><span class="pre">match_nodes</span></span><a class="headerlink" href="#psyneulink.library.compositions.emcomposition.EMComposition.match_nodes" title="Permalink to this definition">¶</a></dt>
<dd><p><a class="reference internal" href="ProcessingMechanism.html"><span class="doc">ProcessingMechanisms</span></a> that compute the dot product of each query and the key stored in
the corresponding field of <a class="reference internal" href="#psyneulink.library.compositions.emcomposition.EMComposition.memory" title="psyneulink.library.compositions.emcomposition.EMComposition.memory"><code class="xref any py py-attr docutils literal notranslate"><span class="pre">memory</span></code></a> (see <a class="reference internal" href="#emcomposition-processing"><span class="std std-ref">Match memories by field</span></a> for additional details). These are named the same as the corresponding
<a class="reference internal" href="#psyneulink.library.compositions.emcomposition.EMComposition.query_input_nodes" title="psyneulink.library.compositions.emcomposition.EMComposition.query_input_nodes"><code class="xref any py py-attr docutils literal notranslate"><span class="pre">query_input_nodes</span></code></a> appended with the suffix <em>[MATCH to KEYS]</em>.</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>list[<a class="reference internal" href="ProcessingMechanism.html#psyneulink.core.components.mechanisms.processing.processingmechanism.ProcessingMechanism" title="psyneulink.core.components.mechanisms.processing.processingmechanism.ProcessingMechanism">ProcessingMechanism</a>]</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="psyneulink.library.compositions.emcomposition.EMComposition.field_weight_nodes">
<span class="sig-name descname"><span class="pre">field_weight_nodes</span></span><a class="headerlink" href="#psyneulink.library.compositions.emcomposition.EMComposition.field_weight_nodes" title="Permalink to this definition">¶</a></dt>
<dd><p>Nodes used to weight the distances computed by the <a class="reference internal" href="#psyneulink.library.compositions.emcomposition.EMComposition.match_nodes" title="psyneulink.library.compositions.emcomposition.EMComposition.match_nodes"><code class="xref any py py-attr docutils literal notranslate"><span class="pre">match_nodes</span></code></a> with the
<a class="reference internal" href="#psyneulink.library.compositions.emcomposition.EMComposition.field_weights" title="psyneulink.library.compositions.emcomposition.EMComposition.field_weights"><code class="xref any py py-attr docutils literal notranslate"><span class="pre">field</span> <span class="pre">weight</span></code></a> for the corresponding <a class="reference internal" href="#emcomposition-fields"><span class="std std-ref">key field</span></a>
(see <a class="reference internal" href="#emcomposition-field-weighting"><span class="std std-ref">Weight distances</span></a> for implementation). These are named the same
as the corresponding <a class="reference internal" href="#psyneulink.library.compositions.emcomposition.EMComposition.query_input_nodes" title="psyneulink.library.compositions.emcomposition.EMComposition.query_input_nodes"><code class="xref any py py-attr docutils literal notranslate"><span class="pre">query_input_nodes</span></code></a>.</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>list[<a class="reference internal" href="ProcessingMechanism.html#psyneulink.core.components.mechanisms.processing.processingmechanism.ProcessingMechanism" title="psyneulink.core.components.mechanisms.processing.processingmechanism.ProcessingMechanism">ProcessingMechanism</a> or <a class="reference internal" href="GatingMechanism.html#psyneulink.core.components.mechanisms.modulatory.gating.gatingmechanism.GatingMechanism" title="psyneulink.core.components.mechanisms.modulatory.gating.gatingmechanism.GatingMechanism">GatingMechanism</a>]</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="psyneulink.library.compositions.emcomposition.EMComposition.weighted_match_nodes">
<span class="sig-name descname"><span class="pre">weighted_match_nodes</span></span><a class="headerlink" href="#psyneulink.library.compositions.emcomposition.EMComposition.weighted_match_nodes" title="Permalink to this definition">¶</a></dt>
<dd><p><a class="reference internal" href="ProcessingMechanism.html"><span class="doc">ProcessingMechanisms</span></a> that combine the <a class="reference internal" href="#psyneulink.library.compositions.emcomposition.EMComposition.field_weights" title="psyneulink.library.compositions.emcomposition.EMComposition.field_weights"><code class="xref any py py-attr docutils literal notranslate"><span class="pre">field</span> <span class="pre">weight</span></code></a>
for each <a class="reference internal" href="#emcomposition-fields"><span class="std std-ref">key field</span></a> with the dot product computed by the corresponding the
<a class="reference internal" href="#psyneulink.library.compositions.emcomposition.EMComposition.match_nodes" title="psyneulink.library.compositions.emcomposition.EMComposition.match_nodes"><code class="xref any py py-attr docutils literal notranslate"><span class="pre">match_node</span></code></a>. These are only implemented if <code class="xref any docutils literal notranslate"><span class="pre">use_gating_for_weighting</span></code> is False (see <a class="reference internal" href="#emcomposition-field-weighting"><span class="std std-ref">Weight distances</span></a>
for details), and are named the same as the corresponding <a class="reference internal" href="#psyneulink.library.compositions.emcomposition.EMComposition.query_input_nodes" title="psyneulink.library.compositions.emcomposition.EMComposition.query_input_nodes"><code class="xref any py py-attr docutils literal notranslate"><span class="pre">query_input_nodes</span></code></a>
appended with the suffix <em>[WEIGHTED MATCH]</em>.</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>list[<a class="reference internal" href="ProcessingMechanism.html#psyneulink.core.components.mechanisms.processing.processingmechanism.ProcessingMechanism" title="psyneulink.core.components.mechanisms.processing.processingmechanism.ProcessingMechanism">ProcessingMechanism</a>]</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="psyneulink.library.compositions.emcomposition.EMComposition.combined_matches_node">
<span class="sig-name descname"><span class="pre">combined_matches_node</span></span><a class="headerlink" href="#psyneulink.library.compositions.emcomposition.EMComposition.combined_matches_node" title="Permalink to this definition">¶</a></dt>
<dd><p><a class="reference internal" href="ProcessingMechanism.html"><span class="doc">ProcessingMechanism</span></a> that receives the weighted distances from the <a class="reference internal" href="#psyneulink.library.compositions.emcomposition.EMComposition.weighted_match_nodes" title="psyneulink.library.compositions.emcomposition.EMComposition.weighted_match_nodes"><code class="xref any py py-attr docutils literal notranslate"><span class="pre">weighted_match_nodes</span></code></a> if more than one <a class="reference internal" href="#emcomposition-fields"><span class="std std-ref">key field</span></a> is specified
(or directly from <a class="reference internal" href="#psyneulink.library.compositions.emcomposition.EMComposition.match_nodes" title="psyneulink.library.compositions.emcomposition.EMComposition.match_nodes"><code class="xref any py py-attr docutils literal notranslate"><span class="pre">match_nodes</span></code></a> if <code class="xref any docutils literal notranslate"><span class="pre">use_gating_for_weighting</span></code> is True), and combines them into a single vector that is passed
to the <a class="reference internal" href="#psyneulink.library.compositions.emcomposition.EMComposition.softmax_node" title="psyneulink.library.compositions.emcomposition.EMComposition.softmax_node"><code class="xref any py py-attr docutils literal notranslate"><span class="pre">softmax_node</span></code></a> for retrieval. This node is named <em>COMBINE MATCHES</em>.</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p><a class="reference internal" href="ProcessingMechanism.html#psyneulink.core.components.mechanisms.processing.processingmechanism.ProcessingMechanism" title="psyneulink.core.components.mechanisms.processing.processingmechanism.ProcessingMechanism">ProcessingMechanism</a></p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="psyneulink.library.compositions.emcomposition.EMComposition.softmax_node">
<span class="sig-name descname"><span class="pre">softmax_node</span></span><a class="headerlink" href="#psyneulink.library.compositions.emcomposition.EMComposition.softmax_node" title="Permalink to this definition">¶</a></dt>
<dd><p><a class="reference internal" href="ProcessingMechanism.html"><span class="doc">ProcessingMechanisms</span></a> that computes the softmax over the summed distances of keys
and memories (output of the <code class="xref any docutils literal notranslate"><span class="pre">combined_match_node</span></code>)
from the corresponding <a class="reference internal" href="#psyneulink.library.compositions.emcomposition.EMComposition.match_nodes" title="psyneulink.library.compositions.emcomposition.EMComposition.match_nodes"><code class="xref any py py-attr docutils literal notranslate"><span class="pre">match_nodes</span></code></a> (see <a class="reference internal" href="#emcomposition-processing"><span class="std std-ref">Softmax over summed distances</span></a> for additional details).  This is named <em>RETRIEVE</em> (as it yields the
softmax-weighted average over the keys in <a class="reference internal" href="#psyneulink.library.compositions.emcomposition.EMComposition.memory" title="psyneulink.library.compositions.emcomposition.EMComposition.memory"><code class="xref any py py-attr docutils literal notranslate"><span class="pre">memory</span></code></a>).</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>list[<a class="reference internal" href="ProcessingMechanism.html#psyneulink.core.components.mechanisms.processing.processingmechanism.ProcessingMechanism" title="psyneulink.core.components.mechanisms.processing.processingmechanism.ProcessingMechanism">ProcessingMechanism</a>]</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="psyneulink.library.compositions.emcomposition.EMComposition.softmax_gain_control_node">
<span class="sig-name descname"><span class="pre">softmax_gain_control_node</span></span><a class="headerlink" href="#psyneulink.library.compositions.emcomposition.EMComposition.softmax_gain_control_node" title="Permalink to this definition">¶</a></dt>
<dd><p><a class="reference internal" href="ControlMechanism.html"><span class="doc">ControlMechanisms</span></a> that adaptively control the <a class="reference internal" href="#psyneulink.library.compositions.emcomposition.EMComposition.softmax_gain" title="psyneulink.library.compositions.emcomposition.EMComposition.softmax_gain"><code class="xref any py py-attr docutils literal notranslate"><span class="pre">softmax_gain</span></code></a>
of the <a class="reference internal" href="#psyneulink.library.compositions.emcomposition.EMComposition.softmax_node" title="psyneulink.library.compositions.emcomposition.EMComposition.softmax_node"><code class="xref any py py-attr docutils literal notranslate"><span class="pre">softmax_node</span></code></a>. This is implemented only if <a class="reference internal" href="#psyneulink.library.compositions.emcomposition.EMComposition.softmax_gain" title="psyneulink.library.compositions.emcomposition.EMComposition.softmax_gain"><code class="xref any py py-attr docutils literal notranslate"><span class="pre">softmax_gain</span></code></a> is specified as <em>CONTROL</em> (see <a class="reference internal" href="#emcomposition-softmax-gain"><span class="std std-ref">softmax_gain</span></a> for
details).</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>list[<a class="reference internal" href="ControlMechanism.html#psyneulink.core.components.mechanisms.modulatory.control.controlmechanism.ControlMechanism" title="psyneulink.core.components.mechanisms.modulatory.control.controlmechanism.ControlMechanism">ControlMechanism</a>]</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="psyneulink.library.compositions.emcomposition.EMComposition.retrieved_nodes">
<span class="sig-name descname"><span class="pre">retrieved_nodes</span></span><a class="headerlink" href="#psyneulink.library.compositions.emcomposition.EMComposition.retrieved_nodes" title="Permalink to this definition">¶</a></dt>
<dd><p><a class="reference internal" href="ProcessingMechanism.html"><span class="doc">ProcessingMechanisms</span></a> that receive the vector retrieved for each field in <a class="reference internal" href="#psyneulink.library.compositions.emcomposition.EMComposition.memory" title="psyneulink.library.compositions.emcomposition.EMComposition.memory"><code class="xref any py py-attr docutils literal notranslate"><span class="pre">memory</span></code></a> (see <a class="reference internal" href="#emcomposition-processing"><span class="std std-ref">Retrieve values by field</span></a> for additional details).
These are assigned the same names as the <a class="reference internal" href="#psyneulink.library.compositions.emcomposition.EMComposition.query_input_nodes" title="psyneulink.library.compositions.emcomposition.EMComposition.query_input_nodes"><code class="xref any py py-attr docutils literal notranslate"><span class="pre">query_input_nodes</span></code></a> and
<a class="reference internal" href="#psyneulink.library.compositions.emcomposition.EMComposition.value_input_nodes" title="psyneulink.library.compositions.emcomposition.EMComposition.value_input_nodes"><code class="xref any py py-attr docutils literal notranslate"><span class="pre">value_input_nodes</span></code></a> to which they correspond appended with the suffix
* [RETRIEVED]*, and are in the same order as  <a class="reference internal" href="#psyneulink.library.compositions.emcomposition.EMComposition.input_nodes" title="psyneulink.library.compositions.emcomposition.EMComposition.input_nodes"><code class="xref any py py-attr docutils literal notranslate"><span class="pre">input_nodes</span></code></a>
to which to which they correspond.</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>list[<a class="reference internal" href="ProcessingMechanism.html#psyneulink.core.components.mechanisms.processing.processingmechanism.ProcessingMechanism" title="psyneulink.core.components.mechanisms.processing.processingmechanism.ProcessingMechanism">ProcessingMechanism</a>]</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="psyneulink.library.compositions.emcomposition.EMComposition.storage_node">
<span class="sig-name descname"><span class="pre">storage_node</span></span><a class="headerlink" href="#psyneulink.library.compositions.emcomposition.EMComposition.storage_node" title="Permalink to this definition">¶</a></dt>
<dd><p><code class="xref any docutils literal notranslate"><span class="pre">EMStorageMechanism</span></code> that receives inputs from the <a class="reference internal" href="#psyneulink.library.compositions.emcomposition.EMComposition.query_input_nodes" title="psyneulink.library.compositions.emcomposition.EMComposition.query_input_nodes"><code class="xref any py py-attr docutils literal notranslate"><span class="pre">query_input_nodes</span></code></a> and
<a class="reference internal" href="#psyneulink.library.compositions.emcomposition.EMComposition.value_input_nodes" title="psyneulink.library.compositions.emcomposition.EMComposition.value_input_nodes"><code class="xref any py py-attr docutils literal notranslate"><span class="pre">value_input_nodes</span></code></a>, and stores these in the corresponding field of`memory
&lt;EMComposition.memory&gt;` with probability <a class="reference internal" href="#psyneulink.library.compositions.emcomposition.EMComposition.storage_prob" title="psyneulink.library.compositions.emcomposition.EMComposition.storage_prob"><code class="xref any py py-attr docutils literal notranslate"><span class="pre">storage_prob</span></code></a> after a retrieval has been
made (see <a class="reference internal" href="#emcomposition-storage"><span class="std std-ref">Retrieval and Storage</span></a> for additional details). This node is named <em>STORE</em>.</p>
<div class="technical-note docutils container">
<p>The <a class="reference internal" href="#psyneulink.library.compositions.emcomposition.EMComposition.storage_node" title="psyneulink.library.compositions.emcomposition.EMComposition.storage_node"><code class="xref any py py-attr docutils literal notranslate"><span class="pre">storage_node</span></code></a> is assigned a Condition to execute after the <a class="reference internal" href="#psyneulink.library.compositions.emcomposition.EMComposition.retrieved_nodes" title="psyneulink.library.compositions.emcomposition.EMComposition.retrieved_nodes"><code class="xref any py py-attr docutils literal notranslate"><span class="pre">retrieved_nodes</span></code></a> have executed, to ensure that storage occurs after retrieval, but before
any subequent processing is done (i.e., in a composition in which the EMComposition may be embededded.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>EMStorageMechanism</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="psyneulink.library.compositions.emcomposition.EMComposition.input_nodes">
<span class="sig-name descname"><span class="pre">input_nodes</span></span><a class="headerlink" href="#psyneulink.library.compositions.emcomposition.EMComposition.input_nodes" title="Permalink to this definition">¶</a></dt>
<dd><p>Full list of <a class="reference internal" href="Composition.html#psyneulink.core.compositions.composition.NodeRole.INPUT" title="psyneulink.core.compositions.composition.NodeRole.INPUT"><code class="xref any py py-attr docutils literal notranslate"><span class="pre">INPUT</span></code></a> <a class="reference internal" href="Composition.html#composition-nodes"><span class="std std-ref">Nodes</span></a> in the same order specified in the
<strong>field_names</strong> argument of the constructor and in <a class="reference internal" href="#psyneulink.library.compositions.emcomposition.EMComposition.field_names" title="psyneulink.library.compositions.emcomposition.EMComposition.field_names"><code class="xref any py py-attr docutils literal notranslate"><span class="pre">self.field_names</span></code></a>.</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>list[<a class="reference internal" href="ProcessingMechanism.html#psyneulink.core.components.mechanisms.processing.processingmechanism.ProcessingMechanism" title="psyneulink.core.components.mechanisms.processing.processingmechanism.ProcessingMechanism">ProcessingMechanism</a>]</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="psyneulink.library.compositions.emcomposition.EMComposition.query_and_value_input_nodes">
<span class="sig-name descname"><span class="pre">query_and_value_input_nodes</span></span><a class="headerlink" href="#psyneulink.library.compositions.emcomposition.EMComposition.query_and_value_input_nodes" title="Permalink to this definition">¶</a></dt>
<dd><p>Full list of <a class="reference internal" href="Composition.html#psyneulink.core.compositions.composition.NodeRole.INPUT" title="psyneulink.core.compositions.composition.NodeRole.INPUT"><code class="xref any py py-attr docutils literal notranslate"><span class="pre">INPUT</span></code></a> <a class="reference internal" href="Composition.html#composition-nodes"><span class="std std-ref">Nodes</span></a> ordered with query_input_nodes first
followed by value_input_nodes; used primarily for internal computations.</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>list[<a class="reference internal" href="ProcessingMechanism.html#psyneulink.core.components.mechanisms.processing.processingmechanism.ProcessingMechanism" title="psyneulink.core.components.mechanisms.processing.processingmechanism.ProcessingMechanism">ProcessingMechanism</a>]</p>
</dd>
</dl>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="psyneulink.library.compositions.emcomposition.EMComposition.PytorchEMCompositionWrapper">
<em class="property"><span class="pre">class</span> </em><span class="sig-name descname"><span class="pre">PytorchEMCompositionWrapper</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#psyneulink.library.compositions.emcomposition.EMComposition.PytorchEMCompositionWrapper" title="Permalink to this definition">¶</a></dt>
<dd><p>Wrapper for EMComposition as a Pytorch Module</p>
<dl class="py method">
<dt class="sig sig-object py" id="psyneulink.library.compositions.emcomposition.EMComposition.PytorchEMCompositionWrapper.execute_node">
<span class="sig-name descname"><span class="pre">execute_node</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">node</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">variable</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">optimization_num</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">context</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#psyneulink.library.compositions.emcomposition.EMComposition.PytorchEMCompositionWrapper.execute_node" title="Permalink to this definition">¶</a></dt>
<dd><p>Override to handle storage of entry to memory_matrix by EMStorage Function</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="psyneulink.library.compositions.emcomposition.EMComposition.PytorchEMCompositionWrapper.memory">
<em class="property"><span class="pre">property</span> </em><span class="sig-name descname"><span class="pre">memory</span></span><a class="headerlink" href="#psyneulink.library.compositions.emcomposition.EMComposition.PytorchEMCompositionWrapper.memory" title="Permalink to this definition">¶</a></dt>
<dd><p>Return list of memories in which rows (outer dimension) are memories for each field.
These are derived from the matrix parameters of the afferent Projections to the retrieval_nodes</p>
<dl class="field-list simple">
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><code class="xref py py-data docutils literal notranslate"><span class="pre">Optional</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">Tensor</span></code>]</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="psyneulink.library.compositions.emcomposition.EMComposition.PytorchEMCompositionWrapper.store_memory">
<span class="sig-name descname"><span class="pre">store_memory</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">memory_to_store</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">context</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#psyneulink.library.compositions.emcomposition.EMComposition.PytorchEMCompositionWrapper.store_memory" title="Permalink to this definition">¶</a></dt>
<dd><p>Store variable in memory_matrix (parallel EMStorageMechanism._execute)</p>
<p>For each node in query_input_nodes and value_input_nodes,
assign its value to weights of corresponding afferents to corresponding match_node and/or retrieved_node.
- memory = matrix of entries made up vectors for each field in each entry (row)
- entry_to_store = query_input or value_input to store
- field_projections = Projections the matrices of which comprise memory</p>
<p>DIVISION OF LABOR between this method and function called by it
store_memory (corresponds to EMStorageMechanism._execute)</p>
<blockquote>
<div><ul class="simple">
<li><p>compute norms to find weakest entry in memory</p></li>
<li><p>compute storage_prob to determine whether to store current entry in memory</p></li>
<li><p>call function with memory matrix for each field, to decay existing memory and assign input to weakest entry</p></li>
</ul>
</div></blockquote>
<dl class="simple">
<dt>storage_node.function (corresponds to EMStorage._function):</dt><dd><ul class="simple">
<li><p>decay existing memories</p></li>
<li><p>assign input to weakest entry (given index for passed from EMStorageMechanism)</p></li>
</ul>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>List[2d tensor] updated memories</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="psyneulink.library.compositions.emcomposition.EMComposition.pytorch_composition_wrapper_type">
<span class="sig-name descname"><span class="pre">pytorch_composition_wrapper_type</span></span><a class="headerlink" href="#psyneulink.library.compositions.emcomposition.EMComposition.pytorch_composition_wrapper_type" title="Permalink to this definition">¶</a></dt>
<dd><p>alias of <a class="reference internal" href="#psyneulink.library.compositions.emcomposition.EMComposition.PytorchEMCompositionWrapper" title="psyneulink.library.compositions.pytorchEMcompositionwrapper.PytorchEMCompositionWrapper"><code class="xref py py-class docutils literal notranslate"><span class="pre">psyneulink.library.compositions.pytorchEMcompositionwrapper.PytorchEMCompositionWrapper</span></code></a></p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="psyneulink.library.compositions.emcomposition.EMComposition._validate_memory_specs">
<span class="sig-name descname"><span class="pre">_validate_memory_specs</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">memory_template</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">memory_capacity</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">memory_fill</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">field_weights</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">field_names</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">name</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#psyneulink.library.compositions.emcomposition.EMComposition._validate_memory_specs" title="Permalink to this definition">¶</a></dt>
<dd><p>Validate the memory_template, field_weights, and field_names arguments</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="psyneulink.library.compositions.emcomposition.EMComposition._parse_memory_template">
<span class="sig-name descname"><span class="pre">_parse_memory_template</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">memory_template</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">memory_capacity</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">memory_fill</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#psyneulink.library.compositions.emcomposition.EMComposition._parse_memory_template" title="Permalink to this definition">¶</a></dt>
<dd><p>Construct memory from memory_template and memory_fill
Assign self.memory_template and self.entry_template attributes</p>
<dl class="field-list simple">
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>(&lt;class ‘numpy.ndarray’&gt;, &lt;class ‘int’&gt;)</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="psyneulink.library.compositions.emcomposition.EMComposition._parse_memory_shape">
<span class="sig-name descname"><span class="pre">_parse_memory_shape</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">memory_template</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#psyneulink.library.compositions.emcomposition.EMComposition._parse_memory_shape" title="Permalink to this definition">¶</a></dt>
<dd><p>Parse shape of memory_template to determine number of entries and fields</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="psyneulink.library.compositions.emcomposition.EMComposition._construct_pathways">
<span class="sig-name descname"><span class="pre">_construct_pathways</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">memory_template</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">memory_capacity</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">field_weights</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">concatenate_queries</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">normalize_memories</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">softmax_gain</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">softmax_threshold</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">softmax_choice</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">storage_prob</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">memory_decay_rate</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">use_storage_node</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">learn_field_weights</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">enable_learning</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">use_gating_for_weighting</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#psyneulink.library.compositions.emcomposition.EMComposition._construct_pathways" title="Permalink to this definition">¶</a></dt>
<dd><p>Construct Nodes and Pathways for EMComposition</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="psyneulink.library.compositions.emcomposition.EMComposition._construct_input_nodes">
<span class="sig-name descname"><span class="pre">_construct_input_nodes</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#psyneulink.library.compositions.emcomposition.EMComposition._construct_input_nodes" title="Permalink to this definition">¶</a></dt>
<dd><p>Create one node for each input to EMComposition and identify as key or value</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="psyneulink.library.compositions.emcomposition.EMComposition._construct_concatenate_queries_node">
<span class="sig-name descname"><span class="pre">_construct_concatenate_queries_node</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">concatenate_queries</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#psyneulink.library.compositions.emcomposition.EMComposition._construct_concatenate_queries_node" title="Permalink to this definition">¶</a></dt>
<dd><p>Create node that concatenates the inputs for all keys into a single vector
Used to create a matrix for Projection from match / memory weights from concatenate_node -&gt; match_node</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="psyneulink.library.compositions.emcomposition.EMComposition._construct_match_nodes">
<span class="sig-name descname"><span class="pre">_construct_match_nodes</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">memory_template</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">memory_capacity</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">concatenate_queries</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">normalize_memories</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#psyneulink.library.compositions.emcomposition.EMComposition._construct_match_nodes" title="Permalink to this definition">¶</a></dt>
<dd><p>Create nodes that, for each key field, compute the similarity between the input and each item in memory.
- If self.concatenate_queries is True, then all inputs for keys from concatenated_keys_node are</p>
<blockquote>
<div><p>assigned a single match_node, and weights from memory_template are assigned to a Projection
from concatenated_keys_node to that match_node.</p>
</div></blockquote>
<ul class="simple">
<li><dl class="simple">
<dt>Otherwise, each key has its own match_node, and weights from memory_template are assigned to a Projection</dt><dd><p>from each query_input_node[i] to each match_node[i].</p>
</dd>
</dl>
</li>
<li><p>Each element of the output represents the similarity between the query_input and one key in memory.</p></li>
</ul>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="psyneulink.library.compositions.emcomposition.EMComposition._construct_field_weight_nodes">
<span class="sig-name descname"><span class="pre">_construct_field_weight_nodes</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">concatenate_queries</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">use_gating_for_weighting</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#psyneulink.library.compositions.emcomposition.EMComposition._construct_field_weight_nodes" title="Permalink to this definition">¶</a></dt>
<dd><p>Create ProcessingMechanisms that weight each key’s softmax contribution to the retrieved values.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="psyneulink.library.compositions.emcomposition.EMComposition._construct_weighted_match_nodes">
<span class="sig-name descname"><span class="pre">_construct_weighted_match_nodes</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">concatenate_queries</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#psyneulink.library.compositions.emcomposition.EMComposition._construct_weighted_match_nodes" title="Permalink to this definition">¶</a></dt>
<dd><p>Create nodes that weight the output of the match node for each key.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="psyneulink.library.compositions.emcomposition.EMComposition._construct_softmax_gain_control_node">
<span class="sig-name descname"><span class="pre">_construct_softmax_gain_control_node</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">softmax_gain</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#psyneulink.library.compositions.emcomposition.EMComposition._construct_softmax_gain_control_node" title="Permalink to this definition">¶</a></dt>
<dd><p>Create nodes that set the softmax gain (inverse temperature) for each softmax_node.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="psyneulink.library.compositions.emcomposition.EMComposition._construct_combined_matches_node">
<span class="sig-name descname"><span class="pre">_construct_combined_matches_node</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">concatenate_queries</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">memory_capacity</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">use_gating_for_weighting</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#psyneulink.library.compositions.emcomposition.EMComposition._construct_combined_matches_node" title="Permalink to this definition">¶</a></dt>
<dd><p>Create node that combines weighted matches for all keys into one match vector.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="psyneulink.library.compositions.emcomposition.EMComposition._construct_softmax_node">
<span class="sig-name descname"><span class="pre">_construct_softmax_node</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">memory_capacity</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">softmax_gain</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">softmax_threshold</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">softmax_choice</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#psyneulink.library.compositions.emcomposition.EMComposition._construct_softmax_node" title="Permalink to this definition">¶</a></dt>
<dd><p>Create node that applies softmax to output of combined_matches_node.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="psyneulink.library.compositions.emcomposition.EMComposition._construct_retrieved_nodes">
<span class="sig-name descname"><span class="pre">_construct_retrieved_nodes</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">memory_template</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#psyneulink.library.compositions.emcomposition.EMComposition._construct_retrieved_nodes" title="Permalink to this definition">¶</a></dt>
<dd><p>Create nodes that report the value field(s) for the item(s) matched in memory.</p>
<dl class="field-list simple">
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><code class="xref py py-class docutils literal notranslate"><span class="pre">list</span></code></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="psyneulink.library.compositions.emcomposition.EMComposition._construct_storage_node">
<span class="sig-name descname"><span class="pre">_construct_storage_node</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">use_storage_node</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">memory_template</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">memory_decay_rate</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">storage_prob</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#psyneulink.library.compositions.emcomposition.EMComposition._construct_storage_node" title="Permalink to this definition">¶</a></dt>
<dd><p>Create EMStorageMechanism that stores the key and value inputs in memory.
Memories are stored by adding the current input to each field to the corresponding row of the matrix for
the Projection from the query_input_node (or concatenate_node) to the matching_node and retrieved_node for keys,
and from the value_input_node to the retrieved_node for values. The <code class="xref any docutils literal notranslate"><span class="pre">function</span></code>
of the <code class="xref any docutils literal notranslate"><span class="pre">EMSorageMechanism</span></code> that takes the following arguments:</p>
<blockquote>
<div><ul class="simple">
<li><p><strong>variable</strong> – template for an <a class="reference internal" href="#emcomposition-memory-specification"><span class="std std-ref">entry</span></a>
in <a class="reference internal" href="#psyneulink.library.compositions.emcomposition.EMComposition.memory" title="psyneulink.library.compositions.emcomposition.EMComposition.memory"><code class="xref any py py-attr docutils literal notranslate"><span class="pre">memory</span></code></a>;</p></li>
<li><p><strong>fields</strong> – the <a class="reference internal" href="#psyneulink.library.compositions.emcomposition.EMComposition.input_nodes" title="psyneulink.library.compositions.emcomposition.EMComposition.input_nodes"><code class="xref any py py-attr docutils literal notranslate"><span class="pre">input_nodes</span></code></a> for the corresponding <a class="reference internal" href="#emcomposition-fields"><span class="std std-ref">fields</span></a> of an <code class="xref any docutils literal notranslate"><span class="pre">entry</span></code> in <a class="reference internal" href="#psyneulink.library.compositions.emcomposition.EMComposition.memory" title="psyneulink.library.compositions.emcomposition.EMComposition.memory"><code class="xref any py py-attr docutils literal notranslate"><span class="pre">memory</span></code></a>;</p></li>
<li><p><strong>field_types</strong> – a list of the same length as <code class="docutils literal notranslate"><span class="pre">fields</span></code>, containing 1’s for key fields and 0’s for
value fields;</p></li>
<li><p><strong>concatenate_queries_node</strong> – node used to concatenate keys
(if <a class="reference internal" href="#psyneulink.library.compositions.emcomposition.EMComposition.concatenate_queries" title="psyneulink.library.compositions.emcomposition.EMComposition.concatenate_queries"><code class="xref any py py-attr docutils literal notranslate"><span class="pre">concatenate_queries</span></code></a> is <code class="xref any docutils literal notranslate"><span class="pre">True</span></code>) or None;</p></li>
<li><p><strong>memory_matrix</strong> – <code class="xref any docutils literal notranslate"><span class="pre">memory_template</span></code>);</p></li>
<li><p><strong>learning_signals</strong> – list of ` <a class="reference internal" href="MappingProjection.html"><span class="doc">MappingProjection</span></a>s (or their ParameterPort`s) that store each
<a class="reference internal" href="#emcomposition-fields"><span class="std std-ref">field</span></a> of <a class="reference internal" href="#psyneulink.library.compositions.emcomposition.EMComposition.memory" title="psyneulink.library.compositions.emcomposition.EMComposition.memory"><code class="xref any py py-attr docutils literal notranslate"><span class="pre">memory</span></code></a>;</p></li>
<li><p><strong>decay_rate</strong> – rate at which entries in the <code class="xref any docutils literal notranslate"><span class="pre">memory_matrix</span></code> decay;</p></li>
<li><p><strong>storage_prob</strong> – probability for storing an entry in <a class="reference internal" href="#psyneulink.library.compositions.emcomposition.EMComposition.memory" title="psyneulink.library.compositions.emcomposition.EMComposition.memory"><code class="xref any py py-attr docutils literal notranslate"><span class="pre">memory</span></code></a>.</p></li>
</ul>
</div></blockquote>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="psyneulink.library.compositions.emcomposition.EMComposition._set_learning_attributes">
<span class="sig-name descname"><span class="pre">_set_learning_attributes</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#psyneulink.library.compositions.emcomposition.EMComposition._set_learning_attributes" title="Permalink to this definition">¶</a></dt>
<dd><p>Set learning-related attributes for Node and Projections</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="psyneulink.library.compositions.emcomposition.EMComposition._store_memory">
<span class="sig-name descname"><span class="pre">_store_memory</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">inputs</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">context</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#psyneulink.library.compositions.emcomposition.EMComposition._store_memory" title="Permalink to this definition">¶</a></dt>
<dd><p>Store inputs to query and value nodes in memory
Store memories in weights of Projections to match_nodes (queries) and retrieved_nodes (values).
Note: inputs argument is ignored (included for compatibility with function of MemoryFunctions class;</p>
<blockquote>
<div><p>storage is handled by call to EMComopsition._encode_memory</p>
</div></blockquote>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="psyneulink.library.compositions.emcomposition.EMComposition._encode_memory">
<span class="sig-name descname"><span class="pre">_encode_memory</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">context</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#psyneulink.library.compositions.emcomposition.EMComposition._encode_memory" title="Permalink to this definition">¶</a></dt>
<dd><p>Encode inputs as memories
For each node in query_input_nodes and value_input_nodes,
assign its value to afferent weights of corresponding retrieved_node.
- memory = matrix of entries made up vectors for each field in each entry (row)
- memory_full_vectors = matrix of entries made up vectors concatentated across all fields (used for norm)
- entry_to_store = query_input or value_input to store
- field_memories = weights of Projections for each field</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="psyneulink.library.compositions.emcomposition.EMComposition.learn">
<span class="sig-name descname"><span class="pre">learn</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#psyneulink.library.compositions.emcomposition.EMComposition.learn" title="Permalink to this definition">¶</a></dt>
<dd><p>Override to check for inappropriate use of ARG_MAX or PROBABILISTIC options for retrieval with learning</p>
<dl class="field-list simple">
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><code class="xref py py-class docutils literal notranslate"><span class="pre">list</span></code></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="psyneulink.library.compositions.emcomposition.EMComposition._get_execution_mode">
<span class="sig-name descname"><span class="pre">_get_execution_mode</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">execution_mode</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#psyneulink.library.compositions.emcomposition.EMComposition._get_execution_mode" title="Permalink to this definition">¶</a></dt>
<dd><p>Parse execution_mode argument and return a valid execution mode for the learn() method</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="psyneulink.library.compositions.emcomposition.EMComposition._identify_target_nodes">
<span class="sig-name descname"><span class="pre">_identify_target_nodes</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">context</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#psyneulink.library.compositions.emcomposition.EMComposition._identify_target_nodes" title="Permalink to this definition">¶</a></dt>
<dd><p>Identify retrieval_nodes specified by <strong>target_field_weights</strong> as TARGET nodes</p>
<dl class="field-list simple">
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><code class="xref py py-class docutils literal notranslate"><span class="pre">list</span></code></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="psyneulink.library.compositions.emcomposition.EMComposition.infer_backpropagation_learning_pathways">
<span class="sig-name descname"><span class="pre">infer_backpropagation_learning_pathways</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">execution_mode</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">context</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#psyneulink.library.compositions.emcomposition.EMComposition.infer_backpropagation_learning_pathways" title="Permalink to this definition">¶</a></dt>
<dd><p>Create backpropapagation learning pathways for every Input Node –&gt; Output Node pathway
Flattens nested compositions:</p>
<blockquote>
<div><ul class="simple">
<li><p>only includes the Projections in outer Composition to/from the CIMs of the nested Composition
(i.e., to input_CIMs and from output_CIMs) – the ones that should be learned;</p></li>
<li><p>excludes Projections from/to CIMs in the nested Composition
(from input_CIMs and to output_CIMs), as those should remain identity Projections;</p></li>
</ul>
<p>see <a class="reference internal" href="AutodiffComposition.html#psyneulink.library.compositions.autodiffcomposition.AutodiffComposition.PytorchCompositionWrapper" title="psyneulink.library.compositions.autodiffcomposition.AutodiffComposition.PytorchCompositionWrapper"><code class="xref any py py-class docutils literal notranslate"><span class="pre">PytorchCompositionWrapper</span></code></a> for table of how Projections are handled and further details.</p>
</div></blockquote>
<p>Returns list of target nodes for each pathway</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="psyneulink.library.compositions.emcomposition.EMComposition.do_gradient_optimization">
<span class="sig-name descname"><span class="pre">do_gradient_optimization</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">retain_in_pnl_options</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">context</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">optimization_num</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#psyneulink.library.compositions.emcomposition.EMComposition.do_gradient_optimization" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute loss and use in call to autodiff_backward() to compute gradients and update PyTorch parameters.
Update parameters (weights) based on trial(s) executed since last optimization,
Reinitizalize minibatch_loss and minibatch_loss_count</p>
</dd></dl>

</dd></dl>

<dl class="py exception">
<dt class="sig sig-object py" id="psyneulink.library.compositions.emcomposition.EMCompositionError">
<em class="property"><span class="pre">exception</span> </em><span class="sig-prename descclassname"><span class="pre">psyneulink.library.compositions.emcomposition.</span></span><span class="sig-name descname"><span class="pre">EMCompositionError</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">error_value</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#psyneulink.library.compositions.emcomposition.EMCompositionError" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="psyneulink.library.compositions.emcomposition.FieldType">
<em class="property"><span class="pre">class</span> </em><span class="sig-prename descclassname"><span class="pre">psyneulink.library.compositions.emcomposition.</span></span><span class="sig-name descname"><span class="pre">FieldType</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">value</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">names</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">module</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">qualname</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">type</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">start</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">boundary</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#psyneulink.library.compositions.emcomposition.FieldType" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</section>
</section>


             </article>
             
            </div>
            <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="Subystems.html" class="btn btn-neutral float-right" title="Subsystems" accesskey="n" rel="next">Next <img src="_static/images/chevron-right-orange.svg" class="next-page"></a>
      
      
        <a href="ParameterEstimationComposition.html" class="btn btn-neutral" title="ParameterEstimationComposition" accesskey="p" rel="prev"><img src="_static/images/chevron-right-orange.svg" class="previous-page"> Previous</a>
      
    </div>
  

  

    <hr>

  

  <div role="contentinfo">
    <p>
        &copy; Copyright 2016, Jonathan D. Cohen.

    </p>
  </div>
    
      <div>
        Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>.
      </div>
     

</footer>

          </div>
        </div>

        <div class="psyneulink-content-right" id="psyneulink-content-right">
          <div class="psyneulink-right-menu" id="psyneulink-right-menu">
            <div class="psyneulink-side-scroll" id="psyneulink-side-scroll-right">
              <ul>
<li><a class="reference internal" href="#">EMComposition</a><ul>
<li><a class="reference internal" href="#contents">Contents</a></li>
<li><a class="reference internal" href="#overview">Overview</a></li>
<li><a class="reference internal" href="#creation">Creation</a><ul>
<li><a class="reference internal" href="#memory-specification"><em>Memory Specification</em></a></li>
<li><a class="reference internal" href="#fields"><em>Fields</em></a></li>
<li><a class="reference internal" href="#retrieval-and-storage"><em>Retrieval and Storage</em></a></li>
<li><a class="reference internal" href="#learning"><em>Learning</em></a></li>
</ul>
</li>
<li><a class="reference internal" href="#structure">Structure</a><ul>
<li><a class="reference internal" href="#input"><em>Input</em></a></li>
<li><a class="reference internal" href="#memory"><em>Memory</em></a></li>
<li><a class="reference internal" href="#output"><em>Output</em></a></li>
</ul>
</li>
<li><a class="reference internal" href="#execution">Execution</a><ul>
<li><a class="reference internal" href="#processing"><em>Processing</em></a></li>
<li><a class="reference internal" href="#training"><em>Training</em></a></li>
<li><a class="reference internal" href="#visualizing-the-emcomposition"><em>Visualizing the EMComposition</em></a></li>
<li><a class="reference internal" href="#memory-template"><em>Memory Template</em></a></li>
<li><a class="reference internal" href="#field-weights"><em>Field Weights</em></a></li>
</ul>
</li>
<li><a class="reference internal" href="#class-reference">Class Reference</a></li>
</ul>
</li>
</ul>

            </div>
          </div>
        </div>
      </section>
    </div>

  


  

     
       <script type="text/javascript" id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
         <script data-url_root="./" id="documentation_options" src="_static/documentation_options.js"></script>
         <script src="_static/jquery.js"></script>
         <script src="_static/underscore.js"></script>
         <script src="_static/doctools.js"></script>
     

  

  <script type="text/javascript" src="_static/js/vendor/popper.min.js"></script>
  <script type="text/javascript" src="_static/js/vendor/bootstrap.min.js"></script>
  <script type="text/javascript" src="_static/js/theme.js"></script>

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

  <!-- Begin Footer -->

  <footer class="site-footer" id="docs-tutorials-resources">
    <div class="container footer-container">
      <div class="footer-logo-wrapper">
        <a href="https://princetonuniversity.github.io/PsyNeuLink/" class="footer-logo"></a>
      </div>

  </footer>

  

  <!-- End Footer -->

  <!-- Begin Mobile Menu -->

  <div class="mobile-main-menu">
    <div class="container-fluid">
      <div class="container mobile-logo-container">
        <div class="mobile-main-menu-header-container">
          <a class="header-logo" href="https://princetonuniversity.github.io/PsyNeuLink/" aria-label="PsyNeuLink"></a>
          <a class="main-menu-close-button" href="#" data-behavior="close-mobile-menu"></a>
        </div>
      </div>
    </div>

    <div class="mobile-main-menu-links-container">
      <div class="main-menu">
        <ul>
          <li>
            <a href="https://github.com/PrincetonUniversity/PsyNeuLink">Github</a>
          </li>
        </ul>
      </div>
    </div>
  </div>

  <!-- End Mobile Menu -->

  <script type="text/javascript" src="_static/js/vendor/anchor.min.js"></script>

  <script type="text/javascript">
    $(document).ready(function() {
      mobileMenu.bind();
      mobileTOC.bind();
      psyneulinkAnchors.bind();
      sideMenus.bind();
      scrollToAnchor.bind();
      highlightNavigation.bind();
      mainMenuDropdown.bind();

      // Add class to links that have code blocks, since we cannot create links in code blocks
      $("article.psyneulink-article a span.pre").each(function(e) {
        $(this).closest("a").addClass("has-code");
      });
    })
  </script>
</body>
</html>